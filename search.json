[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "실험계획법 2024 강의 노트",
    "section": "",
    "text": "서론\n이 온라인 교과서는 2024년 실험계회법 강의의 보조 교재입니다.\n강의교재는 임용빈 (2020) 를 참고하시기 바랍니다.",
    "crumbs": [
      "서론"
    ]
  },
  {
    "objectID": "index.html#필요한-r-라이브러리",
    "href": "index.html#필요한-r-라이브러리",
    "title": "실험계획법 2024 강의 노트",
    "section": "필요한 R 라이브러리",
    "text": "필요한 R 라이브러리\nlibrary(here)           # file pathways\nlibrary(tidyverse)      # data management, summary, and visualization\nlibrary(MASS)\nlibrary(knitr)\nlibrary(kableExtra)\n\nlibrary(agricolae)\nlibrary(emmeans)\n\n# 변량모형(혼합모형)\nlibrary(lme4)\nlibrary(lmerTest)\n\nlibrary(SixSigma)\nlibrary(FrF2)\nlibrary(unrepx)\n\nlibrary(rsm)\nlibrary(DoE.wrapper)\nlibrary(scatterplot3d)\n\n\n# ggplot 그래프에서 한글 사용\nlibrary(showtext)\nfont_add_google(\"Nanum Pen Script\", \"gl\")\nshowtext_auto()\n\n# 참고도서 데이터 \nlibrary(MontgomeryDAE)\n\n\n\n\n\n임용빈. 2020. Design Expert, Minitab 과 R을 활용한 실험계획법. 자유아카데미.",
    "crumbs": [
      "서론"
    ]
  },
  {
    "objectID": "qmd/oneway.html",
    "href": "qmd/oneway.html",
    "title": "1  일원배치법",
    "section": "",
    "text": "1.1 두 집단의 평균 비교",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>일원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/oneway.html#두-집단의-평균-비교",
    "href": "qmd/oneway.html#두-집단의-평균-비교",
    "title": "1  일원배치법",
    "section": "",
    "text": "1.1.1 t-검정\n기초통계학에서 나오는 가장 기본적이고 자주 쓰이는 가설검정 방법은 두 집단의 평균의 차이를 검정하는 t-검정(t-test)이다.\n교과서 2장 예제 2.2 를 다시 보자. 공장의 두 개 라인에서 생산되는 시멘트의 인장강도에 유의한 차이가 있는지 통계적 가설 검정을 수행하려고 한다. 첫 번째 생산라인을 \\(1\\), 두 번째 생산라인을 \\(2\\) 라고 했을 때 각각의 라인에서 시멘트 인장강도의 평균을 \\(\\mu_1\\), \\(\\mu_2\\)이라고 하자.\n여기서 고려해야할 가설은 다음과 같다.\n\\[ H_0: \\mu_1 = \\mu_2 \\quad \\text{vs.} \\quad H_1: \\mu_1  \\ne \\mu_2 \\]\n두 집단이 분산이 동일한 정규분포 \\(N(\\mu_1, \\sigma^2)\\), \\(N(\\mu_2, \\sigma^2)\\)를 따른다고 가정하고 다음과 같이 각각 \\(n_1\\), \\(n_2\\)개의 독립 표본을 얻었다고 하자.\n\\[ y_{11}, y_{12}, \\dots, y_{1 n_1} \\sim N(\\mu_1, \\sigma^2), \\quad y_{21}, y_{22}, \\dots, y_{2 n_2} \\sim N(\\mu_2, \\sigma^2) \\]\n위의 가설을 다음과 같은 t-통계량을 이용하여 검정할 수 있다.\n\\[ t_0 =\\frac {\\bar y_1 -\\bar y_2 } {  s_p \\sqrt{1/n_1 + 1/n_2}} \\]\n여기서 \\(\\bar y_1\\), \\(\\bar y_2\\)은 두 생산라인에서 추출된 표본의 평균을 나타내고 \\(n_1\\), \\(n_2\\) 은 각 집단의 표본 개수를 나타낸다. 또한 \\(s_p^2\\) 은 두 집단의 공통분산 추정량이며 다음과 같이 계산한다.\n\\[ \\hat \\sigma^2 = s_p^2 =  \\frac { \\sum_{i=1}^{n_1} (y_{1i} -\\bar y_1)^2 + \\sum_{i=1}^{n_2} (y_{2i} -\\bar y_2)^2 } { n_1 + n_2 -2} \\]\n위에서 구한 t-통계량의 절대값이 크다면 귀무가설 \\(H_0\\) 에 반대되는 증거이다. 유의수준을 \\(\\alpha\\)라고 했을 때 t-통계량 \\(t_0\\)의 절대값이 자유도 \\(df=n_1 + n_2 -2\\) 를 가지는 t-분포의 상위 \\(\\alpha/2\\) 분위수보다 크면 귀무가설을 기각하고 대립가설 \\(H_1\\)을 채택한다.\n\\[ \\text{ Reject } H_0  \\quad \\text { if } ~~ |t_0| &gt; t(1-\\alpha/2, n_1 + n_2 -2 ) \\]\n가설 검정은 p-값(p-value)을 구하고 그 값이 \\(\\alpha\\)보다 작으면 귀무가설을 기각하는 방법을 사용할 수 있다.\n\\[ \\text{ Reject } H_0  \\quad \\text { if    p-value } &lt; \\alpha \\]\n여기서 \\(p-value\\) 는 다음과 같이 계산할 수 있으며 \\(t(n_1 + n_1 -2 )\\)는 자유도가 \\(n_1 + n_2 -2\\)을 가지는 \\(t\\)-분포를 따르는 확률변수이다. .\n\\[ \\text {p-value }=2 P[ t(n_1 + n_2 -2 ) &gt;|t_0|] \\]\nR 에서 함수 t.test를 이용하여 두 집단에 대한 t-검정을 실시해 보자.\n\nline1 &lt;- c(16.9, 16.4, 17.2, 16.4, 16.5, 17.0, 17.0, 17.2, 16.6, 16.6)\nline2 &lt;- c(16.6, 16.8, 17.4, 17.1, 17.0, 16.9, 17.3, 17.0, 17.1, 17.3)\ndf220 &lt;- data.frame(line1, line2)\n\ndf220\n\n   line1 line2\n1   16.9  16.6\n2   16.4  16.8\n3   17.2  17.4\n4   16.4  17.1\n5   16.5  17.0\n6   17.0  16.9\n7   17.0  17.3\n8   17.2  17.0\n9   16.6  17.1\n10  16.6  17.3\n\ndf22&lt;- df220 %&gt;% pivot_longer(cols = everything(), names_to = \"line\", values_to = \"strength\") %&gt;% dplyr::arrange(line)\n\ndf22\n\n# A tibble: 20 × 2\n   line  strength\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 line1     16.9\n 2 line1     16.4\n 3 line1     17.2\n 4 line1     16.4\n 5 line1     16.5\n 6 line1     17  \n 7 line1     17  \n 8 line1     17.2\n 9 line1     16.6\n10 line1     16.6\n11 line2     16.6\n12 line2     16.8\n13 line2     17.4\n14 line2     17.1\n15 line2     17  \n16 line2     16.9\n17 line2     17.3\n18 line2     17  \n19 line2     17.1\n20 line2     17.3\n\nt.test(strength~line, df22, paired = FALSE, var.equal = TRUE, conf.level = 0.95)\n\n\n    Two Sample t-test\n\ndata:  strength by line\nt = -2.1338, df = 18, p-value = 0.04687\nalternative hypothesis: true difference in means between group line1 and group line2 is not equal to 0\n95 percent confidence interval:\n -0.535840211 -0.004159789\nsample estimates:\nmean in group line1 mean in group line2 \n              16.78               17.05 \n\n\n유의수준을 0.05로 정하면 t-검정의 결과 p-값이 유의수준 보다 작아서 귀무가설을 기각하고 대립가설 \\(H_1\\)을 채택한다. 즉, 두 라인의 시멘트 인장강도 평균은 유의하게 다르다.\n\n\n1.1.2 t-검정의 재구성\n이제 두 집단에 대한 가설 검정을 세 개 이상인 여러 개의 집단으로 확장하는 경우를 생각해보자. 여러 개의 집단에 대한 가설 검정을 고려하기 전에 두 집단에 대한 t-검정을 약간 재구성하여 여러 평균들의 차이를 비교하는 검정법에 대한 일반적인 개념을 제시해 보려고 한다. 이제 t-검정에서 검정 통계량의 분자와 분모를 따로 살펴보자\n\\[ t_0 =\\frac {\\bar y_1 -\\bar y_2 } { s_p \\sqrt{1/n_1 + 1/n_2}} \\]\nt-검정 통계량의 분자는 집단 간의 평균의 차이를 나타낸다. 즉 \\(\\bar y_1 -\\bar y_2\\)는 두 집단의 표본 평균의 차이를 추정하는 양이고 그 차이가 크면 클수록 두 집단의 모평균의 차이 \\(\\mu_1 - \\mu_2\\)가 크다는 것을 의미한다.\nt-검정 통계량의 분모는 두 집단의 공통분산 추정량 \\(\\hat \\sigma^2 =s_p^2\\)에 비례한다. 즉 집단 내의 변동을 반영하는 \\(s_p^2\\) 이 크면 클수록 t-검정 통계량은 그 크기가 작아져서 귀무가설의 기각을 어렵게 한다.\n\\[ s^2_p = \\frac{\\sum_{i=1}^{n_1} (y_{1i} -\\bar y_1)^2 + \\sum_{i=1}^{n_2} (y_{2i} -\\bar y_2)^2}{n_1+n_2-2} \\]\n또한 t-검정 통계량는 표본의 수(\\(n_1\\)과 \\(n_2\\))에 비례한다. 즉 표본의 수가 증가햐면 t-검정 통계량이 커지게 된다.\n정리해보면 t-검정 통계량은 집단 간의 변동(between-group variation)을 집단 내의 변동(within-group variation) 으로 나누어준 값이다. 다른 말로 급간 변동과 급내 변동을 사용하기도 한다.\n이제 t-검정 통계량을 제곱하면 다음과 같이 표현할 수 있다.\n\\[  t_0^2 =\\frac { (\\bar y_1 -\\bar y_2)^2 } { s_p^2 (1/n_1 + 1/n_2)} = \\frac{\\text{between-group variation}} {\\text{within-group variation}} \\]\n두 집단의 평균을 비교하는 t-검정 통계량은 집단 간의 변동(집단 간의 평균들의 차이)과 집단 내의 변동(집단 내 관측치들의 퍼진 정도)의 비율로 구성된 통계량으로 생각할 수 있으며 이러한 개념을 3개 이상의 집단을 비교하는 경우로 쉽게 확장할 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>일원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/oneway.html#일원배치법",
    "href": "qmd/oneway.html#일원배치법",
    "title": "1  일원배치법",
    "section": "1.2 일원배치법",
    "text": "1.2 일원배치법\n\n1.2.1 일원배치을 이용한 랜덤화 실험계획법\n\n일원배치법(one-way randomization design)은 관심있는 중요한 한 개 요인이 반응변수에 어떠한 영향을 미치는지 알아보는 실험법이다.\n반응값에 영향을 주는 다른 요인들에 대한 정보가 많고 사전 실험이 많이 이루어져서 가장 중요한 요인의 미세한 영향을 조사하고자 할 때 유용하다.\n처리를 제외한 다른 요인들의 영향을 적절하게 통제할 수 있어야 한다.\n\n\n\n1.2.2 실험배정의 랜덤화\n실험배정의 랜덤화 방법은 교과서 38-41 페이지 참조\n\n\n\n1.2.3 예제 3.1 - 자료\n이 실험에서 요인은 직물이며 4개 수준은 4개의 납품업체에서 공급한 서로 다른 직물이다. 실험 목적은 4개의 직물의 긁힘에 대한 저항력을 비교하는 실험이다. 각 업체마다 4개의 제품을 랜덤하게 선택하여 일원배치법으로 마모도 검사를 실시하였다.\n\ncompany&lt;- as.factor(rep(c(1:4), each=4))\nresponse&lt;- c(1.93, 2.38, 2.20, 2.25,\n             2.55, 2.72, 2.75, 2.70,\n             2.40, 2.68, 2.32, 2.28,\n             2.33, 2.38, 2.28, 2.25)\ndf31 &lt;- data.frame(company=company, response= response)\n\ndf31\n\n   company response\n1        1     1.93\n2        1     2.38\n3        1     2.20\n4        1     2.25\n5        2     2.55\n6        2     2.72\n7        2     2.75\n8        2     2.70\n9        3     2.40\n10       3     2.68\n11       3     2.32\n12       3     2.28\n13       4     2.33\n14       4     2.38\n15       4     2.28\n16       4     2.25\n\nggplot(df31, aes(company, response)) +   geom_point(aes(colour = factor(company)), size = 2)\n\n\n\n\n\n\n\n\n실험에서는 처리 이외의 다른 요인들이 적절하게 통제되는 것이 매우 중요하다. 4개의 처리 외에 마모도 검사의 결과에 영향을 미칠 수 있는 다른 요인을 생각해 보자.\n\n검사를 수행하는 사람\n마모도를 검사하는 도구 또는 기계\n검사를 실시하는 환경 (측정 시간, 장소 등)\n마모도 검사의 배정을 완전 임의(completely randomized)로 할 수 있는지?\n\n일원배치법으로 실험을 진행할 떄 다음과 같은 상항들을 고려해야 한다.\n\n처리 이외의 다른 요인들을 적절하게 통제할 수 있는가?\n어떤 경우에 완전한 랜덤화가 불가능한가? 이러한 경우 실험의 배정을 어떻게 해야 할까?\n\n\n\n1.2.4 일원배치법의 자료 구조와 모형\n\n일원배치법에서의 자료 구조는 교과서 41-44 페이지 참조\n\n일원배치법 실험에서는 하나의 요인 A 의 효과를 측정한다. 요인 A 에 대하여 서로 다른 a 개의 수준(\\(A_1, A_2, \\dots, A_a\\))의 효과를 비교한다고 가정하자. 각 수준에 대하여 \\(r_i\\) 개의 반응값을 반복 측정한다.\n이제 \\(i\\)번 수준에서 측정된 \\(j\\)번째 반응변수의 값을 \\(x_{ij}\\)라고 하자. 일원배치법에서 측정된 자료들은 다음과 같은 모형을 가진다고 가정한다.\n\\[\nx_{ij} = \\mu_i + e_{ij} \\text{ where } e_{ij} \\sim N(0,\\sigma_E^2)\n\\tag{1.1}\\]\n여기서 오차항 \\(e_{ij}\\)는 모두 독립이다.\n첨자 \\(i\\)는 실험의 수준에 나타낸다 (\\(i=1, 2, \\cdots, a\\)). 균형자료의 경우는 모든 수준에 대하여 반복수가 같은 경우이다 (\\(j=1,2,\\cdots,r\\)). 불균형자료의 경우는 수준에 대하여 반복수가 다른 경우이다 (\\(j=1,2,\\cdots,r_i\\)). \n식 1.1 은 일반적으로 평균모형(mean model) 이라고 부르며 모형의 이름대로 모두 \\(\\mu_i\\)는 \\(i\\)번째 수준의 평균을 의미한다.\n\\[ E(x_{ij}) = E(\\mu_i + e_{ij}) = \\mu_i \\]\n이제 식 1.1 을 약각 변형하여 다른 형식의 모형을 만들어 보자.\n\\[\\begin{align*}\nx_{ij} & = \\mu_i + e_{ij} \\\\\n      & = \\mu + (\\mu_i - \\mu) + e_{ij} \\\\\n      & = \\mu + \\alpha_i + e_{ij}\n\\end{align*}\\]\n위의 모형에서 모수 \\(\\mu\\)는 반응값의 전체 평균을 의미하며 \\(\\alpha_i = \\mu_i - \\mu\\)는 \\(i\\)번째 수준의 평균이 전체 평균과 어떻게 다른지 나타내는 수준의 상대적 효과를 의미한다.\n다음의 식으로 정의된 일원배치 모형을 주효과모형(main effect model) 이라고 부른다. 모수 \\(\\alpha_i\\)는 \\(i\\) 번째 집단의 효과(처리 효과; treatment effect)를 나타낸다고 할 수 있다.\n\\[\nx_{ij} = \\mu + \\alpha_i + e_{ij} \\text{ where } e_{ij} \\sim N(0,\\sigma_E^2)\n\\tag{1.2}\\]\n여기서 오차항 \\(e_{ij}\\)는 모두 독립이며 다음과 같은 제약조건이 있다.\n\\[\n\\sum_{i=1}^a \\alpha_i = 0\n\\tag{1.3}\\]\n식 1.3 의 제약조건은 모수의 개수(\\(a+1\\))가 그룹의 개수(\\(a\\))보다 많아서 발생하는 문제를 해결하기 위하여 모수에 대한 제약 조건 1개를 고려해서 모수의 개수와 그룹의 개수를 맞추어준 것이다. 나중에 이러한 제약조건에 대한 이론을 자세히 다루기로 한다.\n식 1.3 의 제약조건은 sum to zero조건이라고 부르며 문제를 해결하는 유일한 조건은 아니다. 예를 들어서 조건 식 1.3 의 제약조건을 대신하여 \\(\\alpha_1=0\\) 인 set to zero 조건을 사용할 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>일원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/oneway.html#분산분석",
    "href": "qmd/oneway.html#분산분석",
    "title": "1  일원배치법",
    "section": "1.3 분산분석",
    "text": "1.3 분산분석\n\n1.3.1 모형과 가설\n집단의 모평균을 편의상 \\(\\mu_1, \\mu_2, \\cdots, \\mu_a\\) 이라고 하자. 평균모형 식 1.1 을 가정하고 집단들 사이에 차이가 있는지에 대한 가설은 다음과 같다.\n\\[ H_0: \\mu_1 = \\mu_2 =\\dots =\\mu_a \\quad \\text{vs.} \\quad H_1: \\text{ not } H_0 \\]\n위의 가설에서 주의할 점은 대립가설 \\(H_1\\)의 경우애 평균들이 서로 다른 경우가 매우 다양하다는 것이다. 예를 들어 집단이 3개 인 경우 \\(\\mu_1 = \\mu_2  &lt; \\mu_3\\)일 수 도 있고 \\(\\mu_1 &lt; \\mu_2  &lt; \\mu_3\\) 있으며 이 외에 매우 다양한 경우들이 있다.\n이제 효과모형 식 1.2 을 고려하면 집단들 사이에 차이가 있는지에 대한 가설을 다음과 같이 바꿀수 있다. 집단에 대한 효과가 모두 0이 되면 집단 간의 평균에 대한 차이는 없다.\n\\[\nH_0: \\alpha_1 = \\alpha_2 =\\cdots=\\alpha_a =0  \\quad \\text{vs.} \\quad H_1: \\text{ not } H_0\n\\tag{1.4}\\]\n\n\n1.3.2 변동의 분해\n이제 앞 절에서 생각해본 t-검정의 재구성처럼 집단 간의 변동(각 집단의 평균의 차이가 얼마나 나는지에 대한 통계량)과 집단 내의 변동(각 집단내에서 관측값들의 퍼진 정도)를 측정하는 통계량을 찾아서 검정 통계량을 구성해 보자.\n일단 다음과 같이 전체 평균과 집단의 평균을 정의하자.\n\\[ \\bar{\\bar {x}} =  \\frac{\\sum_{i=1}^a \\sum_{j=1}^r x_{ij}}{ar} =\\frac{T}{ar}, \\quad  \\bar {x}_{i.} =   \\frac{\\sum_{j=1}^r x_{ij}}{r} = \\frac{T_{i.}}{r} \\]\n이제 하나의 관측값 \\(x_{ij}\\)과 전체 평균 \\(\\bar{\\bar {x}}\\) 간의 편차(deviation)를 다음과 같이 분해해 보자.\n\\[\n\\underbrace{ x_{ij} - \\bar{\\bar {x}} }_{\\text{total deviation}}  = \\underbrace{ ( x_{ij} - \\bar {x}_{i.} )}_{\\text{within-group deviation}} + \\underbrace{(\\bar {x}_{i.} - \\bar{\\bar {x}} )}_{\\text{between-group deviation}}\n\\tag{1.5}\\]\n식 1.5 에서 집단 평균과 총 평균의 편차 (\\(\\bar {x}_{i.} - \\bar{\\bar {x}}\\))는 처리의 효과를 측정할 수 있는 통계량이다. 집단 간의 차이를 반영하는 양으로 처리 효과 \\(\\alpha_i\\)들에 의하여 발생한다.\n집단 내의 관측값과 집단 평균의 차이 (\\(x_{ij} - \\bar {x}_{i.}\\))는 집단 내의 변동을 나타내는 통계량으로 측정 오차 \\(e_{ij}\\)에 의하여 발생한다.\n식 1.5 의 각 편차들은 양수와 음수로서 부호를 가지기 때문에 이를 변동으로 표현하기 위하여 차이를 제곱하여 합친 제곱합(sum of squares)을 고려해 보자.\n\\[\\begin{align*}\n\\sum_{i=1}^a \\sum_{j=1}^r (x_{ij} - \\bar{\\bar {x}})^2\n    & = \\sum_{i=1}^a \\sum_{j=1}^r \\left [ ( x_{ij} - \\bar {x}_{i.} ) + (\\bar {x}_{i.} - \\bar{\\bar {x}} ) \\right ]^2 \\\\\n    & = \\sum_{i=1}^a \\sum_{j=1}^r ( x_{ij} - \\bar {x}_{i.} )^2 + \\sum_{i=1}^a \\sum_{j=1}^r (\\bar {x}_{i.} - \\bar{\\bar {x}} )^2 + 2   \\sum_{i=1}^a \\sum_{j=1}^r ( x_{ij} - \\bar {x}_{i.} ) (\\bar {x}_{i.} - \\bar{\\bar {x}} ) \\\\\n    & = \\sum_{i=1}^a \\sum_{j=1}^r ( x_{ij} - \\bar {x}_{i.} )^2 + \\sum_{i=1}^a r (\\bar {x}_{i.} - \\bar{\\bar {x}} )^2 + 0 (why?) \\\\\n\\end{align*}\\]\n결과적으로 다음과 같은 변동의 분해를 제곱합의 형식으로 얻을 수 있다.\n\\[\n\\underbrace{ \\sum_{i=1}^a \\sum_{j=1}^r (x_{ij} - \\bar{\\bar {x}})^2  }_{\\text{total variation}}  = \\underbrace{ \\sum_{i=1}^a \\sum_{j=1}^r ( x_{ij} - \\bar {x}_{i.} )^2 }_{\\text{within-group variation}} + \\underbrace{\\sum_{i=1}^a \\sum_{j=1}^r (\\bar {x}_{i.} - \\bar{\\bar {x}} )^2 }_{\\text{between-group variation}}\n\\tag{1.6}\\]\n분해 식 1.6 에서 나타난 각 제곱합에 대한 이름과 의미를 살펴보자.\n\n\\(SS_T\\)를 총 제곱합(Total Sum of Squares)이라고 부르며 자료의 전체 변동을 의미한다.\n\n\\[ SS_T = \\sum_{i=1}^a \\sum_{j=1}^r (x_{ij} - \\bar{\\bar {x}})^2 \\]\n\n\\(SS_E\\)를 잔차 제곱합(Residual Sum of Squares)이라고 부르며 관측 오차에 발생된 집단 내의 변동 또는 급내 변동(within-group variation)을 의미한다.\n\n\\[ SS_E = \\sum_{i=1}^a \\sum_{j=1}^r  ( x_{ij} - \\bar {x}_{i.} )^2 \\]\n\n\\(SS_A\\)를 처리 제곱합(Treatment Sum of Squares)이라고 부르며 처리들의 차이로 발생하는 변동으로거 집단 간의 변동 또는 급간 변동(bwtween-group variation)을 의미한다.\n\n\\[ SS_A = \\sum_{i=1}^a \\sum_{j=1}^r (\\bar {x}_{i.} - \\bar{\\bar {x}} )^2 =\\sum_{i=1}^a r (\\bar {x}_{i.} - \\bar{\\bar {x}} )^2 \\]\n이제 분해 식 1.6 을 다음과 같이 나타낼수 있다.\n\\[\nSS_T = SS_A + SS_E\n\\tag{1.7}\\]\n위의 분해식에서 볼 수 있듯이 집단 간의 변동의 크기를 나타내는 처리제곱합이 커질수록, 또는 집단내의 변동의 크기를 나타내는 오차제곱합이 작아질수록 귀무가설에 반대되는(즉, 집단 간의 평균이 유의한 차이가 난다는) 증거가 강해진다.\n\n\n1.3.3 자유도\n제곱합은 편차(deviation)의 제곱들을 더한 형태로서 각 제곱합들에 대하여 해당하는 자유도(degrees of freedom; df 또는 \\(\\phi\\)로 표기)를 구할 수 있다.\n제곱합의 자유도 = 제곱합을 구성하는 편차의 개수 – 선형제약 조건의 개수 \n각 제곱합에 대한 선형제약조건은 편차들의 합이 0이 되는 조건이다. 이제 식 식 1.7 에 주어진 제곱합의 자유도에 대한 정보를 다음과 같이 정리할 수 있다.\n\n\n\n\n\n\n\n\n\n\n제곱합\n편차의 개수\n제약조건\n제약조건의 수\n자유도\n\n\n\n\n\\(SS_T\\)\n\\(ar\\)\n\\(\\sum_{i=1}^a \\sum_{j=1}^r (x_{ij} - \\bar{\\bar {x}})=0\\)\n1\n\\(\\phi_T= ar-1\\)\n\n\n\\(SS_A\\)\n\\(a\\)\n\\(\\sum_{i=1}^a (\\bar {x}_{i.} - \\bar{\\bar {x}} ) =0\\)\n1\n\\(\\phi_A=a-1\\)\n\n\n\\(SS_E\\)\n\\(ar\\)\n\\(\\sum_{j=1}^r ( x_{ij} - \\bar {x}_{i.} ) =0, i=1,2,..,a\\)\na\n\\(\\phi_E=ar-a\\)\n\n\n\n\n\n1.3.4 평균제곱합과 F-통계량\n이제 가설 식 4.6 을 검정하기 위한 통계량을 구성해 보자. 먼저 다음과 같은 제곱합들을 각 자유도로 나눈 평균제곱합(Mean Sum of Squares)를 정의한다.\n\\[\nMS_A = \\frac{SS_A}{\\phi_A}, \\quad MS_E =\\frac{SS_E}{\\phi_E}\n\\tag{1.8}\\]\n앞 절에서 t-검정을 재구성하면서 알아본 통계량의 의미를 다시 생각해 보자. 집단 간의 변동과 집단 내의 변동의 상대적 비율로 그룹 간의 차이를 검정할 수 있다는 개념을 확장하여 다음과 같은 F-통계량 \\(F_0\\) 를 만들어 보자.\n\\[\nF_0 =  \\frac{MS_A}{MS_E} = \\frac{\\text{between-group variation}} {\\text{within-group variation}}\n\\tag{1.9}\\]\n위 식 1.9 에서 정의된 F-통계량은 그룹 간에 평균의 차이가 클수록, 그룹 내의 차이가 작을 수록 그 값이 커진다. 따라서 F-통계량의 값이 크면 클수록 귀무가설에 반대되는 증거가 강해진다.\n이렇게 전체의 변동을 집단 간의 변동과 집단 내의 변동으로 나누어 집단 간의 평균의 차이를 추론하는 방법을 분산분석(Analysis of Variance, ANOVA)이라고 한다.\n\n\n1.3.5 분산분석을 이용한 F-검정\n이제 식 1.9 에서 정의된 F-통계량을 이용하여 가설 식 4.6 를 검정하는 통계적 방법을 만들어 보자. 일단 두 제곱합의 통계적 성질은 다음과 같다.\n\n잔차 제곱합을 오차항의 분산으로 나눈 통계량은 자유도가 \\(\\phi_E\\) 를 가지는 카이제곱 분포를 따른다.\n\n\\[ \\frac{SS_E}{\\sigma_E^2}  \\sim \\chi^2(\\phi_E) \\]\n\n귀무가설이 참인 경우 처리 제곱합을 오차항의 분산으로 나눈 통계량은 자유도가 \\(\\phi_A\\) 를 가지는 카이제곱 분포를 따른다.\n\n\\[ \\frac{SS_A}{\\sigma_E^2}  \\sim \\chi^2(\\phi_A) \\quad \\text{ under } H_0  \\]\n\n잔차 제곱합과 처리 제곱합은 서로 독립이다.\n\n따라서 귀무가설이 참인 경우 F-통계량은 자유도가 \\(\\phi_A, \\phi_E\\)를 가지는 F-분포를 따른다.\n\\[\nF_0 =  \\frac{MS_A}{MS_E} = \\frac{ \\tfrac{SS_A/\\sigma_E^2}{\\phi_A}} {\\tfrac{SS_E/\\sigma_E^2}{\\phi_E }}  \\sim F(\\phi_A, \\phi_E) \\quad \\text{ under } H_0  \n\\tag{1.10}\\]\n유의수준 \\(\\alpha\\)에서 F-통계량이 기각역을 벗어나면 귀무가설을 기각한다.\n\\[ \\text{ Reject } H_0 \\text{ if } F_0 &gt; F(1-\\alpha, \\phi_A, \\phi_E)  \\]\n또는 다음과 같이 게산된 p-값이 유의수준 \\(\\alpha\\) 보다 작으면 귀무가설을 기각한다.\n\\[ p-value = P[F(\\phi_A, \\phi_E) &gt; F_0  ]   \\]\nF-통계량을 정의할 때 편리하고 유용하게 사용되는 것이 다음과 같은 분산분석표(ANOVA table)이다.\n\n\n\n\n\n\n\n\n\n\n\n요인\n제곱합\n자유도\n평균제곱합\n\\(F_0\\)\np-값\n\n\n\n\n처리\n\\(SS_A\\)\n\\(\\phi_A = a-1\\)\n\\(MS_A=SS_A/\\phi_A\\)\n\\(F_0=MS_A/MS_E\\)\n\\(P[F(\\phi_A, \\phi_E) &gt; F_0  ]\\)\n\n\n잔차\n\\(SS_E\\)\n\\(\\phi_E=a(r-1)\\)\n\\(MS_E=SS_E/\\phi_E\\)\n\n\n\n\n총합\n\\(SS_T\\)\n\\(\\phi_T =  ar-1\\)\n\n\n\n\n\n\n\n\n1.3.6 분산분석 후의 추정\n분산분석에서 고려한 요인 A의 수준에 따라서 반응값의 평균에 유의한 차이가 있다고 결론이 나면 그룹 간의 모평균을 차이에 대한 더 자세한 정보가 필요하다. 즉 집단들의 평균이 서로 유의하게 다르거나 같은지에 대한 정보를 얻는 것이 중요하다.\n일단 모집단의 분산 \\(\\sigma_E^2\\) 에 대한 추정은 잔차제곱합의 분포를 이용하면 다음과 같은 불편추정량을 얻을 수 있다.\n\\[ \\hat \\sigma_E^2 = MS_E, \\quad E(MS_E) = \\sigma_E^2 \\]\n다음으로 각 수준(집단)에 대한 평균에 대한 추정량은 표본평균 \\(\\bar {x}_{i.}\\) 이며\n\\[ \\hat \\mu_i = \\widehat {\\mu + \\alpha_i} = \\bar {x}_{i.}  \\quad E(\\bar {x}_{i.}) =\\mu_i \\]\n\\(100(1-\\alpha)\\) % 신뢰구간(confidence interval)은 다음과 같이 주어진다.\n\\[ \\bar {x}_{i.} \\pm t(1-\\alpha/2, \\phi_E) \\sqrt{ \\frac{MS_E}{r}} \\]\n야기서 \\(t(1-\\alpha/2, \\phi_E)\\)는 자유도 \\(\\phi_E\\)를 가지는 t-분포의 \\(1-\\alpha/2\\) 분위수를 의미한다.\n이제 두 개의 수준에 대한 평균의 차이에 대한 통계적 추론을 생각해 보자. 수준 \\(A_i\\)와 \\(A_j\\)의 평균의 차이에 대한 추정과 검정을 하려고 한다.\n\\[ \\delta_{ij} = \\mu_i-\\mu_j = \\alpha_i - \\alpha_j \\]\n두 평균의 차이 \\(\\delta_{ij}\\) 에 대한 \\(100(1-\\alpha)\\) % 신뢰구간은 다음과 같이 주어진다.\n\\[\n( \\bar {x}_{i.} - \\bar {x}_{j.})   \\pm t(1-\\alpha/2, \\phi_E) \\sqrt{ \\frac{2MS_E}{r}}\n\\tag{1.11}\\]\n신뢰구간 식 1.11 에서 두 개의 표본 평균 \\(\\bar {x}_{i.}\\)와 \\(\\bar {x}_{j.}\\) 은 서로 독립인 것에 유의하자.\n이제 마지막으로 두 평균의 차이 \\(\\delta_{ij}\\) 에 대한 가설을 검정하여고 한다.\n\\[ H_0 : \\alpha_i = \\alpha_j \\quad \\text{ vs. } \\quad H_1: \\alpha_i \\ne \\alpha_j \\]\n유의 수준 \\(\\alpha\\)에서 다음과 같은 조건을 만족하면 위의 귀무가설을 기각한다.\n\\[\n\\left | \\bar {x}_{i.} - \\bar {x}_{j.} \\right | &gt; t(1-\\alpha/2, \\phi_E) \\sqrt{ \\frac{2MS_E}{r}}\n\\tag{1.12}\\]\n식 1.12 에서 주어진 귀무 가설 \\(\\delta_{ij}=0\\) 을 기각하는 조건은 식 1.11 에 주어진 신뢰구간이 0 을 포함하지 않는 조건과 동일하다.\n식 1.12 에서 검정을 위한 조건의 우변을 최소유의차(least significant difference; LSD) 라고 부른다. 두 수준의 차이가 유의하려면 두 평균 차이의 절대값이 최소한 최소유의차의 값보다 커야한다.\n\\[  \\text{LSD} =t(1-\\alpha/2, \\phi_E) \\sqrt{ \\frac{2MS_E}{r}}  \\]\n\n\n1.3.7 예제 3.1 - ANOVA F-검정과 사후 추정\n다시 예제 3.1의 실험 자료를 고려한다.\n\ndf31\n\n   company response\n1        1     1.93\n2        1     2.38\n3        1     2.20\n4        1     2.25\n5        2     2.55\n6        2     2.72\n7        2     2.75\n8        2     2.70\n9        3     2.40\n10       3     2.68\n11       3     2.32\n12       3     2.28\n13       4     2.33\n14       4     2.38\n15       4     2.28\n16       4     2.25\n\ndf31s &lt;- df31 %&gt;% group_by(company)  %&gt;%  summarise(mean=mean(response), median= median(response), sd=sd(response), min=min(response), max=max(response))\n\ndf31s\n\n# A tibble: 4 × 6\n  company  mean median     sd   min   max\n  &lt;fct&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1        2.19   2.22 0.189   1.93  2.38\n2 2        2.68   2.71 0.0891  2.55  2.75\n3 3        2.42   2.36 0.180   2.28  2.68\n4 4        2.31   2.30 0.0572  2.25  2.38\n\n\n예제 3.1에서 실험의 목적은 4개의 직물의 긁힘에 대한 저항력을 비교하는 실험이다.\n\nggplot(df31, aes(company, response)) +\n  geom_boxplot() + \n  geom_line(data=df31s, aes(x=company, y=mean, group=1), size=1.5, col=\"#9ACBF9\") +\n  geom_point(data=df31s, aes(x=company, y=mean), col=\"darkblue\", size=3) +\n  theme_bw()\n\n\n\n\n\n\n\n\n이제 위에서 제시한 F-검정을 이용하여 납품 업체 간에 직물 마모도에 차이가 있는지 검정해보자.\n\\[ H_0: \\mu_1=\\mu_2=\\mu_3=\\mu_4 \\quad \\text{ vs. }\\quad H_1: \\text{ not } H_0 \\]\n\nanova.res &lt;- aov(response~company,data=df31) \nsummary(anova.res)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \ncompany      3 0.5240 0.17467   8.785 0.00235 **\nResiduals   12 0.2386 0.01988                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n위의 분산분석표에서 p-값이 유의수준 5% 보다 매우 작으므로 네 개의 직물에 대한 평균이 같다는 귀무가설을 기각한다. 따라서 4개의 납품업체에서 받은 직물의 저항력이 유의하게 다르다고 할 수 있다. 여기서 유의할 점은 ANOVA를 이용한 F-검정은 그룹 간의 차이가 있다는 것을 의미하지만 어떻게 다른지에 대한 정보를 주지 않는다.\n최소유의차(LSD) 방법에 의하여 처리 간의 평균을 신뢰구간을 구하고 차이가 있는지 검정할 수 있다.\n\n### Mean of response by factor\nresult1 &lt;- LSD.test(anova.res, \"company\", group=FALSE, console = TRUE)\n\n\nStudy: anova.res ~ \"company\"\n\nLSD t Test for response \n\nMean Square Error:  0.01988333 \n\ncompany,  means and individual ( 95 %) CI\n\n  response        std r         se      LCL      UCL  Min  Max    Q25   Q50\n1     2.19 0.18920888 4 0.07050414 2.036385 2.343615 1.93 2.38 2.1325 2.225\n2     2.68 0.08906926 4 0.07050414 2.526385 2.833615 2.55 2.75 2.6625 2.710\n3     2.42 0.18036999 4 0.07050414 2.266385 2.573615 2.28 2.68 2.3100 2.360\n4     2.31 0.05715476 4 0.07050414 2.156385 2.463615 2.25 2.38 2.2725 2.305\n     Q75\n1 2.2825\n2 2.7275\n3 2.4700\n4 2.3425\n\nAlpha: 0.05 ; DF Error: 12\nCritical Value of t: 2.178813 \n\nComparison between treatments means\n\n      difference pvalue signif.         LCL         UCL\n1 - 2      -0.49 0.0004     *** -0.70724487 -0.27275513\n1 - 3      -0.23 0.0397       * -0.44724487 -0.01275513\n1 - 4      -0.12 0.2520         -0.33724487  0.09724487\n2 - 3       0.26 0.0229       *  0.04275513  0.47724487\n2 - 4       0.37 0.0030      **  0.15275513  0.58724487\n3 - 4       0.11 0.2916         -0.10724487  0.32724487\n\nresult1\n\n$statistics\n     MSerror Df Mean       CV  t.value       LSD\n  0.01988333 12  2.4 5.875345 2.178813 0.2172449\n\n$parameters\n        test p.ajusted  name.t ntr alpha\n  Fisher-LSD      none company   4  0.05\n\n$means\n  response        std r         se      LCL      UCL  Min  Max    Q25   Q50\n1     2.19 0.18920888 4 0.07050414 2.036385 2.343615 1.93 2.38 2.1325 2.225\n2     2.68 0.08906926 4 0.07050414 2.526385 2.833615 2.55 2.75 2.6625 2.710\n3     2.42 0.18036999 4 0.07050414 2.266385 2.573615 2.28 2.68 2.3100 2.360\n4     2.31 0.05715476 4 0.07050414 2.156385 2.463615 2.25 2.38 2.2725 2.305\n     Q75\n1 2.2825\n2 2.7275\n3 2.4700\n4 2.3425\n\n$comparison\n      difference pvalue signif.         LCL         UCL\n1 - 2      -0.49 0.0004     *** -0.70724487 -0.27275513\n1 - 3      -0.23 0.0397       * -0.44724487 -0.01275513\n1 - 4      -0.12 0.2520         -0.33724487  0.09724487\n2 - 3       0.26 0.0229       *  0.04275513  0.47724487\n2 - 4       0.37 0.0030      **  0.15275513  0.58724487\n3 - 4       0.11 0.2916         -0.10724487  0.32724487\n\n$groups\nNULL\n\nattr(,\"class\")\n[1] \"group\"\n\n\n최소유의차(LSD) 방법에 의한 평균의 차이에 대한 결과를 이용하여 처리를 다음과 같이 그룹화 하여 보여줄 수 있다.\n\nresult2 &lt;- LSD.test(anova.res, \"company\", group=TRUE, console = TRUE)\n\n\nStudy: anova.res ~ \"company\"\n\nLSD t Test for response \n\nMean Square Error:  0.01988333 \n\ncompany,  means and individual ( 95 %) CI\n\n  response        std r         se      LCL      UCL  Min  Max    Q25   Q50\n1     2.19 0.18920888 4 0.07050414 2.036385 2.343615 1.93 2.38 2.1325 2.225\n2     2.68 0.08906926 4 0.07050414 2.526385 2.833615 2.55 2.75 2.6625 2.710\n3     2.42 0.18036999 4 0.07050414 2.266385 2.573615 2.28 2.68 2.3100 2.360\n4     2.31 0.05715476 4 0.07050414 2.156385 2.463615 2.25 2.38 2.2725 2.305\n     Q75\n1 2.2825\n2 2.7275\n3 2.4700\n4 2.3425\n\nAlpha: 0.05 ; DF Error: 12\nCritical Value of t: 2.178813 \n\nleast Significant Difference: 0.2172449 \n\nTreatments with the same letter are not significantly different.\n\n  response groups\n2     2.68      a\n3     2.42      b\n4     2.31     bc\n1     2.19      c\n\n\n\nresult2$groups\n\n  response groups\n2     2.68      a\n3     2.42      b\n4     2.31     bc\n1     2.19      c\n\nplot(result2)",
    "crumbs": [
      "<span class='chapter-number'>1</span>  <span class='chapter-title'>일원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twoway.html",
    "href": "qmd/twoway.html",
    "title": "2  이원배치법",
    "section": "",
    "text": "2.1 예제 4.1\n예제 4.1 은 교과서 89 페이지에 나온 분석 예제이다. 4종류의 사료(A)와 3종류의 돼지품종(B)이 체중 증가에 미치는 영향을 조사한 실험이다. 각 처리 조합마다 3회 반복실험하여 총 36개의 관측값을 얻었다.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>이원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twoway.html#예제-4.1",
    "href": "qmd/twoway.html#예제-4.1",
    "title": "2  이원배치법",
    "section": "",
    "text": "2.1.1 자료 읽기\n다음과 같은 순서로 자료를 가진 데이터프레임 df2을 만들어 보자.\n\nresponse&lt;- c(64, 66, 70, 72, 81, 64, \n             74, 51, 65, 65, 63, 58,\n             57, 43, 52, 47, 58, 67,\n             59, 68, 65, 66, 71, 59,\n             58, 39, 42, 58, 41, 46,\n             57, 61, 53, 53, 59, 38)\nresponse\n\n [1] 64 66 70 72 81 64 74 51 65 65 63 58 57 43 52 47 58 67 59 68 65 66 71 59 58\n[26] 39 42 58 41 46 57 61 53 53 59 38\n\n\n\nfood&lt;- factor(rep(c(1:4), each=9)) \nbreed&lt;- factor(rep(c(1:3), each=3))\nfood\n\n [1] 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 2 2 3 3 3 3 3 3 3 3 3 4 4 4 4 4 4 4 4 4\nLevels: 1 2 3 4\n\nbreed\n\n[1] 1 1 1 2 2 2 3 3 3\nLevels: 1 2 3\n\n\n\ndf2&lt;- data.frame(food, breed, response)\nhead(df2)\n\n  food breed response\n1    1     1       64\n2    1     1       66\n3    1     1       70\n4    1     2       72\n5    1     2       81\n6    1     2       64\n\n\n\n\n2.1.2 자료의 시각화와 기초 통계량\n이제 처리별로 효과를 시각적으로 비교하기 위하여 자료들에 대한 산점도와 상자그림을 그려보자\n\ndf2 %&gt;% \n  ggplot() +\n  aes(x = food , y = response, fill=breed, color=breed) +\n  geom_boxplot(alpha = 0.1, width = 0.75)\n\n\n\n\n\n\n\n\n\ndf2 %&gt;% \n  ggplot() +\n  aes(x = breed  , y = response, fill=food, color=food) +\n  geom_boxplot(alpha = 0.1, width = 0.75) \n\n\n\n\n\n\n\n\n위와 같이 두 요인의 조합으로 그림을 보는 것보다 각 요인별로 요약하여 보는 것도 유용하다.\n\ndf2 %&gt;% \n  ggplot( aes(x = food , y = response) ) +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n\ndf2 %&gt;% \n  ggplot( aes(x = breed , y = response))  +\n  geom_boxplot()\n\n\n\n\n\n\n\n\n다음으로 12개의 처리 조합에 대한 체중의 기초통계량(평균과 표준편차)을 구해보자.\n\ndf2s &lt;- df2 %&gt;% group_by(food, breed)  %&gt;%  summarise(mean=mean(response),  sd=sd(response))\ndf2s\n\n# A tibble: 12 × 4\n# Groups:   food [4]\n   food  breed  mean    sd\n   &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 1     1      66.7  3.06\n 2 1     2      72.3  8.50\n 3 1     3      63.3 11.6 \n 4 2     1      62    3.61\n 5 2     2      50.7  7.09\n 6 2     3      57.3 10.0 \n 7 3     1      64    4.58\n 8 3     2      65.3  6.03\n 9 3     3      46.3 10.2 \n10 4     1      48.3  8.74\n11 4     2      57    4   \n12 4     3      50   10.8 \n\n\n또한 각 요인에 대한 기초통계량도 구해보자.\n\ndf2s_food&lt;- df2 %&gt;% group_by(food)  %&gt;%  summarise(mean=mean(response),  sd=sd(response))\ndf2s_food\n\n# A tibble: 4 × 3\n  food   mean    sd\n  &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1      67.4  8.34\n2 2      56.7  8.08\n3 3      58.6 11.2 \n4 4      51.8  8.26\n\n\n\ndf2s_breed &lt;- df2 %&gt;% group_by(breed)  %&gt;%  summarise(mean=mean(response),  sd=sd(response))\ndf2s_breed\n\n# A tibble: 3 × 3\n  breed  mean    sd\n  &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1      60.2  8.74\n2 2      61.3 10.3 \n3 3      54.2 11.4 \n\n\n이제 위에서 계산된 처리 그룹에 대한 평균으로 상호작용 그림을 그려보자. 아래 그림에서 사료의 종류에 따라서 체중의 변화를 본 그림이다. 사료 1번에서 체중이 가장 크게 나타났고 다른 사료에 대해서는 체중이 줄어드는데 품종에 따라서 그 크기가 서로 다르다.\n\ndf2s %&gt;% \n  ggplot() +\n  aes(x = food , y = mean, color =breed) +\n  geom_line(aes(group = breed)) +\n  geom_point()\n\n\n\n\n\n\n\n\n아래 그림은 아래 그림에서 품종의 종류에 따라서 체중의 변화를 본 그림이다.\n\ndf2s %&gt;% \n  ggplot() +\n  aes(x = breed , y = mean, color =food) +\n  geom_line(aes(group = food)) +\n  geom_point()\n\n\n\n\n\n\n\n\n사료와 품종간에 상호 작용이 그림으로 나타나고 있지만 뚜렸하지 않고 해석하기도 힘들다.\n\n\n2.1.3 분산분석표와 가설검정\n이제 이원배치법에서의 가설검정을 수행하기 위하여 분산분석 표를 구해보자.\n\ndf2aov &lt;- aov(response ~ food*breed, data=df2)\nsummary(df2aov)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \nfood         3 1156.6   385.5   6.163 0.00294 **\nbreed        2  349.4   174.7   2.793 0.08121 . \nfood:breed   6  771.3   128.5   2.055 0.09712 . \nResiduals   24 1501.3    62.6                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n상호작용에 대한 가설 검정\n\n\\[\nH_0: (\\alpha \\beta)_{11} = (\\alpha \\beta)_{12} =\\cdots = (\\alpha \\beta)_{6} =0 \\quad \\text{ vs.} \\quad H_1: \\text{ not } H_0\n\\]\n분산분석표에서 상호작용에 대한 가설 검정을 위한 F-통계량은 \\(2.055\\)이고 p-값은 0.097으로 유의수준 0.05보다 크므로 귀무가설 \\(H_0\\)를 기각할 수 있다. 따라서 사료와 품종 간의 상호작용은 유의하지 않다. 하지만 p-값이 0.1 미만이므로 품종에 따라서 사료가 주는 효과가 약간은 다를 가능성이 존재한다.\n\n\n\n\n\n\n노트\n\n\n\n상호작용에 대한 p-값이 0.25 보다 작으므로 상호작용에 대한 모수를 가진 모형을 그대로 사용한다. (교과서 88 페이지 참조 )\n상호작용을 모형에서 제외하는 기준을 일반적으로 정하는 방법은 매우 어려우며 실험계획의 적용되는 분야와 문제에 따라 달리질 수 있다. 또한 기준을 설벙할 떄는 고유 분야에 대한 지식과 경험이 필요하다.\n본 강의에서는 학생들이 상호작용을 모형에서 제외하는판단은 하지 않으며 과제나 시험에서 상호작용을 모형에서 제외하는 판단을 요구하지 않는다.\n\n\n\n주효과에 대한 가설 검정\n주효과에 대한 검정에서 품종에 대한 검정은 p-값이 \\(0.081\\)로서 유의수준 5%에서 귀무가설을 기각할 수 없으므로 돼지품종에 따라서는 유의한 차이가 없다. 다만 유의수준 1%에서는 유의하므로 약간의 차이는 있다고 말할 수 있다.\n사료에 대한 검정은 p-값이 \\(0.003\\)로서 유의수준 5%에서 귀무가설을 기각할 수 있어서 사료에 따라서는 유의한 차이가 있다.\n\n\n\n\n\n\n\n노트\n\n\n\n보통 유의수준 1%에서 유의하면 “제한적으로 유의하다”(marginally significant)라고 말한다.\n\n\n\n\n2.1.4 분산분석 후의 추정\n\n2.1.4.1 모평균에 대한 추론\n이원배치에서 유의한 상호작용이 있는 경우 처리수준 \\(A_iB_j\\)에 대한 모평균 \\(\\mu_{ij}\\) 에 대한 추정량은 처리수준 \\(A_iB_j\\)에서의 관측값들의 평균 \\(\\bar {x}_{ij.}\\) 이며 오차항의 분산 \\(\\sigma^2_E\\)는 분산분석표에서 \\(MS_E\\)로 추정할 수 있다.\n\\[ \\hat \\sigma^2_E = MS_E = \\frac{SS_E}{ab(r-1)} =\\frac{1501.3}{24} = 62.6 \\]\n위의 결과를 이용하면 처리수준 \\(A_iB_j\\)에 대한 모평균 \\(\\mu_{ij}\\)에 대한 \\(100(1-\\alpha)\\)% 신뢰구간은 다음과 같이 주어진다.\n\\[ \\bar x_{ij.} \\pm t(1-\\alpha/2, ab[r-1]) \\sqrt{ \\frac{MS_E}{r}} \\]\n예를 들어 사료가 1 이고(\\(i=1\\)) 품종이 1인 경우(\\(j=1\\)) 체중의 평균 \\(\\mu_{11}\\) 에 대한 95% 신뢰 구간을 구해보자. 일단 위의 기초 통계량에서 \\(\\bar x_{11.}=66.7\\) 이고 분산분석표에서 \\(MS_E =62.6\\), \\(r=3\\) 그리고 t-분포의 백분위수 \\(t(0.975, 24)\\) 은 다음과 같이 주어진다.\n\nqt(0.975, 24)\n\n[1] 2.063899\n\n\n따라서 \\(\\mu_{11}\\) 에 대한 95% 신뢰 구간은 다음과 같다.\n\\[\n\\bar x_{11.} \\pm t(1-\\alpha/2, 24) \\sqrt{ \\frac{MS_E}{r}} = 66.7 \\pm (2.06)\\sqrt{\\frac{62.6}{3}} = 66.7 \\pm (2.06)(4.56)= (57, 76)\n\\tag{2.1}\\]\n패키지 emmeans에 있는 함수 emmeans()를 다음과 같이 사용하면 각 처리에 대한 평균의 95% 신뢰구간을 쉽게 구할 수 있다.\n\nemmeans(df2aov, \"food\", \"breed\")\n\nbreed = 1:\n food emmean   SE df lower.CL upper.CL\n 1      66.7 4.57 24     57.2     76.1\n 2      62.0 4.57 24     52.6     71.4\n 3      64.0 4.57 24     54.6     73.4\n 4      48.3 4.57 24     38.9     57.8\n\nbreed = 2:\n food emmean   SE df lower.CL upper.CL\n 1      72.3 4.57 24     62.9     81.8\n 2      50.7 4.57 24     41.2     60.1\n 3      65.3 4.57 24     55.9     74.8\n 4      57.0 4.57 24     47.6     66.4\n\nbreed = 3:\n food emmean   SE df lower.CL upper.CL\n 1      63.3 4.57 24     53.9     72.8\n 2      57.3 4.57 24     47.9     66.8\n 3      46.3 4.57 24     36.9     55.8\n 4      50.0 4.57 24     40.6     59.4\n\nConfidence level used: 0.95",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>이원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twoway.html#반복이-있는-이원배치에서-상호작용이-없는-경우의-추론",
    "href": "qmd/twoway.html#반복이-있는-이원배치에서-상호작용이-없는-경우의-추론",
    "title": "2  이원배치법",
    "section": "2.2 반복이 있는 이원배치에서 상호작용이 없는 경우의 추론",
    "text": "2.2 반복이 있는 이원배치에서 상호작용이 없는 경우의 추론\n교과서에서 상호작용의 유의성에 따라서 모형을 축소하는 기준을 다음과 같이 제시하고 있다.\n상호작용에 대한 p-값이 0.25보다 큰 경우 상호작용이 존재하지 않는다고 판단하고 오차항에 풀링힌다. 상호작용을 오차항에 풀링한다는 것은 다음과 같은 모형을 사용한다는 의미이다.\n\\[\nx_{ijk} = \\mu + \\alpha_i + \\beta_j + e_{ijk}\n\\tag{2.2}\\]\n만약 예제 4.1에 대한 반복이 있는 자료에서 위와 같이 오차항을 풀링한 모형을 적합해 보면 아래와 같은 분산분석표를 얻는다.\n\ndf2aov2 &lt;- aov(response ~ food + breed, data=df2)\nsummary(df2aov2)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \nfood         3 1156.6   385.5   5.089 0.00575 **\nbreed        2  349.4   174.7   2.306 0.11705   \nResiduals   30 2272.6    75.8                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n만약 반복이 있는 이원배치 모형에서 상호작용 \\(A \\times B\\)가 존재하지 않고 주효과만 유의한 경우, 즉 모형 식 2.2 을 가정한 경우 모평균 \\(\\mu_{ij}\\)에 대한 모수는 다음과 같다.\n\\[ \\mu_{ij} = \\mu + \\alpha_i + \\beta_j \\]\n이러한 경우 모평균 \\(\\mu_{ij}\\)에 대한 최소제곱 추정량(least square estimator)은 표본 평균 \\(\\bar x_{ij.}\\)이 아니라 다음과 같은 추정량이 주어진다.\n\\[\n\\begin{aligned}\n\\hat \\mu_{ij} & = \\hat \\mu + \\hat \\alpha_i + \\hat \\beta_j \\\\\n  & = (\\bar{\\bar x}) + (\\bar x_{i..}-\\bar{\\bar x}) + (\\bar x_{.j.}-\\bar{\\bar x}) \\\\\n  & = \\bar x_{i..} + \\bar x_{.j.} - \\bar{\\bar x}\n\\end{aligned}\n\\]\n위에서 주어진 \\(\\hat \\mu_{ij}\\) 는 모평균 \\(\\mu_{ij}\\)의 불편 추정량이며 상호작용 \\(A \\times B\\) 이 없는 모형 @ref(eq:nointer) 에서 표본 평균 \\(\\bar x_{ij.}\\) 보다 분산이 작은 추정량이다. 즉,\n\\[ Var \\left (\\hat \\mu_{ij} \\right ) = \\frac{\\sigma_E^2}{n_e}  \\le \\frac{\\sigma_E^2}{r} = Var (\\bar x_{ij.} )    \\]\n위의 식에서 유효 반복수 \\(n_e\\) 는 다음과 같이 정의된다.\n\\[ \\frac{1}{n_e} = \\frac{1}{br} + \\frac{1}{ar} - \\frac{1}{abr}, \\quad n_e=\\frac{abr}{a+b-1} \\]\n따라서 이 경우 모평균 \\(\\mu_{ij}\\)에 대한 \\(100(1-\\alpha)\\)% 신뢰구간은 다음과 같은 주어진다.\n\\[ \\hat \\mu_{ij} \\pm t(1-\\alpha/2, \\phi_E) \\sqrt{ \\frac{MS_E}{n_e}} \\]\n주의할 점은 위의 신뢰구간에서 \\(MS_E\\)는 상호작용이 없는 모형 식 2.2 으로 유도된 분산분석표에 나타난 \\(MS_E\\) 이며 자유도는 \\(\\phi_E = abr-a-b+1\\) 이다.\n참고로 예제 4.1 경우 \\(a=4\\), \\(b=3\\), \\(r=3\\)이므로 유효 반복수 \\(n_e\\) 는 다음과 같이 주어진다.\n\\[ n_e = \\frac{abr}{a+b-1} = \\frac{(4)(3)(3)}{4+3-1} = 6  \\]\n상호작용 \\(A \\times B\\) 이 없는 모형 식 2.2 에서 적용한 분산분석 결과 df2aov2 에 대하여 모형 식 2.2 에서 각 처리에 대한 평균 \\(\\mu_{ij}\\)에 대한 최소제곱 추정량 \\(\\hat \\mu_{ij}=\\bar x_{i..} + \\bar x_{.j.} - \\bar{\\bar x}\\) 과 95% 신뢰구간을 다음과 같이 구할 수 있다.\n\ndf2s_food$mean[1]\n\n[1] 67.44444\n\ndf2s_breed$mean[1]\n\n[1] 60.25\n\nmean(df2$response)\n\n[1] 58.61111\n\n\n\\[ \\hat \\mu_{ij}=\\bar x_{i..} + \\bar x_{.j.} - \\bar{\\bar x} = 67.4 +  60.3 - 58.6 =69.1 \\]\n이제 상호작용 \\(A \\times B\\) 이 없는 모형 식 2.2 에서 \\(\\mu_{11}\\) 에 대한 95% 신뢰 구간은 다음과 같다.\n\\[\n\\begin{aligned}\n\\hat \\mu_{11}  \\pm t(1-\\alpha/2, 30) \\sqrt{ \\frac{MS_E}{n_e}}\n& = 69.1 \\pm (2.04)\\sqrt{\\frac{ 75.8}{6}} \\\\\n& = 69.1 \\pm (2.04)(3.55) \\\\\n& = (61.8, 76.3)\n\\end{aligned}\n\\]\n위의 신뢰구간 \\((61.8, 76.3)\\)은 상호 작용이 포함된 모형에서 유도힌 신뢰구간 식 2.1 에서 구한 \\((57, 76)\\)과 다르다.\n함수 emmeans()를 분산분석 결과df2aov2 에 대하여 다음과 같이 사용하면 상호작용 \\(A \\times B\\) 이 없는 모형 식 2.2 에서 각 처리에 대한 평균 \\(\\mu_{ij}\\)에 대한 최소제곱 추정량 \\(\\hat \\mu_{ij}\\) 과 95% 신뢰구간을 다음과 같이 구할 수 있다.\n\nemmeans(df2aov2, \"food\", \"breed\")\n\nbreed = 1:\n food emmean   SE df lower.CL upper.CL\n 1      69.1 3.55 30     61.8     76.3\n 2      58.3 3.55 30     51.0     65.6\n 3      60.2 3.55 30     52.9     67.5\n 4      53.4 3.55 30     46.2     60.7\n\nbreed = 2:\n food emmean   SE df lower.CL upper.CL\n 1      70.2 3.55 30     62.9     77.4\n 2      59.4 3.55 30     52.1     66.6\n 3      61.3 3.55 30     54.0     68.5\n 4      54.5 3.55 30     47.2     61.8\n\nbreed = 3:\n food emmean   SE df lower.CL upper.CL\n 1      63.1 3.55 30     55.8     70.3\n 2      52.3 3.55 30     45.0     59.6\n 3      54.2 3.55 30     46.9     61.5\n 4      47.4 3.55 30     40.2     54.7\n\nConfidence level used: 0.95 \n\n\n위에서 나타난 emmean 은 \\(\\mu_{ij}\\)에 대한 최소제곱 추정량 \\(\\bar x_{i..} + \\bar x_{.j.} - \\bar{\\bar x}\\) 으로서 아래 주어진 표본평균 \\(\\bar x_{ij.}\\) 과 다른 값으로 나타남을 알 수 있다.\n\ndf2s\n\n# A tibble: 12 × 4\n# Groups:   food [4]\n   food  breed  mean    sd\n   &lt;fct&gt; &lt;fct&gt; &lt;dbl&gt; &lt;dbl&gt;\n 1 1     1      66.7  3.06\n 2 1     2      72.3  8.50\n 3 1     3      63.3 11.6 \n 4 2     1      62    3.61\n 5 2     2      50.7  7.09\n 6 2     3      57.3 10.0 \n 7 3     1      64    4.58\n 8 3     2      65.3  6.03\n 9 3     3      46.3 10.2 \n10 4     1      48.3  8.74\n11 4     2      57    4   \n12 4     3      50   10.8",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>이원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twoway.html#전지의-수명-실험",
    "href": "qmd/twoway.html#전지의-수명-실험",
    "title": "2  이원배치법",
    "section": "2.3 전지의 수명 실험",
    "text": "2.3 전지의 수명 실험\n전지(battery)를 제조하는 회사의 기술자들이 전지의 수명(BatteryLife)에 영향을 미치는 두 요인, 온도(Temperature)와 재료(MaterialType)의 효과를 알아보기 위해서 실행한 실험입니다.\n기술자들은 온도가 크게 변할 때 전지의 수명에 어떤 영향을 미치는지 알아보기 위하여 실험을 실시하였다. 온도는 3개의 수준(15도, 70도, 125도)을 고려하였다. 전지를 생산하는 재료가 3개이므로 재료는 3개의 수준(type 1,2,3)으로 구성되어 있다. 이 실험은 9 개의 처리(\\(ab=3\\times 3=9\\))에 대하여 각각 4번의 반복 측정(\\(r=4\\))을 실시하였다.\n자료의 출처는 (Montgomery 2017) 에 나와 있다\n자료를 얻기 위해서는 다음과 같은 R 프로그램을 실행하여 패키지 MontgomeryDAE를 설치하고 실행해야 한다.\n\ninstall.packages(\"remotes\")\nremotes::install_github(\"ehassler/MontgomeryDAE\")\nlibrary(MontgomeryDAE)\n\n\n2.3.1 자료 읽기\n이제 전지의 수명 실험 자료를 읽어 오자. 전지의 수명 실험에 대한 자료는 데이터프레임 Table5.1에 있다.\n\ndf &lt;- Table5.1\nhead(df) # 자료의 앞부부만 보기   \n\n  MaterialType Temperature BatteryLife\n1            1          15         130\n2            1          15          74\n3            2          15         150\n4            2          15         159\n5            3          15         138\n6            3          15         168\n\n\n함수 str()은 자료의 구조와 자료 안에 있는 변수의 형식을 보여준다.\n\nstr(df)  # 자료의 구조를 알아보는 명령\n\n'data.frame':   36 obs. of  3 variables:\n $ MaterialType: chr  \"1\" \"1\" \"2\" \"2\" ...\n $ Temperature : num  15 15 15 15 15 15 15 15 15 15 ...\n $ BatteryLife : num  130 74 150 159 138 168 155 180 188 126 ...\n\n\n위의 결과를 보면 데이터프레임 df에 있는 변수 MaterialType은 문자형 변수(chr)이고 나머지는 숫자형 변수(num)이다. 두 요인에 대한 변수인 MaterialType와 Temperature를 함수 factor()를 이용하여 범주형 변수로 만들어 주자 .\n\ndf$MaterialType &lt;- factor(df$MaterialType)\ndf$Temperature &lt;- factor(df$Temperature)\nstr(df)\n\n'data.frame':   36 obs. of  3 variables:\n $ MaterialType: Factor w/ 3 levels \"1\",\"2\",\"3\": 1 1 2 2 3 3 1 1 2 2 ...\n $ Temperature : Factor w/ 3 levels \"15\",\"70\",\"125\": 1 1 1 1 1 1 1 1 1 1 ...\n $ BatteryLife : num  130 74 150 159 138 168 155 180 188 126 ...\n\n\n\n\n2.3.2 자료의 시각화와 기초 통계량\n이제 처리별로 효과를 시각적으로 비교하기 위하여 자료들에 대한 산점도와 상자그림을 그려보자\n\ndf %&gt;% \n  ggplot() +\n  aes(x = Temperature , y = BatteryLife, fill=MaterialType, color=MaterialType, group = interaction(Temperature, MaterialType)) +\n  geom_boxplot(alpha = 0.1, width = 0.75) \n\n\n\n\n\n\n\n\n다음으로 6개의 처리 조합에 대한 전지 수명의 기초통계량(평균과 표준편차)을 구해보자.\n\ndfs &lt;- df %&gt;% group_by(MaterialType, Temperature)  %&gt;%  summarise(mean=mean(BatteryLife),  sd=sd(BatteryLife))\ndfs\n\n# A tibble: 9 × 4\n# Groups:   MaterialType [3]\n  MaterialType Temperature  mean    sd\n  &lt;fct&gt;        &lt;fct&gt;       &lt;dbl&gt; &lt;dbl&gt;\n1 1            15          135.   45.4\n2 1            70           57.2  23.6\n3 1            125          57.5  26.9\n4 2            15          156.   25.6\n5 2            70          120.   12.7\n6 2            125          49.5  19.3\n7 3            15          144    26.0\n8 3            70          146.   22.5\n9 3            125          85.5  19.3\n\n\n이제 위에서 계산된 처리 그룹에 대한 평균으로 상호작용 그림을 그려보자. 아래 그림에서 온도가 증가할 수록 전지의 수명이 감소하는 경향을 보이고 있다. 또한 각 재료에 따른 온도의 변화가 수평으로 나타나지 않고 있음을 알 수 있다. 이러한 점은 온도와 재료 사이에 유의한 상호작용이 있다고 예측할 수 있다.\n\ndfs %&gt;% \n  ggplot() +\n  aes(x = Temperature , y = mean, color =MaterialType) +\n  geom_line(aes(group = MaterialType)) +\n  geom_point()\n\n\n\n\n\n\n\n\n\n\n2.3.3 분산분석표와 가설검정\n이제 다음과 같은 모형에서 이원배치법에서의 가설검정을 수행하기 위하여 분산분석 표를 구해보자.\n\\[ x_{ijk} = \\mu + \\alpha_i + \\beta_j + (\\alpha\\beta)_{ij} + e_{ijk} \\]\n\n\n\n\n\n\n\n\n\n\n요인\n제곱합\n자유도\n평균제곱합\n\\(F_0\\)\n\n\n\n\n요인 \\(A\\)\n\\(SS_A\\)\n\\(a-1\\)\n\\(MS_A\\)\n\\(MS_A/MS_E\\)\n\n\n요인 \\(B\\)\n\\(SS_B\\)\n\\(b-1\\)\n\\(MS_B\\)\n\\(MS_B/MS_E\\)\n\n\n상호작용 \\(A \\times B\\)\n\\(SS_{A \\times B}\\)\n\\((a-1)(b-1)\\)\n\\(MS_{A \\times B}\\)\n\\(MS_{A \\times B}/MS_E\\)\n\n\n잔차 \\(E\\)\n\\(SS_E\\)\n\\(ab(r-1)\\)\n\\(MS_E\\)\n\n\n\n총합\n\\(SS_T\\)\n\\(abr-1\\)\n\n\n\n\n\n\ndfaov &lt;- aov(BatteryLife~ MaterialType + Temperature + MaterialType:Temperature, data=df)\n# This is equivalent to aov(BatteryLife~ MaterialType *Temperature , data=df)\nsummary(dfaov)\n\n                         Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nMaterialType              2  10684    5342   7.911  0.00198 ** \nTemperature               2  39119   19559  28.968 1.91e-07 ***\nMaterialType:Temperature  4   9614    2403   3.560  0.01861 *  \nResiduals                27  18231     675                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n상호작용에 대한 가설 검정\n\\[ H_0: (\\alpha \\beta)_{11} = (\\alpha \\beta)_{12} =\\cdots = (\\alpha \\beta)_{3,3} =0 \\quad \\text{ vs.} \\quad H_1: \\text{ not } H_0 \\]\n분산분석표에서 상호작용에 대한 가설 검정을 위한 F-통계량은 다음과 같다.\n\\[ F_0 = \\frac{MS_{A \\times B}}{MS_E} =\\frac{SS_{A\\times B}/\\phi_{AB}} {SS_E/\\phi_E} = \\frac{9614/4}{18231/27} = 3.560 \\]\n위의 F-통계량에 대한 p-값은 0.0186으로 유의수준 0.05보다 작으므로 귀무가설 \\(H_0\\)를 기각한다. 따라서 온도와 재료의 상호작용은 유의하다.\n주효과에 대한 가설 검정\n위에서 유의한 상호작용이 있다고 판단하였기 때문에 주효과에 대한 가설검정은 기술적 의미가 없다. 기술적으로 의미가 없다는 것은 유의한 상호작용이 있으면 이미 주효과 \\(A\\) 의크기가 \\(B\\) 의 수준에 따라서 다르므로 주효과가 유의하게 있다는 것을 뜻한다.\n\n\n\n2.3.4 분산분석 후의 추정\n\n\n2.3.5 모평균에 대한 추론\n이원배치에서 유의한 상호작용이 있는 경우 처리수준 \\(A_iB_j\\)에 대한 모평균 \\(\\mu_{ij}\\) 은 다음과 같다.\n\\[ \\mu_{ij} = \\mu + \\alpha_i + \\beta_j + (\\alpha \\beta)_{ij} = \\mu + \\tau_{ij} \\]\n이때 \\(\\mu_{ij}\\) 에 대한 추정량은 처리수준 \\(A_iB_j\\)에서의 관측값들의 평균 \\(\\bar {x}_{ij.}\\)으로 다음과 같은 분포를 따른다.\n\\[ \\bar {x}_{ij.} \\sim N(\\mu_{ij}, \\sigma^2_E/ r) \\]\n오차항의 분산 \\(\\sigma^2_E\\)는 분산분석표에서 \\(MS_E\\)로 추정할 수 있다.\n\\[ \\hat \\sigma^2_E = MS_E = \\frac{SS_E}{ab(r-1)} =\\frac{18231}{27} = 675 \\]\n위의 결과를 이용하면 처리수준 \\(A_iB_j\\)에 대한 모평균 \\(\\mu_{ij}\\)에 대한 \\(100(1-\\alpha)\\)% 신뢰구간은 다음과 같이 주어진다.\n\\[ \\bar x_{ij.} \\pm t(1-\\alpha/2, ab[r-1]) \\sqrt{ \\frac{MS_E}{r}}  \\]\n예를 들어 전지의 수명실험에서 온도가 70도이고(\\(i=2\\)) 재료의 형테가 3인 경우(\\(j=3\\)) 수명 시간의 평균 \\(\\mu_{23}\\) 에 대한 95% 신뢰 구간을 구해보자. 일단 위의 기초 통계량에서 \\(\\bar x_{13.}=146\\) 이고 분산분석표에서 \\(MS_E =675\\), \\(r=4\\) 그리고 t-분포의 백분위수 \\(t(0.975, 27)\\) 은 다음과 같이 주어진다.\n\nqt(0.975, 27)\n\n[1] 2.051831\n\n\n따라서 \\(\\mu_{23}\\) 에 대한 95% 신뢰 구간은 다음과 같다.\n\\[ \\bar x_{23.} \\pm t(1-\\alpha/2, ab[r-1]) \\sqrt{ \\frac{MS_E}{r}} = 146 \\pm (2.05)\\sqrt{\\frac{675}{4}} = (119, 172) \\]\n패키지 emmeans에 있는 함수 emmeans()를 다음과 같이 사용하면 각 처리에 대한 평균의 95% 신뢰구간을 쉽게 구할 수 있다. 함수 emmeans()의 첫 번째 인자는 분산분석의 결과(aov()의 결과)이며 다음의 인자들은 요인에 대한 변수명을 써주면 된다.\n\nemmeans(dfaov, \"MaterialType\",\"Temperature\")\n\nTemperature = 15:\n MaterialType emmean SE df lower.CL upper.CL\n 1             134.8 13 27    108.1    161.4\n 2             155.8 13 27    129.1    182.4\n 3             144.0 13 27    117.3    170.7\n\nTemperature = 70:\n MaterialType emmean SE df lower.CL upper.CL\n 1              57.2 13 27     30.6     83.9\n 2             119.8 13 27     93.1    146.4\n 3             145.8 13 27    119.1    172.4\n\nTemperature = 125:\n MaterialType emmean SE df lower.CL upper.CL\n 1              57.5 13 27     30.8     84.2\n 2              49.5 13 27     22.8     76.2\n 3              85.5 13 27     58.8    112.2\n\nConfidence level used: 0.95 \n\n\n함수 emmeans()에서 출력되는 SE는 표분오차(standard error)를 의미하며 이는 평균의 추정량 \\(\\bar x_{ij.}\\)의 표준편차(standard deviation)이다.\n\\[  \\hat{\\text{SE}}(\\bar x_{ij.}) = \\hat{ sd} (\\bar x_{ij.}) = \\sqrt{ \\hat {Var} (\\bar x_{ij.})}\n= \\sqrt{\\frac{MS_E}{r}} = \\sqrt{675/4} = 13.0 \\]\n\n\n2.3.6 미래의 관측값에 대한 추론\n처리수준 \\(A_iB_j\\)에 대한 미래의 관측값에 대한 신뢰구간을 구하는 경우 관측 오차에 의한 불확실성을 반영하기 때문에 그 신뢰구간은 다음과 같이 주어진다.\n\\[ \\bar x_{ij.} \\pm t(1-\\alpha/2, ab[r-1]) \\sqrt{ \\frac{MS_E}{r}+MS_E}  \\]\n참고로 다른 교과서에서는 관측값에 대한 신뢰구간을 예측구간(prediction interval)이라고 부른다. 이는 모수는 추정(estimation)하지만 관측값은 예측(prediction)한다고 말하기 때문이다.\n\n\n\n\nMontgomery, Douglas C. 2017. Design and analysis of experiments. John wiley & sons.",
    "crumbs": [
      "<span class='chapter-number'>2</span>  <span class='chapter-title'>이원배치법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html",
    "href": "qmd/block.html",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "",
    "text": "3.1 블럭설계 예제\n다음은 교과서 예제 5.1 -플라스틱 강도 실험을 분석하는 예제이다.\n플라스틱 제품의 강도를 측정하는 것이 실험의 목적이다. 랜덤하게 4일을 택해서 각 일마다 온도를 3개 수준으로 랜덤하게 변화시켜서 제품의 강도(intensity)를 측정하였다.\n여기서 온도(temp)는 고정효과(\\(\\tau\\))이며 선택된 일(day)는 블럭(\\(\\rho\\))에 따른 효과이다.\n\\[ x_{ij} = \\mu + \\tau_i + \\rho_j + e_{ij} \\]",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html#블럭설계-예제",
    "href": "qmd/block.html#블럭설계-예제",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "",
    "text": "3.1.1 자료의 구성\n이제 실험자료를 입력하여 데이터프레임으로 만들어 보자\n\nintensity&lt;- c(98.0, 97.7, 96.5,\n              99.0, 98.0, 97.9,\n              98.6, 98.2, 96.9,\n              97.6, 97.3, 96.7)\n\ntemp &lt;- factor(rep(c(70, 80, 90), times=4))\nday &lt;- as.factor(rep(c(1:4), each=3))\n\ndf&lt;- data.frame(intensity=intensity, temp=temp, day=day)\ndf\n\n   intensity temp day\n1       98.0   70   1\n2       97.7   80   1\n3       96.5   90   1\n4       99.0   70   2\n5       98.0   80   2\n6       97.9   90   2\n7       98.6   70   3\n8       98.2   80   3\n9       96.9   90   3\n10      97.6   70   4\n11      97.3   80   4\n12      96.7   90   4\n\n\n벡터를 범주형 변수로 만들어 줄때 두 함수 as.factor() 와 factor() 모두 사용 가능하다.\n\n\n3.1.2 시각적 분석\n이제 온도의 수준에 따른 변화를 볼 수 있는 그림을 그려보자. 온도가 올라가면 강도가 떨어지는 경향을 볼 수 있다.\n\ndf %&gt;% \n  ggplot(aes(x = temp  , y = intensity,  color=day)) +\n   geom_line(aes(group = day)) +   geom_point()\n\n\n\n\n\n\n\n\n\nplot(intensity ~ temp, data=df)\n\n\n\n\n\n\n\n\n이제 실험일에 따른 변동을 살펴보자. 실험일에 따라서 온도의 효과가 변하는 것을 볼 수 있다. 단 실험일과 온도의 상호작용은 크게 나타나지 않는다. 유의할 점은 반복이 없기 때문에 상호작용에 대한 추론은 불가능하다\n\ndf %&gt;% \n  ggplot(aes(x = day  , y = intensity,  color=temp)) +\n   geom_line(aes(group = temp)) +   geom_point()\n\n\n\n\n\n\n\n\n\n\n3.1.3 분산분석\n블럭 효과인 실험일(day)를 고정효과로 놓았을 경우 분산분석표는 다음과 같다.\n\\[ \\rho_j : \\text{ fixed effect,}  \\quad e_{ij} \\sim N(0, \\sigma_E^2) \\]\n\nmodel&lt;- aov(intensity ~ temp + day, data=df)\nsummary(model)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \ntemp         2   3.44  1.7200  18.429 0.00274 **\nday          3   2.22  0.7400   7.929 0.01647 * \nResiduals    6   0.56  0.0933                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n위의 분산분석표에서 온도의 효과를 검정하는 F-통계량의 값은 18.4285714 이고 p-값은 0.002744이다. 따라서 5% 유의수준으로 귀무가설을 기각하며 온도에 따라서 강도는 유의하게 다르다.\n일반적으로 블럭효과에 대해서는 검정하지 않지만 그래도 p-값이 0.0164702 로서 매우 작으므로 실험일에 따른 변동이 크다는 것을 알 수 있다. 이는 실험울 수행하는 날에 따라서 관측값에 변동이 크다는 것이다. 단 상호작용이 그림으로 볼 때 나타나지 않기 때문에 온도의 효과는 적절하게 추정할 수 있다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html#혼합모형",
    "href": "qmd/block.html#혼합모형",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "3.2 혼합모형",
    "text": "3.2 혼합모형\n고정효과와 임의효과(변량)가 동시에 모형식에 나타나는 모형을 혼합모형(mixed models)이라고 부른다. 교과서에서는 변량모형이라고 부른다. 혼합모형에 대한 자세한 기초이론은 부록 C 에서 찾아볼 수 있다.\n\n혼합모형을 적합시키는 패키지는 lme4 이며 모형을 적합시키는 함수는 lmer이다.\n\nlibrary(lme4)\nlibrary(lmerTest)\n\n혼합모형으로 부터 얻은 분산분석표에서 p-값을 보려면 패키지 lmerTest를 사용해야 한다.\n함수 lmer 에서 고정효과에 대한 모형식은 함수 anova와 같다.\n함수 lmer 에서 만약 변수 var 을 임의효과로 고려하려면 (1|var) 으로 쓰면 된다.\n\n다음은 플라스틱 강도 자료 실험에서 블럭 효과인 실험일(day, \\(\\rho\\))를 임의효과로 놓았을 경우 분석결과이다. 즉\n\\[ \\rho_j \\sim N(0, \\sigma_B^2), \\quad e_{ij} \\sim N(0, \\sigma_E^2) \\]\n\nfit &lt;- lmer(intensity ~ temp + (1|day), data=df)\nsummary(fit)\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: intensity ~ temp + (1 | day)\n   Data: df\n\nREML criterion at convergence: 14.6\n\nScaled residuals: \n    Min      1Q  Median      3Q     Max \n-1.0616 -0.7992  0.1430  0.5419  1.2297 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n day      (Intercept) 0.21556  0.4643  \n Residual             0.09333  0.3055  \nNumber of obs: 12, groups:  day, 4\n\nFixed effects:\n            Estimate Std. Error      df t value Pr(&gt;|t|)    \n(Intercept)  98.3000     0.2779  4.5593 353.739  2.7e-11 ***\ntemp80       -0.5000     0.2160  6.0000  -2.315  0.05989 .  \ntemp90       -1.3000     0.2160  6.0000  -6.018  0.00095 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n       (Intr) temp80\ntemp80 -0.389       \ntemp90 -0.389  0.500\n\n\n위의 결과에서 블럭효과(day) 를 나타내는 분산 성분 \\(\\sigma_B^2\\)의 추정치는 0.2155556 이며 오차항(Residual)의 분산 \\(\\sigma_E^2\\)의 추정치는 0.0933333 이다. 이는 급내상관 계수(ICC)는 0.6978417 로서 매우 크다는 것을 의미한다.\n\\[ ICC = \\frac{\\sigma_B^2}{\\sigma_B^2 + \\sigma_E^2} =  0.6978417 \\]\n다음은 플라스틱 강도 자료 실험에서 블럭 효과를 임의효과로 놓았을 경우 분산분석표이다. 함수 lmer 에 의해 생성된 결과를 함수 anova에 적용하면 고정효과에 대한 분산분석과 F-검정만 보여준다. 앞에서 블럭을 고정효과로 놓았을 때 분산분석의 검정 결과와 같다.\n\nanova(fit)\n\nType III Analysis of Variance Table with Satterthwaite's method\n     Sum Sq Mean Sq NumDF DenDF F value   Pr(&gt;F)   \ntemp   3.44    1.72     2     6  18.429 0.002744 **\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html#라틴정방설계",
    "href": "qmd/block.html#라틴정방설계",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "3.3 라틴정방설계",
    "text": "3.3 라틴정방설계\n\n3.3.1 로켓 추진체\n다음은 교재 예제 5.2 - 로켓 추진체 실험을 분석하는 예제이다.\n5가지의 로켓 추진체(A, B, C, D, E)의 성능을 비교하기 위하여 라틴정방계획을 사용한 실험이다.\n\n행블럭: 5개의 연료 (R, \\(\\rho\\))\n열블럭: 5명의 기사 (C, \\(\\gamma\\))\n처리: 5가지의 로켓 추진체 (trt, \\(\\tau\\))\n\n[ x_{ijk} = + _i + _j + k + e{ijk } ]\n\n\n3.3.2 자료의 구성\n예제 5.2에 있는 자료를 분석을 위하여 데이터프레임으로 만들어 보자.\n\ntrt &lt;- c(\"A\", \"B\", \"C\", \"D\", \"E\",\n         \"B\", \"C\", \"D\", \"E\", \"A\",\n         \"C\", \"D\", \"E\", \"A\", \"B\",\n         \"D\", \"E\", \"A\", \"B\", \"C\",\n         \"E\", \"A\", \"B\", \"C\", \"D\" )\ntrt &lt;- factor(trt)\nR &lt;- factor(rep(1:5, each=5))\nC &lt;- factor(rep(1:5, times=5))\ny &lt;- c( -1,-5, -6, -1, -1,\n        -8, -1, 5, 2, 11,\n        -7, 13, 1, 2, -4,\n        1, 6, 1, -2, -3,\n        -3, 5, -5, 4, 6)\ndf&lt;- data.frame(trt, R, C, y)\ndf\n\n   trt R C  y\n1    A 1 1 -1\n2    B 1 2 -5\n3    C 1 3 -6\n4    D 1 4 -1\n5    E 1 5 -1\n6    B 2 1 -8\n7    C 2 2 -1\n8    D 2 3  5\n9    E 2 4  2\n10   A 2 5 11\n11   C 3 1 -7\n12   D 3 2 13\n13   E 3 3  1\n14   A 3 4  2\n15   B 3 5 -4\n16   D 4 1  1\n17   E 4 2  6\n18   A 4 3  1\n19   B 4 4 -2\n20   C 4 5 -3\n21   E 5 1 -3\n22   A 5 2  5\n23   B 5 3 -5\n24   C 5 4  4\n25   D 5 5  6\n\n\n함수 xtabs()는 모형식을 이용하여 다음과 같이 열과 행으로 구성된 자료를 보여줄 수 있다.\n\nxtabs(y~ R + C, data = df)\n\n   C\nR    1  2  3  4  5\n  1 -1 -5 -6 -1 -1\n  2 -8 -1  5  2 11\n  3 -7 13  1  2 -4\n  4  1  6  1 -2 -3\n  5 -3  5 -5  4  6\n\n\n\n\n3.3.3 시각적 분석\n먼저 로켓 추진체, 즉 처리별로 자료의 분포를 보자. 추진체 B 와 C 가 다른 추진체들 보다 관측값이 작게 나오는 것을 알 수 있다.\n\ndf %&gt;% \n  ggplot() +\n  aes(x = trt , y = y) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\n원료(R) 뭉치별로 자료의 분포를 보면 큰 차이는 보이지 않는다.\n\ndf %&gt;% \n  ggplot() +\n  aes(x = R , y = y) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\n기사(C) 별로 자료의 분포를 보면 약간의 차이가 보인다.\n\ndf %&gt;% \n  ggplot() +\n  aes(x = C , y = y) +\n  geom_boxplot() \n\n\n\n\n\n\n\n\n\n\n3.3.4 분산분석\n이제 라틴정방계획법으로 얻은 자료에 대래 분산분석을 적용해 보자.\n\nmodel&lt;- aov(y ~ trt + R + C, data=df)\nsummary(model)\n\n            Df Sum Sq Mean Sq F value  Pr(&gt;F)   \ntrt          4    330   82.50   7.734 0.00254 **\nR            4     68   17.00   1.594 0.23906   \nC            4    150   37.50   3.516 0.04037 * \nResiduals   12    128   10.67                   \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n위의 분산분석표에서 추진체(처리)의 효과를 검정하는 F-통계량의 값은 7.734375 이고 p-값은 0.0025365이다. 따라서 5% 유의수준으로 귀무가설을 기각하며 추진체에 따라서 성능이 유의하게 다르다.\n\n\n3.3.5 라틴정방의 구축\n교과서 5.3절에서는 라틴정방 계획으로 실험을 하는 경우 처리를 랜덤하게 배정하는 방법을 설명하고 있다.\n패키지 agricolae 에 포함된 함수 design.lsd()를 이용하면 다음과 같이 처리를 랜덤하게 배정해준다.\n\nmytrt &lt;- factor(c(\"A\", \"B\", \"C\", \"D\", \"E\"))\nmytrt\n\n[1] A B C D E\nLevels: A B C D E\n\ndesign.lsd(mytrt)$sketch\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"C\"  \"D\"  \"A\"  \"B\"  \"E\" \n[2,] \"A\"  \"B\"  \"D\"  \"E\"  \"C\" \n[3,] \"E\"  \"A\"  \"C\"  \"D\"  \"B\" \n[4,] \"D\"  \"E\"  \"B\"  \"C\"  \"A\" \n[5,] \"B\"  \"C\"  \"E\"  \"A\"  \"D\" \n\n\n함수 design.lsd()는 실행할 때마다 랜덤하게 배정하기 때문에 기록을 위해서 랜덤 seed 를 지정하면 나중에도 동일한 계획을 얻을 수 있다.\n\ndesign.lsd(mytrt, seed = 1234 )$sketch\n\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"C\"  \"B\"  \"E\"  \"A\"  \"D\" \n[2,] \"A\"  \"E\"  \"C\"  \"D\"  \"B\" \n[3,] \"B\"  \"A\"  \"D\"  \"E\"  \"C\" \n[4,] \"D\"  \"C\"  \"A\"  \"B\"  \"E\" \n[5,] \"E\"  \"D\"  \"B\"  \"C\"  \"A\"",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html#처리-조합의-블럭",
    "href": "qmd/block.html#처리-조합의-블럭",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "3.4 처리 조합의 블럭",
    "text": "3.4 처리 조합의 블럭\n\n3.4.1 화학약품의 생성률\n다음은 교재 분할법 I - 예제 5.3 - 화학약품의 생성률 실험을 분석하는 예제이다.\n이 실험에서는 화학약품의 생성률에 영향을 미치는 두 요인을 고려한 실험이다.\n\n반응온도(temp, \\(\\alpha\\)) 3개의 수준\n중간원료 제조회사 (company, \\(\\beta\\)) 3개의 수준\n\n이 실험에서는 9개의 처리를 먼저 랜덤하게 선택하고 선택된 처리 하에서 실험을 2번 반복하였다. 따라서 처리의 조합이 블럭효과(block, \\(\\rho\\))로 나타난다.\n\\[ x_{ijk} = \\mu + \\alpha_i + \\beta_j + \\rho_{ij} + e_{2(ijk)} \\]\n위의 모형식에서 상호작용 효과 \\((\\alpha \\beta)_{ij}\\) 와 1차 랜덤화에 의한 오차 \\(e_{1(ij)}\\) 는 교락되어 블럭효과 \\(\\rho_{ij}\\)에 합쳐저서 나타난다.\n\\[ \\rho_{ij} = e_{1(ij)} + (\\alpha \\beta)_{ij}  \\]\n이러한 경우 블럭효과 \\(\\rho_{ij}\\)는 임의효과가 된다.\n\\[\n\\rho_{ij}   \\sim N(0, \\sigma_1^2), \\quad e_{2(ijk)} \\sim N(0, \\sigma_2^2)\n\\tag{3.1}\\]\n\n\n3.4.2 자료의 구성\n이제 실험자료를 입력하여 데이터프레임으로 만들어 보자\n\ntemp&lt;- as.factor(rep(c(\"A1\",\"A2\", \"A3\"), each=2, times=3))\ncompany&lt;- as.factor(rep(c(\"B1\", \"B2\", \"B3\"), each=6))\n\ny &lt;-c( 81.0, 80.2, 84.1, 83.2, 85.2, 86.1,\n       83.3, 82.7, 86.2, 85.4, 86.6, 87.2,\n       81.3, 81.9, 83.2, 84.2, 86.0, 86.4) \n\ndf&lt;- data.frame(temp, company, y)\ndf\n\n   temp company    y\n1    A1      B1 81.0\n2    A1      B1 80.2\n3    A2      B1 84.1\n4    A2      B1 83.2\n5    A3      B1 85.2\n6    A3      B1 86.1\n7    A1      B2 83.3\n8    A1      B2 82.7\n9    A2      B2 86.2\n10   A2      B2 85.4\n11   A3      B2 86.6\n12   A3      B2 87.2\n13   A1      B3 81.3\n14   A1      B3 81.9\n15   A2      B3 83.2\n16   A2      B3 84.2\n17   A3      B3 86.0\n18   A3      B3 86.4\n\n\n\n\n3.4.3 시각적 분석\n일단 각 처리에 대한 관측값의 평균을 구해보자.\n\ndfsum &lt;- df %&gt;% group_by(temp, company)  %&gt;%  summarise(mean=mean(y),  sd=sd(y))\ndfsum\n\n# A tibble: 9 × 4\n# Groups:   temp [3]\n  temp  company  mean    sd\n  &lt;fct&gt; &lt;fct&gt;   &lt;dbl&gt; &lt;dbl&gt;\n1 A1    B1       80.6 0.566\n2 A1    B2       83   0.424\n3 A1    B3       81.6 0.424\n4 A2    B1       83.6 0.636\n5 A2    B2       85.8 0.566\n6 A2    B3       83.7 0.707\n7 A3    B1       85.6 0.636\n8 A3    B2       86.9 0.424\n9 A3    B3       86.2 0.283\n\n\n이제 처리의 평균값을 가지고 온도에 따른 변화를 살펴보자. 이 경우 제조회사 원료에 대해서는 색깔을 다르게 하여 상호작용 효과도 볼 수 있다.\n아래 상호작용 그림을 보면 온도에 따라서 화학약품의 생성률이 크게 변하는 것을 알 수 있다. 유의한 상호작용은 관측되지 않는다.\n\ndfsum %&gt;% \n  ggplot(aes(x = temp  , y = mean,  color=company)) +\n   geom_line(aes(group = company)) +   geom_point()\n\n\n\n\n\n\n\n\n함수 interaction.plot()은상호작용 그림을 평균값을 계산하지 않고 원래 자료를 이용하여 다음과 같이 그릴 수 있다.\n\nwith(df, interaction.plot(x.factor = temp, trace.factor = company,  response = y))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n노트\n\n\n\n위에서 함수 with() 은 이용하고자 하는 변수가 있는 데이터프레임을 지정하는데사용한다. 함수 with()의 첫 번쨰 인자는 앞의 예제와 같이 df 와 같은 데이터 프레임을 지정한다. 두 번째 인자에는 함수를 이용한 명령문을 넣어준다. 앞의 프로그램에서 함수 interaction.plot() 안에서 사용된 변수들( temp,company,y)들은 데이터프레임 df에 있는 변수들이다.\n\n\n이제 제조회사에 따른 변화를 살펴보자. 제조회사에 따른 생성률의 변화는 크지 않다.\n\nwith(df, interaction.plot(x.factor = company, trace.factor =temp ,  response = y))\n\n\n\n\n\n\n\n\n\n\n3.4.4 분산분석\n이제 분산분석을 하여 처리의 효과에 대한 검정을 해보자. 실험에서 각 처리의 조합을 블럭으로 해주어야 한다.\n다음 anova 함수에서 두 처리의 조합을 temp:company 로 표시한다. 사실 temp:company는 두 처리 temp와 company의 상호작용(interaction)을 의미한다. 다음으로 처리의 조합 temp:company 이 임의효과라는 것을 Error(temp:company)와 같이 지정해 준다.\n\nmodel&lt;- aov(y ~ temp + company + Error(temp:company), data=df)\nsummary(model)\n\n\nError: temp:company\n          Df Sum Sq Mean Sq F value  Pr(&gt;F)    \ntemp       2  61.81  30.907   85.72 0.00052 ***\ncompany    2  11.96   5.982   16.59 0.01157 *  \nResiduals  4   1.44   0.361                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nError: Within\n          Df Sum Sq Mean Sq F value Pr(&gt;F)\nResiduals  9   2.57  0.2856               \n\n\n위의 분산분석표에서 온도의 효과를 검정하는 F-통계량의 값은 85.7211094 이고 p-값은 5.1981853^{-4}이다. 따라서 5% 유의수준으로 귀무가설을 기각하며 온도에 따라서 생성률이 매우 유의하게 다르다.\n온도의 효과를 검정하는 F-통계량의 값은 16.5916795 이고 p-값은 0.0115724이다. 따라서 5% 유의수준으로 귀무가설을 기각하며 원료 제조회사에 따라서도 생성률이 유의하게 다르다.\n\n\n3.4.5 블럭을 고려하지 않는 경우\n만약에 처리 조합으로 생긴 블럭효과를 고려하지 않으면 어떤 일이 일어날까?\n만약 생성률 실험자료를 완전 랜덤화 이원배치법에 의하여 얻은 자료라고 생각한다면 반복이 있으므로 상호작용 효과를 추론할 수 있다. 따라서 상호작용 효과를 고정효과로 놓고 분산분석을 적용할 것이다.\n\\[\n\\rho_{ij}  = (\\alpha \\beta)_{ij} : \\text{ fixed effect }, \\quad e_{2(ijk)} \\sim N(0, \\sigma_2^2)\n\\tag{3.2}\\]\n아래 프로그램은 상호작용 효과를 고정효과로 생각한 것이다.\n\nmodel2&lt;- aov(y ~ temp + company + temp:company, data=df)\nsummary(model2)\n\n             Df Sum Sq Mean Sq F value   Pr(&gt;F)    \ntemp          2  61.81  30.907 108.235 5.07e-07 ***\ncompany       2  11.96   5.982  20.949 0.000411 ***\ntemp:company  4   1.44   0.361   1.263 0.352665    \nResiduals     9   2.57   0.286                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n분산분석의 결과는 위와 같으며 온도와 제조회사에 대한 F-검정 통계량을 보면 임의효과 모형에서 나온 것보다 크다. 이는 F-검정 통계량을 만들 때 분모에 사용된 평균 오차제곱합 \\(MS_E\\)와 자유도가 달라서 나타나는 현상이다. 또한 자유도도\n두 모형에서 온도에 대한 F-검정의 차이를 보자.\n\n\n\n\n\n\n\n\n\n\n모형\nanova 항\n\\(MS_A\\)\n\\(MS_E\\)\n\\(F_0\\)\n\n\n\n\n임의효과 모형 식 3.1\nError(temp:company)\n30.9072222\n0.3605556\n85.7211094\n\n\n고정효과 모형 식 3.2\ntemp:company\n30.9072222\n0.2855556\n108.2354086\n\n\n\n위의 표에서와 같이 실험계획에 따라서 나누어 주는 평균 오차제곱합 \\(MS_E\\)와 자유도가 다르기 때문에 검정의 결과가 다르게 나타난다.\n\n\n\n\n\n\n노트\n\n\n\n실험계획에서 통계적 추론을 하는 경우 자료의 구조는 같아도 실험의 방법(랜덤화의 방법)이 다르면 가설검정의 방법이 다르다.\n따라서 실험의 방법에 따른 적절한 통계적 추론 방법을 선택하는 것이 중요하다.\n\n\n\n\n3.4.6 혼합모형\n처리들의 조합을 임의효과로 보는 모형 식 3.1 을 lmer로 적합시키는 프로그램은 다음과 같다.\n분산분석 결과는 anova() 에서 임의효과 Error(temp:company)를 사용하는 결과와 동일하다.\n\nfit &lt;- lmer(y ~ temp + company + (1 | temp:company ), data = df)\nsummary(fit)\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: y ~ temp + company + (1 | temp:company)\n   Data: df\n\nREML criterion at convergence: 29.4\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-1.52027 -0.46728 -0.07111  0.77604  1.20140 \n\nRandom effects:\n Groups       Name        Variance Std.Dev.\n temp:company (Intercept) 0.0375   0.1936  \n Residual                 0.2856   0.5344  \nNumber of obs: 18, groups:  temp:company, 9\n\nFixed effects:\n            Estimate Std. Error      df t value Pr(&gt;|t|)    \n(Intercept)  80.9111     0.3165  4.0000 255.666  1.4e-09 ***\ntempA2        2.6500     0.3467  4.0000   7.644  0.00157 ** \ntempA3        4.5167     0.3467  4.0000  13.028  0.00020 ***\ncompanyB2     1.9333     0.3467  4.0000   5.577  0.00507 ** \ncompanyB3     0.5333     0.3467  4.0000   1.538  0.19877    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nCorrelation of Fixed Effects:\n          (Intr) tempA2 tempA3 cmpnB2\ntempA2    -0.548                     \ntempA3    -0.548  0.500              \ncompanyB2 -0.548  0.000  0.000       \ncompanyB3 -0.548  0.000  0.000  0.500\n\n\n\nanova(fit)\n\nType III Analysis of Variance Table with Satterthwaite's method\n        Sum Sq Mean Sq NumDF DenDF F value    Pr(&gt;F)    \ntemp    48.956 24.4782     2     4  85.721 0.0005198 ***\ncompany  9.476  4.7379     2     4  16.592 0.0115724 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/block.html#분할법",
    "href": "qmd/block.html#분할법",
    "title": "3  블록설계, 라틴정방설계와 분할법",
    "section": "3.5 분할법",
    "text": "3.5 분할법\n\n3.5.1 전자제품 수명\n다음은 교재 분할법 II - 예제 5.4 - 전자제품 수명 실험을 분석하는 예제이다.\n전자부품의 수명이 온도(580, 600, 620, 640도)와 시간(5, 10, 15분)에 의해 어떤 영향을 받는지에 대한 실험이다.\n이 실험은 split-plot 설계를 적용하여 관측값을 얻었다. 온도를 먼저 랜덤하게 선택하고 선택된 온도에서 3개의 가열 시간에 대한 실험을 임의 순서로 진행하였다. 또한 각 실험은 3번 반복 하였다.\n\n온도 (temp, \\(\\alpha\\)) : 주구, main plot - 1차 랜덤화 요인\n시간 (time, \\(\\beta\\)) : 분할구, split-plot, sub-plot - 2차 랜덤화 요인\n반복 (rep, \\(r\\)) : 반복 요인\n\n\\[\nx_{ijk} = \\mu + r_k + \\alpha_i + \\gamma_{ik} + \\beta_j + (\\alpha \\beta)_{ij} + e_{2(ijk)}\n\\tag{3.3}\\]\n위의 모형식에서 반복과 온도의 상호작용 효과 \\(( \\alpha  r)_{ik}\\) 와 1차 랜덤화에 의한 오차 \\(e_{1(ik)}\\) 는 교락되어 블럭효과 \\(\\gamma_{ik}\\)에 합쳐저서 나타난다.\n\\[ \\gamma_{ik}  =  (\\alpha r)_{ik} + e_{1(ik)}  \\]\n\n\n3.5.2 자료의 구성\n이제 실험자료를 입력하여 데이터프레임으로 만들어 보자\n\nrep&lt;- as.factor(rep(c(1:3), each=12))\ntemp&lt;- as.factor(rep(c(580, 600, 620, 640), each=3, times=3))\ntime&lt;- as.factor(rep(c(5, 10, 15), times=12))\n\ny &lt;-c(217, 233, 175, 158, 138, 152, 229, 186, 155, 223, 227, 156,\n        188, 201, 195, 126, 130, 147, 160, 170, 161, 201, 181, 172,\n        162, 170, 213, 122, 185, 180, 167, 181, 182, 182, 201, 199) \n\ndf &lt;- data.frame(rep, temp, time, y)\n\n함수 xtab 을 이용하면 반복에 따라서 자료 구조를 쉽게 볼 수 있다.\n\nxtabs( y ~time + temp + rep, df)\n\n, , rep = 1\n\n    temp\ntime 580 600 620 640\n  5  217 158 229 223\n  10 233 138 186 227\n  15 175 152 155 156\n\n, , rep = 2\n\n    temp\ntime 580 600 620 640\n  5  188 126 160 201\n  10 201 130 170 181\n  15 195 147 161 172\n\n, , rep = 3\n\n    temp\ntime 580 600 620 640\n  5  162 122 167 182\n  10 170 185 181 201\n  15 213 180 182 199\n\n\n\n\n3.5.3 시각적 분석\n이제 온도의 수준에 따른 변화를 볼 수 있는 그림을 그려보자. 온도가 증가하면서 수명이 줄어들었다가 다시 늘어나는 현상을 볼 수 있다.\n\nwith(df, interaction.plot(x.factor = temp, trace.factor = time, response = y))\n\n\n\n\n\n\n\n\n가열시간의 수준에 따른 변화를 볼 수 있는 그림을 그려보자. 가열시간이 증가하더러도 수명이 크게 변하지 않는 것을 알 수 있다.\n\nwith(df, interaction.plot(x.factor = time, trace.factor = temp, response = y))\n\n\n\n\n\n\n\n\n\n\n3.5.4 분산분석\n이제 모형식 식 3.3 에 대한 분산분석을 실시해 보자.\n여기서 유의할 점은 모형식 식 3.3 에서 블럭효과 \\(\\gamma_{ik}\\)는 임의효과로 생각하며 반복 수준과 온도 수준의 조합이다. 따라서 블럭효과 \\(\\gamma_{ik}\\) 에 대한 항을 Error(rep:temp)로 사용한다.\n\\[ \\gamma_{ik} \\sim N(0,\\sigma^2_1), \\quad e_{2(ijk)} \\sim N(0, \\sigma^2_E) \\]\n\nmodel&lt;- aov(y ~ rep + temp*time + Error(rep:temp), data=df)\nsummary(model)\n\n\nError: rep:temp\n          Df Sum Sq Mean Sq F value Pr(&gt;F)   \nrep        2   1963     981   3.319  0.107   \ntemp       3  12494    4165  14.086  0.004 **\nResiduals  6   1774     296                  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nError: Within\n          Df Sum Sq Mean Sq F value Pr(&gt;F)\ntime       2    566   283.1   0.456  0.642\ntemp:time  6   2600   433.4   0.698  0.655\nResiduals 16   9933   620.8               \n\n\n분산분석표에서 온도의 효과를 검정하는 F-통계량의 값은 14.0864677 이고 p-값은 0.0040028이다. 따라서 5% 유의수준으로 귀무가설을 기각하며 온도에 따라서 제품의 수명이 유의하게 다르다.\n가열시간의 효과를 검정하는 F-통계량의 값은 0.4560179 이고 p-값은 0.6417897이다. 따라서 5% 유의수준으로 귀무가설을 기각할 수 없으며 가열시간에 따라서 제품의 수명이 다르지 않다.\n온도와 가열시간의 상호작용 효과를 검정하는 F-통계량의 값은 0.6981059 이고 p-값은 0.655133이다. 따라서 5% 유의수준으로 귀무가설을 기각할 수 없으며 상호작용은 유의하지 않다.",
    "crumbs": [
      "<span class='chapter-number'>3</span>  <span class='chapter-title'>블록설계, 라틴정방설계와 분할법</span>"
    ]
  },
  {
    "objectID": "qmd/contrast.html",
    "href": "qmd/contrast.html",
    "title": "4  대비",
    "section": "",
    "text": "4.1 카이제곱 분포\n자유도가 1인 카이제곱 분포 (\\(\\chi^2\\)-distribution)은 평균이 0이고 분산이 1인 정규분포(표준 정규분포)를 따르는 확률변수의 제곱이 따르는 분포이다.\n\\[\nz \\sim N(0,1) \\quad \\rightarrow \\quad z^2 \\sim \\chi^2(1)\n\\tag{4.1}\\]\n만약 \\(k\\) 개의 확률변수 \\(z_1, z_2, \\dots, z_k\\)가 서로 독립이고 각각 표준 정규분포 \\(N(0,1)\\)를 따른다면 확률변수의 제곱들의 합은 자유도가 k인 카이제곱 분포 \\(\\chi^2(k)\\) 를 따른다.\n\\[\nz_1, z_2, \\dots, z_k \\sim_{ind} N(0,1) \\quad \\rightarrow \\quad \\sum_{i=1}^k z_i^2  \\sim \\chi^2(k)\n\\tag{4.2}\\]\n만약 \\(k\\) 개의 확률변수 \\(z_1, z_2, \\dots, z_k\\)가 서로 독립이고 각각 정규분포 \\(N(\\mu_i,\\sigma^2)\\)를 따른다면 표준화 확률변수의 제곱들의 합은 자유도가 k인 카이제곱 분포 \\(\\chi^2(k)\\) 를 따른다.\n\\[\n\\sum_{i=1}^k  \\left [ \\frac{z_i - \\mu_i}{\\sigma} \\right ]^2 \\sim \\chi^2(k)\n\\tag{4.3}\\]",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>대비</span>"
    ]
  },
  {
    "objectID": "qmd/contrast.html#대비",
    "href": "qmd/contrast.html#대비",
    "title": "4  대비",
    "section": "4.2 대비",
    "text": "4.2 대비\n\n4.2.1 대비의 정의\n다음과 같은 균형자료를 가지는 일원배치 모형을 고려하자.\n\\[\nx_{ij} = \\mu + \\alpha_i + e_{ij}, \\quad i=1,2,\\dots, a,~~ j= 1,2,\\dots, r\n\\tag{4.4}\\]\n위의 일원배치 모형 식 4.4 에서 오차항 \\(e_{ij}\\)가 정규분포 \\(N(0, \\sigma^2)\\) 을 따른다고 가정하자.\n지금까지 우리는 다음과 같은 가설검정에 대한 통계적 추론을 배웠다.\n\\[ H_0: \\alpha_1 = \\alpha_2 =\\cdots = \\alpha_a \\quad \\text{vs.} \\quad H_1: ~ \\text{not } H_0\\]\n\\[\nH_0 : \\alpha_i - \\alpha_j =0 \\quad \\text{vs.} \\quad H_1: \\alpha_i - \\alpha_j \\ne 0\n\\tag{4.5}\\]\n위의 첫 번째 가설은 요인 \\(A\\)의 효과가 있는지에 대한 검정이며 분산분석표를 이용한 F-통계량으로 검정한다. 두 번째 가설은 각 처리 수준의 차이에 대한 검정이며 평균의 차이를 이용한 t-통계량으로 검정한다.\n이제 조금 더 복잡한 가설검정을 고려해보자.\n만약 수준이 3개인 경우(\\(a=3\\)) 첫 번째 수준과 두 번째 수준의 평균이 세 번째 수준과 같은지 검정하고 싶다고 하자 [교과서 예제 7.1 (2)]\n\\[\nH_0 : \\frac{\\alpha_1 + \\alpha_2}{2} = \\alpha_3 \\quad \\text{vs.} \\quad H_1: ~ \\text{not } H_0\n\\tag{4.6}\\]\n또는 만약 요인이 온도인 경우 3개의 수준을 각각 100, 110, 120도로 같은 간격으로 증가시켰다. 반응변수의 평균이 일차적인 추세(linear trend)를 보이고 변화하는지 검정하고 싶을 경우가 있다. 또는 반응변수의 평균이 이차적인 추세(quadratic trend)를 가지는지 확인하고 싶은 경우도 있을 것이다.\n\n\n\n3개의 수준이 있는 경우 선형 추세와 이차식 추세\n\n\n만약 반응변수의 평균이 일차적인 추세(linear trend)를 보이면 수준의 순서에 따라서 평균이 일차적으로 증가 또는 감소하므로 두 평균의 변화를 합한 값, 즉 \\((\\alpha_2-\\alpha_1) + (\\alpha_3 - \\alpha_2)\\) 이 0 과 차이가 날 것이다.\n\\[ |(\\alpha_2-\\alpha_1) + (\\alpha_3 - \\alpha_2)| = |\\alpha_1 - \\alpha_3| &gt; 0 \\]\n반면 반응변수의 평균이 이차적인 추세(quadratic trend)를 보이면 수준의 순서에 따라서 평균이 감소했다 증가하거나 또는 감소했다가 증가할 것이므로 두 평균의 변화를 뺀 값, 즉 \\((\\alpha_2-\\alpha_1) - (\\alpha_3 - \\alpha_2)\\) 이 0 과 차이가 날 것이다.\n\\[ |(\\alpha_2-\\alpha_1) - (\\alpha_3 - \\alpha_2)| = | \\alpha_1 - 2 \\alpha_2 + \\alpha_3 |&gt; 0 \\]\n따라서 선형식 \\(\\psi=\\sum_i c_i \\alpha_i\\)를 다음과 같이 정의하면 선형식 \\(\\psi\\)의 추정량 \\(\\hat \\psi\\)의 값이 클수록 반응변수의 평균이 선형적으로 변화하는 증거가 커진다.\n\\[ \\psi = (\\alpha_2-\\alpha_1) + (\\alpha_3 - \\alpha_2) = -\\alpha_1 + \\alpha_3 \\]\n따라서 가설검정을 다음과 같이 세운다. 귀무 가설을 기각하면 평균이 선형적으로 변화한다는 것을 의미한다.\n\\[\nH_0 : \\alpha_1 - \\alpha_3 = 0  \\quad \\text{ equvalently } \\quad H_0: \\text{ not } H_0\n\\tag{4.7}\\]\n위에서 제시한 2개의 가설 식 4.6 과 식 4.7 의 경우는 모수들의 특별한 선형조합으로 표시되는 가설이다. 이러한 모수들의 선형 조합으로 표시된 가설은 다음과 같이 일반적으로 나타낼 수 있다.\n\\[\nH_0: ~ \\sum_{i=1}^a c_i \\alpha_i = 0\n\\tag{4.8}\\]\n위의 가설 식 4.6 은 일반적인 가설 식 4.8 에서 계수 \\(c_i\\)들이 다음과 같은 경우이며\n\\[ c_1 = c_2 = 1/2, ~~c_3 =-1 \\]\n가설 식 4.7 은 일반적인 가설 식 4.8 에서 계수 \\(c_i\\)들이 다음과 같은 경우이며\n\\[ c_1 = -1, ~ c_2= 0,~ c_3 =1 \\]\n물론 두 개의 처리수준을 비교하는 가설 식 4.5 도 일반적인 가설의 범주에 속한다. 이 경우 \\(c_i=1\\), \\(c_j=-1\\)이고 나머지 \\(c_l=0\\)인 경우이다.\n이렇게 관심있는 모수들의 선형조합 \\(\\psi\\)을 선형식(linear combination)이라고 부른다.\n\\[\n\\psi = c_1 \\alpha_1 + c_2 \\alpha_2 + \\dots + c_a \\alpha_a\n\\tag{4.9}\\]\n선형식 식 4.9 에서 주어진 계수들의 합이 0 인 선형식을 특별히 대비(contrast)라고 한다.\n\\[\nC = c_1 \\alpha_1 + c_2 \\alpha_2 + \\dots + c_a \\alpha_a, \\quad \\sum_{i=1}^a c_i =0\n\\tag{4.10}\\]\n이러한 대비는 계수의 합이 0 이므로 각 처리 효과들을 다양하게 비교하는데 사용될 수 있다. 가설 식 4.5 , 식 4.6 , 식 4.7 에 나타난 계수들 \\(c_i\\) 들은 모두 더하면 0이므로 대비라고 부른다.\n\n\n4.2.2 추론\n만약 선형식으로 주어진 가설 식 4.8 를 검정하려면 다음과 같이 각 처리의 표본 평균들의 조합으로 이루어진 통계량을 사용할 수 있다.\n\\[\n\\hat \\psi = L_* = c_1 \\bar x_{1.} + c_2 \\bar x_{2.} + \\dots + c_a \\bar x_{a.}\n\\tag{4.11}\\]\n이제 식 식 4.11 의 선형 추정량 \\(L_*\\) 의 평균과 분산을 구해보자\n\\[\n\\begin{aligned}\nE(L_*) & = E ( c_1 \\bar x_{1.} + c_2 \\bar x_{2.} + \\dots + c_a \\bar x_{a.} ) \\\\\n  & = c_1 E(\\bar x_{1.}) + c_2 E(\\bar x_{2.}) + \\dots + c_a E(\\bar  x_{a.}) \\\\\n  & = c_1 (\\mu+ \\alpha_1) + c_2 (\\mu + \\alpha_2) + \\dots + c_a  (\\mu + \\alpha_a) \\\\\n  & = \\mu \\sum_{i=1}^a c_i + c_1 \\alpha_1 + c_2  \\alpha_2 + \\dots + c_a   \\alpha_a \\\\\n  & =  c_1 \\alpha_1 + c_2  \\alpha_2 + \\dots + c_a   \\alpha_a\n\\end{aligned}\n\\]\n위의 유도에서 마지막 결과는 대비는 계수들의 합이 0 이라는 정의(\\(\\sum_{i=1}^a c_i =0\\))를 이용한 것이다.\n\\[  \n\\begin{aligned}\nV(L_*) & = V ( c_1 \\bar x_{1.} + c_2 \\bar x_{2.} + \\dots + c_a \\bar x_{a.} ) \\\\\n  & = c_1^2 V(\\bar x_{1.}) + c_2^2 V(\\bar x_{2.}) + \\dots + c_a^2 V(\\bar  x_{a.}) \\\\\n  & = c_1^2 \\frac{\\sigma^2}{r} + c_2^2 \\frac{\\sigma^2}{r} + \\dots + c_a^2  \\frac{\\sigma^2}{r} \\\\\n  & = \\frac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2\n\\end{aligned}\n\\]\n이제 일원배치 모형 식 4.4 에서 오차항 \\(e_{ij}\\)가 정규분포 를 따른 다고 가정하였으므로 관측값들의 선형조합은 정규분포를 따른다. 따라서 식 식 4.11 의 선형 추정량 \\(L_*\\)은 다음 같이 정규분포를 따른다.\n\\[\nL_* \\sim N \\left ( \\sum_i c_i \\alpha_i, \\frac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2 \\right )\n\\tag{4.12}\\]\n만약 선형식에 대한 가설 식 4.8 이 참이라면 선형 추정량 \\(L_*\\)의 평균은 0이 되고\n\\[\nL_* \\sim N \\left (0,  \\frac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2\\right )~~ \\text{ under } H_0: ~  \\sum_i c_i \\alpha_i =0\n\\tag{4.13}\\]\n위에서 배운 카이제곱 분포에 대한 결과 식 4.3 에 따라서 다음과 같은 결과를 얻는다.\n\\[\n\\frac{L_*^2}{\\tfrac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2 } \\sim \\chi^2(1) ~~\\text{ under } H_0: ~  \\sum_i c_i \\alpha_i =0\n\\tag{4.14}\\]\n분산분석에서 구한 오차제곱합 \\(SSE\\)는 또한 다음과 같이 자유도가 \\(n-a\\)인 카이제곱 분포를 따르며 선형식 \\(L_*\\)과 독립이다 (독립의 이유에 대한 설명은 본 강의의 수준을 넘어서므로 생략한다.)\n\\[\n\\frac{SSE}{\\sigma^2} \\sim \\chi^2(n-a)\n\\tag{4.15}\\]\n따라서 분포에 대한 두개의 결과 식 4.14 과 식 4.15 를 이용해 보자. 귀무가설 식 4.8 이 참인 경우 카이제곱 분포를 따르는 서로 독립인 독립변수의 비는 F-분포를 따른다.\n\\[\nF = \\frac{  \\left [ L_*^2 / \\tfrac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2 \\right ] /1} { \\left [ SSE/ \\sigma^2  \\right ] / (n-a)}\n=  \\left[ \\frac{L_*^2}{\\sum_{i=1}^a c_i^2/r } \\right ] / MSE  \\sim F(1, n-a) ~~\\text{ under } H_0\n\\tag{4.16}\\]\n따라서 대비로 표현되는 산형식에 대한 가설검정 식 4.8 은 식 식 4.16 의 \\(F\\) 통계량이 자유도 \\((1,n-a)\\)를 가진 F-분포의 상위 5% 백분위수보다 크면 귀무가설을 기각한다.\n\n\n4.2.3 표본합\n위 식 4.11 의 선형 추정량 \\(L_*\\) 은 각 처리에 대한 자료 합 \\(T_1, T_2, \\dots , T_a\\)로 다음과 같이 나타낼 수 있다. 교과서 7.1 식은 선형 추정량 \\(L\\) 을 평균이 아닌 합으로 표시하고 있다.\n각 처리에 대한 평균은 \\(\\bar x_{i.} = T_i / r\\)이므로\n\\[\n\\begin{aligned}\nL  & = c_1 T_1 + c_2 T_2 + \\dots + c_a T_a  \\\\\n  & = r( c_1 \\bar x_{1.} + c_2 \\bar x_{2.} + \\dots + c_a \\bar x_{a.} ) \\\\\n  & =r L_*\n\\end{aligned}\n\\]\n따라서 합으로 표시한 선형식 \\(L\\)의 평균과 분산은 다음과 같다\n\\[\n\\begin{aligned}\nE(L) & =  E(rL) \\\\\n   & = r E(L) \\\\\n   & = r \\sum_{i=1}^a c_i \\alpha_i \\\\\nV(L) & = V(rL_*) \\\\\n   & = r^2 V(L_*) \\\\\n   & = r \\sigma^2 \\sum_{i=1}^a c_i^2\n\\end{aligned}\n\\]\n카이제곱 분포에 대한 결과 식 4.3 에 따라서 다음과 같은 결과를 얻는다.\n\\[\n\\frac{L^2}{r\\sigma^2  \\sum_{i=1}^a c_i^2 } \\sim \\chi^2(1) ~~\\text{ under } H_0: ~  \\sum_i c_i \\alpha_i =0\n\\tag{4.17}\\]\n여기서 유의할 점은 평균으로 구성된 선형식과 합으로 구성된 선형식으로 유도된 카이제곱 통계량은 동일하다. 따라서 대비에 나타나는 게수들에 상수를 곱해줘도 검정통계량의 변화는 없다.\n\\[ \\frac{L^2}{ r\\sigma^2  \\sum_{i=1}^a c_i^2}  = \\frac{r^2 L_*^2}{r\\sigma^2  \\sum_{i=1}^a c_i^2 } = \\frac{L_*^2}{\\tfrac{\\sigma^2}{r} \\sum_{i=1}^a c_i^2 } \\]\n이제 평균의 선형식과 같은 방법으로 합으로 표시된 선형식 \\(L\\)에 대하여 다음과 같은 결과를 구할 수 있다.\n\\[\n\\begin{aligned}\nF & = \\frac{  \\left [ L^2 / r \\sigma^2 \\sum_{i=1}^a c_i^2 \\right ] /1} { \\left [ SSE/ \\sigma^2  \\right ] / (n-a)} \\\\\n& =  \\left[ \\frac{L^2}{r \\sum_{i=1}^a c_i^2 } \\right ] / MSE  \\\\\n& = SS_L / MSE \\sim F(1, n-a) ~~\\text{ under } H_0\n\\end{aligned}\n\\]\n위에서 \\(SS_L\\)은 교과서 7.2 식에서 정의된 통계량과 같다.",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>대비</span>"
    ]
  },
  {
    "objectID": "qmd/contrast.html#직교-대비",
    "href": "qmd/contrast.html#직교-대비",
    "title": "4  대비",
    "section": "4.3 직교 대비",
    "text": "4.3 직교 대비\n\n4.3.1 직교 대비의 정의\n다음과 같이 처리그룹의 합으로 표시된 2개의 서로 다른 대비 \\(C_1\\)과 \\(C_2\\)를 고려하자.\n\\[\nC_1 = c_1 T_1 + c_2 T_2 + \\dots + c_a T_a, \\quad \\sum_{i=1}^a c_i =0\n\\tag{4.18}\\]\n\\[\nC_2 = d_1 T_1 + d_2 T_2 + \\dots + d_a T_a, \\quad \\sum_{i=1}^a d_i =0\n\\tag{4.19}\\]\n서로 다른 두 대비에서 계수들의 내적이 0 이 되는 경우 두 대비가 직교(orthogonal)한다고 말한다.\n\\[\n\\sum_{i=1}^a c_i d_i =0 \\quad \\rightarrow \\text{ orthogonal constrast}\n\\tag{4.20}\\]\n대비가 서로 직교하면 그에 따른 두 제곱합 \\(SS_{C_1}\\)과 \\(SS_{C_2}\\)는 서로 독립이다.\n\\[ SS_{C_1} = \\frac{C_1^2}{r\\sum_i c_i^2 } \\quad \\sim_{indep.} \\quad SS_{C_2} = \\frac{C_2^2}{r\\sum_i d_i^2 } \\]\n따라서 앞 절에서 배운 각 대비에 대한 가설을 검정할 수 있는 F-통계량도 독립이다.\n\\[ F_1 = \\frac{SS_{C_1}}{MSE}  \\quad \\sim_{indep.} \\quad F_2 = \\frac{SS_{C_2}}{MSE} \\]\n\n\n4.3.2 처리 제곱합의 분해\n만약 요인 \\(A\\)가 \\(a\\)개의 수준을 가지면 이 요인에 대한 직교하는 대비를 \\(a-1\\)개 만들 수 있다. 주의할 점은 직교하는 대비들는 유일하지 않다.\n또한 각 대비 \\(C_{i}\\)에 대한 제곱합은 자유도가 1인 카이제곱 분포를 따르며 서로 독립이다. 더 나아가 분산분석에서 요인 A에 대한 처리제곱합 \\(SS_A\\)가 다은과 같이 분해된다.\n\\[ SS_A = SS_{C_1}  + SS_{C_2} + SS_{C_3} + \\dots + SS_{C_{a-1}} \\]\n\n\n4.3.3 대표적인 대비\n\n4.3.3.1 다항 대비\n직교하는 대비들 중에 대표적인 예로 다항 대비(polynomial contrasts)가 있다. 다항 대비는 처리 수준의 간격이 일정한 경우 평균의 변화가 선형(linear)인지, 이차적(quadratic)인지, 더 나아가 \\(k\\)차 다항식의 변화를 가지는지 검정할 수 있다.\n다항대비의 계수들은 검정하고자 하는 변화의 추세가 강할 수록 대응하는 제곱합이 크게 되도록 설계되어 있다. 따라서 귀무가설에 대한 p-값이 크면 변화의 추세가 강하게 나타난다고 말할 수 있다.\n예를 들어 3개의 수준에서 다음과 같이 2개의 다항 대비를 구할 수 있다. 아래 R 출력에 나오는 행렬의 각 열이 서로 직교하는 대비이다. 대비들의 계수의 제곱의 합이 1이 되도록(\\(\\sum_i c_i^2=1\\)) 정규화한 결과이다.\n\ncontr.poly(3)\n\n                .L         .Q\n[1,] -7.071068e-01  0.4082483\n[2,] -9.073800e-17 -0.8164966\n[3,]  7.071068e-01  0.4082483\n\n\n첫 번째 열이 선형 대비(linear contrast)로 계수는 다음과 같다.\n\\[ c_1= - \\frac{1}{\\sqrt{2}}, \\quad c_2 =0 \\quad c_3= \\frac{1}{\\sqrt{2}} \\]\n선형 대비를 그림으로 그려보면 다음과 같다.\n\nx &lt;- c(-1,0,1)\ny1 &lt;- contr.poly(3)[,1]\nplot(x,y1 )\npoints(x,y1,cex=2, pch =3)\n\n\n\n\n\n\n\n\n두 번째 열은 이차 대비(quadratic contrast)로 계수는 다음과 같다.\n\\[ c_1=  \\frac{1}{\\sqrt{6}}, \\quad c_2 = - \\frac{2}{\\sqrt{6}} \\quad c_3=  \\frac{1}{\\sqrt{6}} \\] 이차 대비를 그림으로 그려보면 다음과 같다.\n\ny2 &lt;- contr.poly(3)[,2]\nplot(x,y2 )\npoints(x,y2,cex=2, pch =3)\n\n\n\n\n\n\n\n\n다음과 같이 수준의 개수가 \\(5\\)인 경우 4차 다항대비를 구해준다. 함수 contr.poly(k)는 \\(k-1\\)차 다항 대비까지 구해준다.\n\ncontr.poly(5)\n\n                .L         .Q            .C         ^4\n[1,] -6.324555e-01  0.5345225 -3.162278e-01  0.1195229\n[2,] -3.162278e-01 -0.2672612  6.324555e-01 -0.4780914\n[3,] -3.288380e-17 -0.5345225  9.637305e-17  0.7171372\n[4,]  3.162278e-01 -0.2672612 -6.324555e-01 -0.4780914\n[5,]  6.324555e-01  0.5345225  3.162278e-01  0.1195229",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>대비</span>"
    ]
  },
  {
    "objectID": "qmd/contrast.html#교과서-예제-7.1",
    "href": "qmd/contrast.html#교과서-예제-7.1",
    "title": "4  대비",
    "section": "4.4 교과서 예제 7.1",
    "text": "4.4 교과서 예제 7.1\n교과서 예제 7.1 에서 제조회사에 대한 비교를 하는 경우 요인의 개수가 3개이므로 2개의 직교 대비를 이용한다.\n예제 7.1 에서 제조회사에 대한 비교를 하는 경우 이용한 대비의 계수는 다음과 같다.\n\\[ c_1= 1, ~~ c_2=1, ~~ c_3 = -2 \\] \\[ d_1= 1, ~~d_2=-1, ~~ d_3= 0 \\]\n\n4.4.1 이원배치 자료\n\n\n\n이원배치 자료\n\n\n\ny &lt;- c(11,18,25,1,6,14,6,15,18)\nA &lt;- factor(c(rep(c(\"A1\", \"A2\",\"A3\"), each=3)))\nB &lt;- factor(c(rep(c(\"B1\", \"B2\",\"B3\"), 3)))\ndf &lt;- data.frame(A,B,y)\ndf\n\n   A  B  y\n1 A1 B1 11\n2 A1 B2 18\n3 A1 B3 25\n4 A2 B1  1\n5 A2 B2  6\n6 A2 B3 14\n7 A3 B1  6\n8 A3 B2 15\n9 A3 B3 18\n\n\n\ndf %&gt;%  ggplot( aes(x = A , y = y) ) +  geom_boxplot()\n\n\n\n\n\n\n\n\n\ndf %&gt;%  ggplot( aes(x = B , y = y) ) +  geom_boxplot()\n\n\n\n\n\n\n\n\n\n\n4.4.2 분산분석표\n\n\n\n분산분석표\n\n\n\nfm1 &lt;- aov(y~A+B, data=df)\nsummary(fm1)\n\n            Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nA            2    182      91    45.5 0.001773 ** \nB            2    254     127    63.5 0.000932 ***\nResiduals    4      8       2                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n4.4.3 직교대비에 대한 제곱합의 분해\n\n\n\n제곱합의 분해\n\n\n\n\n4.4.4 직교대비에 대한 검정\n\n4.4.4.1 요인 A: 제조 회사에 대한 직교 대비\n\n# 직교 대비 계수 설정\nc1 &lt;- c(1, 1, -2) # 국산 대 외제\nc2 &lt;- c(1, -1, 0) # 자사 대 국내사\n\n#직교대비 행렬 생성  \nmatA &lt;- cbind(c1,c2)\nmatA\n\n     c1 c2\n[1,]  1  1\n[2,]  1 -1\n[3,] -2  0\n\n# 요인에 대한 대비 지정\ncontrasts(df$A) &lt;- matA\n\n# 직교대비에 대한 검정 \nfm1 &lt;- aov(y~A+B, data=df) # 직교대비 지정한 후에 다시 분산분석을 해주어야 한다.\nsummary.aov(fm1 , split=list(A=list(\"국산 대 외제\"=1, \"자사 대 국내사\" = 2))) \n\n                    Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nA                    2  182.0    91.0   45.50 0.001773 ** \n  A: 국산 대 외제    1    0.5     0.5    0.25 0.643330    \n  A: 자사 대 국내사  1  181.5   181.5   90.75 0.000678 ***\nB                    2  254.0   127.0   63.50 0.000932 ***\nResiduals            4    8.0     2.0                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n4.4.4.2 요인 B: 성형온도에 대한 직교 대비\n\n# 요인에 대한 대비 지정\ncontrasts(df$B) &lt;- contr.poly(3)\n\n# 직교대비에 대한 검정 \nfm1 &lt;- aov(y~A+B, data=df) # 직교대비 지정한 후에 다시 분산분석을 해주어야 한다.\nsummary(fm1 , split=list(B=list(\"선형\"=1, \"이차\" = 2))) \n\n            Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nA            2  182.0    91.0   45.50 0.001773 ** \nB            2  254.0   127.0   63.50 0.000932 ***\n  B: 선형    1  253.5   253.5  126.75 0.000355 ***\n  B: 이차    1    0.5     0.5    0.25 0.643330    \nResiduals    4    8.0     2.0                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n4.4.5 두 요인을 모두 나타내는 분산분석\n\nfm1 &lt;- aov(y~A+B, data=df) # 직교대비 지정한 후에 다시 분산분석을 해주어야 한다.\nsummary(fm1 , split=list( A=list(\"국산 대 외제\"=1, \"자사 대 국내사\" = 2), B=list(\"선형\"=1, \"이차\" = 2))) \n\n                    Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nA                    2  182.0    91.0   45.50 0.001773 ** \n  A: 국산 대 외제    1    0.5     0.5    0.25 0.643330    \n  A: 자사 대 국내사  1  181.5   181.5   90.75 0.000678 ***\nB                    2  254.0   127.0   63.50 0.000932 ***\n  B: 선형            1  253.5   253.5  126.75 0.000355 ***\n  B: 이차            1    0.5     0.5    0.25 0.643330    \nResiduals            4    8.0     2.0                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n직교대비에 대한 분산분석표",
    "crumbs": [
      "<span class='chapter-number'>4</span>  <span class='chapter-title'>대비</span>"
    ]
  },
  {
    "objectID": "qmd/twolevels.html",
    "href": "qmd/twolevels.html",
    "title": "5  2수준 요인배치법",
    "section": "",
    "text": "5.1 반복이 없는 \\(2^3\\) 요인배치법\n먼저 반복이 없는 \\(2^3\\) 요인배치법이 적용되는 교과서 예제 7.3 에 대하여 논의합니다.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2수준 요인배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevels.html#threefactor",
    "href": "qmd/twolevels.html#threefactor",
    "title": "5  2수준 요인배치법",
    "section": "",
    "text": "5.1.1 처리조합 자료의 생성\n먼저 R 프로그림을 이용하여 분석을 하기 위해서는 실험 자료를 data.frame 형식으로 만들어야 한다.\n먼저 각 요인의 수준을 조합하여 처리의 조합을 만들어 보자. 처리의 조합을 만드는 일은 일일이 손으로 처리 조합을 만들 수 있지만 패키지 FrF2 에 있는 함수 FrF2()를 사용하면 처리 조합에 대한 데이터프레임을 쉽게 만들 수 있다.\n이제 \\(2^3\\) 요인배치법의 처리 조합은 다음과 같이 만들 수 있다.\n\nX &lt;- FrF2(nruns=8, nfactors=3, randomize = FALSE)\nX\n\n   A  B  C\n1 -1 -1 -1\n2  1 -1 -1\n3 -1  1 -1\n4  1  1 -1\n5 -1 -1  1\n6  1 -1  1\n7 -1  1  1\n8  1  1  1\nclass=design, type= full factorial \n\n\n위에서 함수 FrF2()는 다음과 같은 인자를 가진다.\n\nnruns : 처리 조합의 개수\nnfactors : 요인의 개수\nrandomize=TRUE : 처리조합의 순서를 임의로 바꾸는 명령\n\nFrF2(nruns, nfactors, randomize=TRUE)\n우리는 지금 3개의 요인을 가진 2요인 배치법을 고려하므로 위와 같이 nruns=8, nfactors=3 으로 지정해야 한다. 또한 실험을 직접 실행하는 것이 아니므로 실험의 순서는 임의화 하지 않는다 (randomize = FALSE). 유의할 점은 요인의 이름은 다른 지정을 하지 않으면 알파벳 대문자 순서(A, B, C,…)로 지정해 준다.\n이제 반응값을 위에서 생성한 처리의 조합순서대로 생성하고 함수 cbind() 를 이용하여 실험자료를 만들어 보자.\n\ny &lt;- c(2,-5,15,13,-12,-17,-2,-7)\ndf &lt;- cbind(X,y)\ndf %&gt;%  kbl() %&gt;%   kable_paper(\"hover\", full_width = F)\n\n\n\n\n\nA\nB\nC\ny\n\n\n\n\n-1\n-1\n-1\n2\n\n\n1\n-1\n-1\n-5\n\n\n-1\n1\n-1\n15\n\n\n1\n1\n-1\n13\n\n\n-1\n-1\n1\n-12\n\n\n1\n-1\n1\n-17\n\n\n-1\n1\n1\n-2\n\n\n1\n1\n1\n-7\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n주의\n\n\n\n위에서 작성한 3 요인의 2수준 배치법의 자료에서 처리의 순서는 표준형 순서(standard order)로 정렬되어 있다.\n표준형 순서는 요인의 순서를 A, B, C 로 고려한다면 제일 먼저 나오는 요인의 수준이 가장 빨리 변하고 다음 요인의 순서가 그 보다 느리게 변하며 가장 마지막의 요인에 대한 수준의 순서가 가장 느리게 변하는 것을 의미한다.\n즉 요인 A 의 순서는 -+-+-+-+, 요인 B의 순서는 --++--++ 이며 마지막 요인 C의 순서는 ----++++ 이다.\n함수 FrF2() 는 randomize = FALSE 로 지정해 주면 처리의 순서를 표준형 순서로 생성한다.\n\n\n\n\n5.1.2 처리효과의 계산\n\n5.1.2.1 인수분해법\n이제 교과서에서 나오는 방법으로 처리 효과를 계산헤 보자.\n요인 A 에 대한 주 효과는 인수분해 방법을 통해서 다음과 같이 계산할 수 있다.\n\\[ A = \\frac{1}{4} (a-1)(b+1)(c+1) = \\frac{1}{4} [(a + ac + ab + abs) - ((1)-c-b-bd)] \\]\n따라서 A 에 대한 주효과는 다음과 같이 계산된다.\n\\[ A = \\frac{1}{4} [(-5+13-17-7)-(2 +15-12-2)] = -4.75 \\]\n다른 모든 요인들의 주효과와 상호작용 효과는 교과서 181-182에 나오는 인수분해법으로 구할 수 있다.\n\n\n5.1.2.2 함수 yates()\n패키지 unrepx 에 나오는 함수 yates 를 이용하면 손쉽게 처리 효과를 계산할 수 있다.\n\nyates(df$y, labels = c(\"A\", \"B\", \"C\"))\n\n     A      B     AB      C     AC     BC    ABC \n -4.75  12.75   1.25 -15.75  -0.25  -2.75  -1.25 \nattr(,\"mean\")\n       \n-1.625 \n\n\n함수 yates 는 첫 번째 인자로 표준형 순서로 정렬되어 있는 반응값의 벡터를 넣어주고 두 번째 인자 labels 로 요인의 이름으로 구성된 문자 벡터를 넣어준다. 함수 yates 의 결과는 각 요인의 효과를 계산해 주고 마지막으로 전체 평균 \\(\\bar y\\) 를 생성한다.\n함수 yates()를 이용하면 표준형 순서로서 영문 소문자 표기법으로 표시된 처리조합을 구할 수 있다. 예를 들어서 \\(2^4\\) 실험법에 대하여 abcd 표기법으로 표준형 순서로 정렬된 처리 조합을 아래와 같이 구할 수 있다,\n물론 가장 처음의 처리 (1) 은 결과에 나타나지 않는다.\n\nXX &lt;- FrF2(16, 4, randomize=FALSE)\nyy &lt;- 1:16\ndf4 &lt;- cbind(XX,yy)\ndf4 %&gt;%  kbl() %&gt;%   kable_paper(\"hover\", full_width = F)\n\n\n\n\n\nA\nB\nC\nD\nyy\n\n\n\n\n-1\n-1\n-1\n-1\n1\n\n\n1\n-1\n-1\n-1\n2\n\n\n-1\n1\n-1\n-1\n3\n\n\n1\n1\n-1\n-1\n4\n\n\n-1\n-1\n1\n-1\n5\n\n\n1\n-1\n1\n-1\n6\n\n\n-1\n1\n1\n-1\n7\n\n\n1\n1\n1\n-1\n8\n\n\n-1\n-1\n-1\n1\n9\n\n\n1\n-1\n-1\n1\n10\n\n\n-1\n1\n-1\n1\n11\n\n\n1\n1\n-1\n1\n12\n\n\n-1\n-1\n1\n1\n13\n\n\n1\n-1\n1\n1\n14\n\n\n-1\n1\n1\n1\n15\n\n\n1\n1\n1\n1\n16\n\n\n\n\n\n\n\n\n\nyates(df4$yy , c(\"A\", \"B\", \"C\", \"D\"))\n\n   A    B   AB    C   AC   BC  ABC    D   AD   BD  ABD   CD  ACD  BCD ABCD \n   1    2    0    4    0    0    0    8    0    0    0    0    0    0    0 \nattr(,\"mean\")\n    \n8.5 \n\n\n\n\n5.1.2.3 R 프로그램을 이용\nR 프로그램을 이용하여 Yates 방법으로 처리 효과를 계산해주는 함수 myyates 를 만들어 보자.\n\n# yates 방법으로 처리 효과를 계산해주는 함수\nmyyates &lt;- function(y) {\n   n &lt;- length(y)  #자료의 수\n   k = round(log(n)/log(2))  # 요인의 수\n   nhalf &lt;- n/2  # (자료의 수)/2\n   \n   res&lt;- rep(0,n)\n   \n   for ( i in 1:k ){\n     for (j in 1:nhalf) {\n       res[j] &lt;- y[2*j-1] + y[2*j]\n     } \n     for (j in 1:nhalf) {\n       res[j+nhalf] &lt;- -y[2*j-1] + y[2*j]\n     } \n     y &lt;-res\n   }\n   res &lt;- res/nhalf\n   res[1] &lt;- res[1]/2\n   res\n}   \n   \nmyyates(df$y)  \n\n[1]  -1.625  -4.750  12.750   1.250 -15.750  -0.250  -2.750  -1.250\n\n\n함수 myyates 를 이용하여 얻은 결과에서 처음 나온 수는 전체 평균의 2 배이며 두 번째 수부터 표준 효과의 추정값이다.\n\n\n5.1.2.4 회귀식의 이용\n이제 위에서 고려한 데이터프레임 df 에 대한 회귀식을 적합시키자.\n아래 회귀식에서 y~A*B*C 는 변수 y 를 반응변수로 하고 3개의 요인 A, B, C 의 각 개별 효과와 모든 상호작용 효과를 고려한 선형 모형이다.\n즉, 아래 적합한 모형은 요인의 수준이 모두 범주형인 경우이므로 다음과 같은 3원배치 분산분석 모형을 적합하는 것이다.\n\\[\ny_{ijk} = \\mu + \\alpha_i + \\beta_j + \\gamma_k + (\\alpha \\beta)_{ij} +(\\beta \\gamma)_{jk} + (\\alpha \\gamma )_{ik} + (\\alpha \\beta \\gamma_k) + e_{ijk},\\quad i=1,2,~j=1,2,~k=1,2\n\\tag{5.1}\\]\n\nfm1 &lt;- lm (y~ A*B*C, data=df) \nsummary(fm1)\n\n\nCall:\nlm.default(formula = y ~ A * B * C, data = df)\n\nResiduals:\nALL 8 residuals are 0: no residual degrees of freedom!\n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)   -1.625        NaN     NaN      NaN\nA1            -2.375        NaN     NaN      NaN\nB1             6.375        NaN     NaN      NaN\nC1            -7.875        NaN     NaN      NaN\nA1:B1          0.625        NaN     NaN      NaN\nA1:C1         -0.125        NaN     NaN      NaN\nB1:C1         -1.375        NaN     NaN      NaN\nA1:B1:C1      -0.625        NaN     NaN      NaN\n\nResidual standard error: NaN on 0 degrees of freedom\nMultiple R-squared:      1, Adjusted R-squared:    NaN \nF-statistic:   NaN on 7 and 0 DF,  p-value: NA\n\n\n위의 모형 식 5.1 은 모수의 개수가 \\(1+2+2+2+4+4+4+8=27\\)이다. 하지만 관측값이 8개이기 때문에 정규방정식의 해가 유일하게 존재하지 않는다. 따라서 최소한 19개의 제약 조건이 필요하다. 고차원 배치법에 대한 회귀모형에서 제약조건을 주는 방법은 과목의 범위를 벋어나므로 생략한다.\n위의 추정 결과는 8개의 관측값을 가지고 8개의 모수를 가진 모형을 적합하는 경우이며 이렇게 관측값의 개수와 모수의 개수가 같은 모형을 포화모형(saturated model)이라고 부른다. 포화모형에서는 오차항의 분산을 추정할 수 있는 잔차가 모두 0이기 때문에 \\(\\sigma^2\\) 을 추정할 수 없다. 따라서 표준오차도 구할 수 없다.\n회귀식의 계수에 대한 추정치에서 절편을 제외한 추정치는 대응하는 효과 추정치의 절반인 것을 알 수 있다. 절편의 주정치는 전체 평균 \\(\\bar y\\)이다.\n\ncoef(fm1)[-1]*2\n\n      A1       B1       C1    A1:B1    A1:C1    B1:C1 A1:B1:C1 \n   -4.75    12.75   -15.75     1.25    -0.25    -2.75    -1.25 \n\n\n위에서 적합한 회귀식을 선형모형 \\(\\pmb y = \\pmb X \\pmb \\beta + \\pmb e\\) 로 보면 모형의 계획행렬 \\(\\pmb X\\) 는 다음과 같이 나오며 열이 각 효과의 대비인 것을 알 수 있다.\n\nX &lt;- model.matrix(fm1)\nX\n\n  (Intercept) A1 B1 C1 A1:B1 A1:C1 B1:C1 A1:B1:C1\n1           1 -1 -1 -1     1     1     1       -1\n2           1  1 -1 -1    -1    -1     1        1\n3           1 -1  1 -1    -1     1    -1        1\n4           1  1  1 -1     1    -1    -1       -1\n5           1 -1 -1  1     1    -1    -1        1\n6           1  1 -1  1    -1     1    -1       -1\n7           1 -1  1  1    -1    -1     1       -1\n8           1  1  1  1     1     1     1        1\nattr(,\"assign\")\n[1] 0 1 2 3 4 5 6 7\nattr(,\"contrasts\")\nattr(,\"contrasts\")$A\n   [,1]\n-1   -1\n1     1\n\nattr(,\"contrasts\")$B\n   [,1]\n-1   -1\n1     1\n\nattr(,\"contrasts\")$C\n   [,1]\n-1   -1\n1     1\n\nyvec &lt;- matrix(df$y, 8, 1)\nyvec\n\n     [,1]\n[1,]    2\n[2,]   -5\n[3,]   15\n[4,]   13\n[5,]  -12\n[6,]  -17\n[7,]   -2\n[8,]   -7\n\n\n따라서 위에서 함수 model.matrix 로 구한 행렬 \\(\\pmb X\\) 의 전치 \\(\\pmb X^t\\) 에 반응 변수 벡터 \\(\\pmb y\\) 를 곱해주면, 즉 \\(\\pmb X^t \\pmb y\\) 는 각 효과에 대하여 합으로 구한 대비를 얻을 수 있다. 이렇게 합으로 구한 대비를 적절한 수로 나누어 주면 평균의 대비도 얻을 수 있다. 이 예제와 같은 반복이 없는 \\(2^3\\) 배치법은 4로 나누어 주면 된다. 주의할 점은 앞에서 효과를 회귀계수로 구하는 경우와 마찬가지로 \\(\\pmb X^t \\pmb y\\) 의 첫 번째 원소는 모든 반응값의 총합 \\(T_{...}\\) 인 것에 유의하자.\n\\[\n\\pmb X^t \\pmb y =\n\\begin{bmatrix}\nT_{...} \\\\\nT_{1..} - T_{0..} \\\\\n\\vdots\n\\end{bmatrix}\n\\]\n예를 들어서 \\(A\\) 에 대한 주효과는 다음과 같이 구할 수 있으며 아래에서 total_effect 가 \\(T_{1..} - T_{0..}\\) 이고 mean_effect 는 \\((T_{1..} - T_{0..})/4\\) 이다.\n\\[\nA = \\frac{1}{4} ( T_{1..} - T_{0..}) = \\frac{1}{4}\n\\begin{bmatrix}\n-1 & 1 & -1 & 1 & -1 & 1 & -1 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n2 \\\\\n-5 \\\\\n15 \\\\\n13 \\\\\n-12 \\\\\n-17 \\\\\n-2 \\\\\n-7\n\\end{bmatrix}\n= -4.75\n\\]\n\ntotal_effect &lt;- t(X) %*% yvec\ntotal_effect &lt;- total_effect[-1]\ntotal_effect\n\n[1] -19  51 -63   5  -1 -11  -5\n\nmean_effect &lt;- total_effect/4\nmean_effect\n\n[1]  -4.75  12.75 -15.75   1.25  -0.25  -2.75  -1.25\n\n\n앞에서 회귀모형의 계수가 각 효과의 2 배로 나타나는 이유는 다음과 같이 회귀식의 계수를 구하는 정규방정식에서 \\(\\pmb X^t \\pmb X\\) 가 대각행렬이며 대각원소의 값이 자료의 개수 \\((2^3) = 8\\) 로 나타나기 때문이다. 효과를 구하기 구하는 때는 함으로 이루어진 대비를 \\(2^2=4\\) 로 나누기 떄문에 회귀계수의 추정값은 효과의 추정값의 절반으로 나타난다.\n\\[\n\\pmb X^t \\pmb X \\pmb \\beta = \\pmb X^t \\pmb y  \\quad \\rightarrow \\quad \\hat{\\pmb \\beta} = (\\pmb X^t \\pmb X)^{-1}\\pmb X^t \\pmb y\n\\]\n\nt(X) %*% X\n\n            (Intercept) A1 B1 C1 A1:B1 A1:C1 B1:C1 A1:B1:C1\n(Intercept)           8  0  0  0     0     0     0        0\nA1                    0  8  0  0     0     0     0        0\nB1                    0  0  8  0     0     0     0        0\nC1                    0  0  0  8     0     0     0        0\nA1:B1                 0  0  0  0     8     0     0        0\nA1:C1                 0  0  0  0     0     8     0        0\nB1:C1                 0  0  0  0     0     0     8        0\nA1:B1:C1              0  0  0  0     0     0     0        8\n\n\n\nbeta_hat &lt;- solve(t(X) %*% X) %*% t(X) %*% yvec\nbeta_hat\n\n              [,1]\n(Intercept) -1.625\nA1          -2.375\nB1           6.375\nC1          -7.875\nA1:B1        0.625\nA1:C1       -0.125\nB1:C1       -1.375\nA1:B1:C1    -0.625\n\n\n\n\n\n5.1.3 분산분석\n분산분석표는 앞에서 적합한 모형 식 5.1 을 적합한 후 aov() 또는 anova() 함수를 적용하면 구할 수 있다.\n앞에서 언급하였듯이 모형 식 5.1 은 포화모형이므로 제곱합은 구할 수 있지만 잔차제곱합을 구할 수 없으므로 가설 검정은 할 수 없다.\n\nanova(fm1)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value Pr(&gt;F)\nA          1  45.13   45.13     NaN    NaN\nB          1 325.12  325.12     NaN    NaN\nC          1 496.13  496.13     NaN    NaN\nA:B        1   3.13    3.13     NaN    NaN\nA:C        1   0.13    0.13     NaN    NaN\nB:C        1  15.12   15.12     NaN    NaN\nA:B:C      1   3.13    3.13     NaN    NaN\nResiduals  0   0.00     NaN               \n\n\n위의 분산분석표에서 효과 \\(A \\times B\\), \\(A \\times C\\), \\(A \\times B \\times C\\) 에 대한 제곱합의 크기가 다른 효과에 비하여 상대적으로 매우 작다.\n\n\n5.1.4 핵심 요인효과의 선별\n핵심요인 효과는 효과 추정치의 절대값 \\(| \\bar y_1 -\\bar y_0|\\) 들을 가지고 반정규확률 그림을 그려서 선별할 수 있다.\n반정규확률 그림은 패키지 FrF2에 있는 함수 DanielPlot() 를 사용하여 구할 수 있다.\n\nDanielPlot(fm1, half=TRUE)\n\n\n\n\n\n\n\n\n위의 반정규확률 그림을 보면 주요인 \\(B\\) 와 \\(C\\) 가 핵심 요인임을 알 수 있다.\n교과서 예제의 결론과 같이 제곱합이 작은 3개의 효과 \\(A \\times B\\), \\(A \\times C\\), \\(A \\times B \\times C\\) 를 풀링하여 모형을 다시 적합해 보자.\n이제 회귀식을 적합시키자.\n\nfm11 &lt;- lm (y~ A+B+C+B*C, data=df) \nsummary(fm11)\n\n\nCall:\nlm.default(formula = y ~ A + B + C + B * C, data = df)\n\nResiduals:\n     1      2      3      4      5      6      7      8 \n 1.125 -1.125 -1.375  1.375  0.125 -0.125  0.125 -0.125 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  -1.6250     0.5154  -3.153 0.051148 .  \nA1           -2.3750     0.5154  -4.608 0.019220 *  \nB1            6.3750     0.5154  12.369 0.001138 ** \nC1           -7.8750     0.5154 -15.280 0.000609 ***\nB1:C1        -1.3750     0.5154  -2.668 0.075826 .  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.458 on 3 degrees of freedom\nMultiple R-squared:  0.9928,    Adjusted R-squared:  0.9832 \nF-statistic: 103.7 on 4 and 3 DF,  p-value: 0.001514\n\nanova(fm11)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq  F value    Pr(&gt;F)    \nA          1  45.13   45.13  21.2353 0.0192201 *  \nB          1 325.12  325.12 153.0000 0.0011384 ** \nC          1 496.13  496.13 233.4706 0.0006088 ***\nB:C        1  15.12   15.12   7.1176 0.0758265 .  \nResiduals  3   6.38    2.13                       \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n5.1.5 부록: 처리 조합을 만드는 다른 방법\n참고로 처리 조합의 데이터프레임을 만드는 다른 방법을 알아보자.\n함수 expand.grid() 는 인자로 주어진 벡터들의 원소들로 구성된 모든 조합을 만들어 주는 함수이다.\n\nX1 &lt;-  expand.grid(A = gl(2, 1, labels = c(\"-1\", \"1\")),\n                   B = gl(2, 1, labels = c(\"-1\", \"1\")),\n                   C = gl(2, 1, labels = c(\"-1\", \"1\")))\nX1\n\n   A  B  C\n1 -1 -1 -1\n2  1 -1 -1\n3 -1  1 -1\n4  1  1 -1\n5 -1 -1  1\n6  1 -1  1\n7 -1  1  1\n8  1  1  1\n\n\n함수 expand.grid() 의 인자에 대한 설명은 다음과 같다.\ngl(n, k, length = n*k, labels = seq_len(n), ordered = FALSE)\n\n- n: an integer giving the number of levels.\n- k: an integer giving the number of replications.\n- labels: an optional vector of labels for the resulting factor levels.\n- ordered: a logical indicating whether the result should be ordered or not.\n만약 반복이 있다면 데이터프레임을 함수 rbind() 를 이용하여 붙이면 된다.\n\nX2 &lt;- rbind(X1, X1)\nX2\n\n    A  B  C\n1  -1 -1 -1\n2   1 -1 -1\n3  -1  1 -1\n4   1  1 -1\n5  -1 -1  1\n6   1 -1  1\n7  -1  1  1\n8   1  1  1\n9  -1 -1 -1\n10  1 -1 -1\n11 -1  1 -1\n12  1  1 -1\n13 -1 -1  1\n14  1 -1  1\n15 -1  1  1\n16  1  1  1",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2수준 요인배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevels.html#반복이-없는-24-요인배치법",
    "href": "qmd/twolevels.html#반복이-없는-24-요인배치법",
    "title": "5  2수준 요인배치법",
    "section": "5.2 반복이 없는 \\(2^4\\) 요인배치법",
    "text": "5.2 반복이 없는 \\(2^4\\) 요인배치법\n먼저 반복이 없는 \\(2^4\\) 요인배치법이 적용되는 교과서 예제 7.4 에 대하여 논의합니다.\n\n5.2.1 처리조합 자료의 생성\n\nX &lt;- FrF2(nruns=16, nfactors=4, randomize = FALSE)\nX\n\n    A  B  C  D\n1  -1 -1 -1 -1\n2   1 -1 -1 -1\n3  -1  1 -1 -1\n4   1  1 -1 -1\n5  -1 -1  1 -1\n6   1 -1  1 -1\n7  -1  1  1 -1\n8   1  1  1 -1\n9  -1 -1 -1  1\n10  1 -1 -1  1\n11 -1  1 -1  1\n12  1  1 -1  1\n13 -1 -1  1  1\n14  1 -1  1  1\n15 -1  1  1  1\n16  1  1  1  1\nclass=design, type= full factorial \n\ny&lt;- c(-1, 0, 9, 4, 5, 3, 11, 8,-1, -9, 1, 5, -9, -13, -5, -4)\ndf2 &lt;- cbind(X,y)\ndf2 %&gt;%  kbl() %&gt;%   kable_paper(\"hover\", full_width = F)\n\n\n\n\n\nA\nB\nC\nD\ny\n\n\n\n\n-1\n-1\n-1\n-1\n-1\n\n\n1\n-1\n-1\n-1\n0\n\n\n-1\n1\n-1\n-1\n9\n\n\n1\n1\n-1\n-1\n4\n\n\n-1\n-1\n1\n-1\n5\n\n\n1\n-1\n1\n-1\n3\n\n\n-1\n1\n1\n-1\n11\n\n\n1\n1\n1\n-1\n8\n\n\n-1\n-1\n-1\n1\n-1\n\n\n1\n-1\n-1\n1\n-9\n\n\n-1\n1\n-1\n1\n1\n\n\n1\n1\n-1\n1\n5\n\n\n-1\n-1\n1\n1\n-9\n\n\n1\n-1\n1\n1\n-13\n\n\n-1\n1\n1\n1\n-5\n\n\n1\n1\n1\n1\n-4\n\n\n\n\n\n\n\n\n\n\n5.2.2 처리효과의 계산\n\nyates(df2$y, c(\"A\", \"B\", \"C\", \"D\"))\n\n    A     B    AB     C    AC    BC   ABC     D    AD    BD   ABD    CD   ACD \n-2.00  6.75  1.25 -1.50  0.00 -0.75 -0.25 -9.25  0.25  0.50  3.00 -5.25  0.25 \n  BCD  ABCD \n 0.00 -1.50 \nattr(,\"mean\")\n     \n0.25 \n\n\n\n5.2.2.1 포화모형의 적합\n이제 포화모형인 회귀식을 적합시키자.\n\nfm2 &lt;- lm (y~ A*B*C*D, data=df2) \nsummary(fm2)\n\n\nCall:\nlm.default(formula = y ~ A * B * C * D, data = df2)\n\nResiduals:\nALL 16 residuals are 0: no residual degrees of freedom!\n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)\n(Intercept)  2.500e-01        NaN     NaN      NaN\nA1          -1.000e+00        NaN     NaN      NaN\nB1           3.375e+00        NaN     NaN      NaN\nC1          -7.500e-01        NaN     NaN      NaN\nD1          -4.625e+00        NaN     NaN      NaN\nA1:B1        6.250e-01        NaN     NaN      NaN\nA1:C1       -1.095e-15        NaN     NaN      NaN\nB1:C1       -3.750e-01        NaN     NaN      NaN\nA1:D1        1.250e-01        NaN     NaN      NaN\nB1:D1        2.500e-01        NaN     NaN      NaN\nC1:D1       -2.625e+00        NaN     NaN      NaN\nA1:B1:C1    -1.250e-01        NaN     NaN      NaN\nA1:B1:D1     1.500e+00        NaN     NaN      NaN\nA1:C1:D1     1.250e-01        NaN     NaN      NaN\nB1:C1:D1     1.045e-15        NaN     NaN      NaN\nA1:B1:C1:D1 -7.500e-01        NaN     NaN      NaN\n\nResidual standard error: NaN on 0 degrees of freedom\nMultiple R-squared:      1, Adjusted R-squared:    NaN \nF-statistic:   NaN on 15 and 0 DF,  p-value: NA\n\n\n\ncoef(fm2)[-1]*2\n\n           A1            B1            C1            D1         A1:B1 \n-2.000000e+00  6.750000e+00 -1.500000e+00 -9.250000e+00  1.250000e+00 \n        A1:C1         B1:C1         A1:D1         B1:D1         C1:D1 \n-2.190503e-15 -7.500000e-01  2.500000e-01  5.000000e-01 -5.250000e+00 \n     A1:B1:C1      A1:B1:D1      A1:C1:D1      B1:C1:D1   A1:B1:C1:D1 \n-2.500000e-01  3.000000e+00  2.500000e-01  2.090373e-15 -1.500000e+00 \n\n\n\nanova(fm2)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value Pr(&gt;F)\nA          1  16.00   16.00     NaN    NaN\nB          1 182.25  182.25     NaN    NaN\nC          1   9.00    9.00     NaN    NaN\nD          1 342.25  342.25     NaN    NaN\nA:B        1   6.25    6.25     NaN    NaN\nA:C        1   0.00    0.00     NaN    NaN\nB:C        1   2.25    2.25     NaN    NaN\nA:D        1   0.25    0.25     NaN    NaN\nB:D        1   1.00    1.00     NaN    NaN\nC:D        1 110.25  110.25     NaN    NaN\nA:B:C      1   0.25    0.25     NaN    NaN\nA:B:D      1  36.00   36.00     NaN    NaN\nA:C:D      1   0.25    0.25     NaN    NaN\nB:C:D      1   0.00    0.00     NaN    NaN\nA:B:C:D    1   9.00    9.00     NaN    NaN\nResiduals  0   0.00     NaN               \n\n\n\n\n5.2.2.2 3차 이상의 상호작용을 풀링\n이제 3차 이상의 상호적용을 풀링한 모형을 적합시키자.\n\nfm21 &lt;- lm (y~ A + B + C+ D+ A*B + A*C + A*D + B*C + B*D + C*D, data=df2) \nsummary(fm21)\n\n\nCall:\nlm.default(formula = y ~ A + B + C + D + A * B + A * C + A * \n    D + B * C + B * D + C * D, data = df2)\n\nResiduals:\n    1     2     3     4     5     6     7     8     9    10    11    12    13 \n-2.25  2.25  2.00 -2.00 -0.75  0.75  1.00 -1.00  2.50 -2.50 -2.25  2.25  0.50 \n   14    15    16 \n-0.50 -0.75  0.75 \n\nCoefficients:\n              Estimate Std. Error t value Pr(&gt;|t|)   \n(Intercept)  2.500e-01  7.542e-01   0.331  0.75371   \nA1          -1.000e+00  7.542e-01  -1.326  0.24219   \nB1           3.375e+00  7.542e-01   4.475  0.00655 **\nC1          -7.500e-01  7.542e-01  -0.994  0.36564   \nD1          -4.625e+00  7.542e-01  -6.133  0.00167 **\nA1:B1        6.250e-01  7.542e-01   0.829  0.44500   \nA1:C1       -1.352e-15  7.542e-01   0.000  1.00000   \nA1:D1        1.250e-01  7.542e-01   0.166  0.87485   \nB1:C1       -3.750e-01  7.542e-01  -0.497  0.64011   \nB1:D1        2.500e-01  7.542e-01   0.331  0.75371   \nC1:D1       -2.625e+00  7.542e-01  -3.481  0.01765 * \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 3.017 on 5 degrees of freedom\nMultiple R-squared:  0.9364,    Adjusted R-squared:  0.8091 \nF-statistic: 7.357 on 10 and 5 DF,  p-value: 0.01992\n\n\n\nanova(fm21)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value   Pr(&gt;F)   \nA          1  16.00   16.00  1.7582 0.242188   \nB          1 182.25  182.25 20.0275 0.006548 **\nC          1   9.00    9.00  0.9890 0.365645   \nD          1 342.25  342.25 37.6099 0.001674 **\nA:B        1   6.25    6.25  0.6868 0.444996   \nA:C        1   0.00    0.00  0.0000 1.000000   \nA:D        1   0.25    0.25  0.0275 0.874848   \nB:C        1   2.25    2.25  0.2473 0.640107   \nB:D        1   1.00    1.00  0.1099 0.753712   \nC:D        1 110.25  110.25 12.1154 0.017645 * \nResiduals  5  45.50    9.10                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n5.2.3 핵심 요인효과의 선별\n\nDanielPlot(fm2, half=TRUE)\n\n\n\n\n\n\n\n\n\nfm22 &lt;- lm (y~ A+B+C+D+ C*D, data=df2) \nsummary(fm22)\n\n\nCall:\nlm.default(formula = y ~ A + B + C + D + C * D, data = df2)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-3.625 -1.438  0.250  1.375  3.625 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   0.2500     0.5876   0.425 0.679529    \nA1           -1.0000     0.5876  -1.702 0.119634    \nB1            3.3750     0.5876   5.743 0.000187 ***\nC1           -0.7500     0.5876  -1.276 0.230691    \nD1           -4.6250     0.5876  -7.871 1.36e-05 ***\nC1:D1        -2.6250     0.5876  -4.467 0.001203 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 2.351 on 10 degrees of freedom\nMultiple R-squared:  0.9227,    Adjusted R-squared:  0.8841 \nF-statistic: 23.88 on 5 and 10 DF,  p-value: 2.925e-05\n\nanova(fm22)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nA          1  16.00   16.00  2.8959 0.1196341    \nB          1 182.25  182.25 32.9864 0.0001869 ***\nC          1   9.00    9.00  1.6290 0.2306913    \nD          1 342.25  342.25 61.9457 1.358e-05 ***\nC:D        1 110.25  110.25 19.9548 0.0012029 ** \nResiduals 10  55.25    5.53                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2수준 요인배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevels.html#반복이-있는-23-요인배치법",
    "href": "qmd/twolevels.html#반복이-있는-23-요인배치법",
    "title": "5  2수준 요인배치법",
    "section": "5.3 반복이 있는 \\(2^3\\) 요인배치법",
    "text": "5.3 반복이 있는 \\(2^3\\) 요인배치법\n이제 반복이 있는 \\(2^3\\) 요인배치법이 적용되는 예제에 대하여 논의합니다.\n자료는 (Montgomery 2017) 이 나온 예제 6.1 을 사용하였다. 반도체 공정에서 웨이퍼를 만드는 공정에서 다음과 같은 2개의 수준을 가진 3개의 요인과 반응변수을 고려한 실험을 실시하였다.\n\n요인 A: electrodes\n요인 B: the gas flow\n요인 C: RF power applied to the cathode\n반응변수 : etch rate for silicon nitride\n\n각 처리 조합마다 2개의 반복 측정값을 얻었다. 을 얻었다.\n\n5.3.1 처리조합 자료의 생성\n패키지 FrF2 에 있는 함수 FrF2()에서 replications=2를 지정하면 2개의 반복이 있는 \\(2^3\\) 요인배치법의 처리 조합을 생성해준다.\n이제 \\(2^3\\) 요인배치법의 처리 조합은 다음과 같이 만들 수 있다.\n\nX &lt;- FrF2(nruns=8, nfactors=3, randomize = FALSE, replications=2)\nX &lt;- as.data.frame(X)\nX\n\n    A  B  C Blocks\n1  -1 -1 -1     .1\n2   1 -1 -1     .1\n3  -1  1 -1     .1\n4   1  1 -1     .1\n5  -1 -1  1     .1\n6   1 -1  1     .1\n7  -1  1  1     .1\n8   1  1  1     .1\n9  -1 -1 -1     .2\n10  1 -1 -1     .2\n11 -1  1 -1     .2\n12  1  1 -1     .2\n13 -1 -1  1     .2\n14  1 -1  1     .2\n15 -1  1  1     .2\n16  1  1  1     .2\n\nX &lt;- X[,-4]  # 블럭변수가 필요없으모 제외\nX\n\n    A  B  C\n1  -1 -1 -1\n2   1 -1 -1\n3  -1  1 -1\n4   1  1 -1\n5  -1 -1  1\n6   1 -1  1\n7  -1  1  1\n8   1  1  1\n9  -1 -1 -1\n10  1 -1 -1\n11 -1  1 -1\n12  1  1 -1\n13 -1 -1  1\n14  1 -1  1\n15 -1  1  1\n16  1  1  1\n\n\n이제 반응값을 처리조합과 결합히여 실험자료를 만들어 보자.\n\ny &lt;- c(550, 669, 633, 642, 1037, 749, 1075, 729, 604, 650, 601, 635, 1052, 868, 1063, 860)\ndf3 &lt;- cbind(X,y)\ndf3 %&gt;%  kbl() %&gt;%   kable_paper(\"hover\", full_width = F)\n\n\n\n\n\nA\nB\nC\ny\n\n\n\n\n-1\n-1\n-1\n550\n\n\n1\n-1\n-1\n669\n\n\n-1\n1\n-1\n633\n\n\n1\n1\n-1\n642\n\n\n-1\n-1\n1\n1037\n\n\n1\n-1\n1\n749\n\n\n-1\n1\n1\n1075\n\n\n1\n1\n1\n729\n\n\n-1\n-1\n-1\n604\n\n\n1\n-1\n-1\n650\n\n\n-1\n1\n-1\n601\n\n\n1\n1\n-1\n635\n\n\n-1\n-1\n1\n1052\n\n\n1\n-1\n1\n868\n\n\n-1\n1\n1\n1063\n\n\n1\n1\n1\n860\n\n\n\n\n\n\n\n\n\n\n5.3.2 처리효과의 계산\n\n5.3.2.1 회귀식의 이용\n이제 회귀식을 적합시키자.\n\nfm3 &lt;- lm (y~ A*B*C, data=df3) \nsummary(fm3)\n\n\nCall:\nlm.default(formula = y ~ A * B * C, data = df3)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-65.50 -11.12   0.00  11.12  65.50 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  776.062     11.865  65.406 3.32e-12 ***\nA1           -50.813     11.865  -4.282 0.002679 ** \nB1             3.688     11.865   0.311 0.763911    \nC1           153.062     11.865  12.900 1.23e-06 ***\nA1:B1        -12.437     11.865  -1.048 0.325168    \nA1:C1        -76.813     11.865  -6.474 0.000193 ***\nB1:C1         -1.062     11.865  -0.090 0.930849    \nA1:B1:C1       2.812     11.865   0.237 0.818586    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 47.46 on 8 degrees of freedom\nMultiple R-squared:  0.9661,    Adjusted R-squared:  0.9364 \nF-statistic: 32.56 on 7 and 8 DF,  p-value: 2.896e-05\n\n\n위의 추정 결과는 16개의 관측값을 가지고 8개의 모수를 가진 모형을 적합하는 경우이므로 \\(\\sigma^2\\)을 추정할 수 있다.\n회귀식의 계수에 대한 추정치에서 절편을 제외한 추정치는 대응하는 효과 추정치의 절반인 것을 알 수 있다. 절편의 주정치는 전체 평균 \\(\\bar y\\)이다.\n\ncoef(fm3)[-1]*2\n\n      A1       B1       C1    A1:B1    A1:C1    B1:C1 A1:B1:C1 \n-101.625    7.375  306.125  -24.875 -153.625   -2.125    5.625 \n\n\n\n\n\n5.3.3 분산분석\n\nanova(fm3)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq  F value    Pr(&gt;F)    \nA          1  41311   41311  18.3394 0.0026786 ** \nB          1    218     218   0.0966 0.7639107    \nC          1 374850  374850 166.4105 1.233e-06 ***\nA:B        1   2475    2475   1.0988 0.3251679    \nA:C        1  94403   94403  41.9090 0.0001934 ***\nB:C        1     18      18   0.0080 0.9308486    \nA:B:C      1    127     127   0.0562 0.8185861    \nResiduals  8  18020    2253                       \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n위의 분산분석표에서 효과 \\(B \\times C\\), \\(A \\times B \\times C\\) 에 대한 제곱합의 크기가 다른 효과에 비하여 상대적으로 매우 작다.\n\n\n5.3.4 핵심 요인효과의 선별\n핵심요인 효과는 효과 추정치의 절대값 \\(| \\bar y_1 -\\bar y_0|\\) 들을 가지고 반정규확률 그림을 그려서 선별할 수 있다.\n반정규확률 그림은 패키지 FrF2에 있는 함수 DanielPlot() 를 사용하여 구할 수 있다.\n\nDanielPlot(fm3, half=TRUE)\n\n\n\n\n\n\n\n\n위의 반정규확률 그림을 보면 주요인 \\(A\\), \\(C\\) 와 상호작용 \\(A \\times C\\) 가 핵심 요인임을 알 수 있다.\n이제 핵심 요인으로 판단되는 주요인 \\(A\\), \\(C\\) 와 상호작용 \\(A \\times C\\) 만을 포함한 모형을 다시 적합해 보자.\n이제 회귀식을 적합시키자.\n\nfm31 &lt;- lm (y~ A+C+A*C, data=df3) \nsummary(fm31)\n\n\nCall:\nlm.default(formula = y ~ A + C + A * C, data = df3)\n\nResiduals:\n   Min     1Q Median     3Q    Max \n-72.50 -15.44   2.50  18.69  66.50 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)   776.06      10.42  74.458  &lt; 2e-16 ***\nA1            -50.81      10.42  -4.875 0.000382 ***\nC1            153.06      10.42  14.685 4.95e-09 ***\nA1:C1         -76.81      10.42  -7.370 8.62e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 41.69 on 12 degrees of freedom\nMultiple R-squared:  0.9608,    Adjusted R-squared:  0.9509 \nF-statistic: 97.91 on 3 and 12 DF,  p-value: 1.054e-08\n\nanova(fm31)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value    Pr(&gt;F)    \nA          1  41311   41311  23.767 0.0003816 ***\nC          1 374850  374850 215.661 4.951e-09 ***\nA:C        1  94403   94403  54.312 8.621e-06 ***\nResiduals 12  20858    1738                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\n\n\n\nMontgomery, Douglas C. 2017. Design and analysis of experiments. John wiley & sons.",
    "crumbs": [
      "<span class='chapter-number'>5</span>  <span class='chapter-title'>2수준 요인배치법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevelscomf.html",
    "href": "qmd/twolevelscomf.html",
    "title": "6  2수준 요인배치법 - 교락법",
    "section": "",
    "text": "6.1 교과서 예제 8.2\n반복이 없는 \\(2^4\\) 요인배치법에서 16회의 실험을 동일한 환경에서 실시할 수 없어서 상호작용효과 \\(ACD\\) 와 \\(BCD\\) 를 블럭과 교락시켜서 실험하였다 (교과서 예제 8.2, 230 페이지)",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>2수준 요인배치법 - 교락법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevelscomf.html#교과서-예제-8.2",
    "href": "qmd/twolevelscomf.html#교과서-예제-8.2",
    "title": "6  2수준 요인배치법 - 교락법",
    "section": "",
    "text": "6.1.1 실험자료의 생성\n먼저 16개의 실험 처리 조합을 표준 순서로서 생성하자. default.level=c(0,1) 은 요인의 수준을 0과 1로 표시하는 옵션이다.\n\nX &lt;- FrF2(nruns=16, nfactors=4, randomize = FALSE,  default.level=c(0,1))\nX\n\n   A B C D\n1  0 0 0 0\n2  1 0 0 0\n3  0 1 0 0\n4  1 1 0 0\n5  0 0 1 0\n6  1 0 1 0\n7  0 1 1 0\n8  1 1 1 0\n9  0 0 0 1\n10 1 0 0 1\n11 0 1 0 1\n12 1 1 0 1\n13 0 0 1 1\n14 1 0 1 1\n15 0 1 1 1\n16 1 1 1 1\nclass=design, type= full factorial \n\n\n실험의 표준 순서는 다음과 같이 yates() 함수를 이용하여 알 수 있다.\n\nyates(rep(0,16))\n\n   A    B   AB    C   AC   BC  ABC    D   AD   BD  ABD   CD  ACD  BCD ABCD \n   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0 \nattr(,\"mean\")\n  \n0 \n\n\n그리고 처리의 표준 순서로 실험값과 블럭변수를 입력한다. 그리고 처리조합 정보 X 와 결합하여 최종 자료인 df 를 만들자.\n\n\n\n\n\n예제 8.2 자료\n\n\n\n\n\ny &lt;- c(45,71, 48, 65, 68, 60, 80, 65, 43, 100, 45, 104, 75, 86, 70, 96 )\nblock &lt;- factor(c(1, 3, 2, 4, 4, 2, 3, 1, 4, 2, 3, 1, 1, 3, 2, 4))\ntreat &lt;- c(\"0\", names(yates(rep(0,16))))\ndf0 &lt;- data.frame(block=block, treat=treat,  y=y )\ndf &lt;- cbind(X, df0)\n\n\ndf %&gt;%  kbl() %&gt;%   kable_paper(\"hover\", full_width = F)\n\n\n\n\n\nA\nB\nC\nD\nblock\ntreat\ny\n\n\n\n\n0\n0\n0\n0\n1\n0\n45\n\n\n1\n0\n0\n0\n3\nA\n71\n\n\n0\n1\n0\n0\n2\nB\n48\n\n\n1\n1\n0\n0\n4\nAB\n65\n\n\n0\n0\n1\n0\n4\nC\n68\n\n\n1\n0\n1\n0\n2\nAC\n60\n\n\n0\n1\n1\n0\n3\nBC\n80\n\n\n1\n1\n1\n0\n1\nABC\n65\n\n\n0\n0\n0\n1\n4\nD\n43\n\n\n1\n0\n0\n1\n2\nAD\n100\n\n\n0\n1\n0\n1\n3\nBD\n45\n\n\n1\n1\n0\n1\n1\nABD\n104\n\n\n0\n0\n1\n1\n1\nCD\n75\n\n\n1\n0\n1\n1\n3\nACD\n86\n\n\n0\n1\n1\n1\n2\nBCD\n70\n\n\n1\n1\n1\n1\n4\nABCD\n96\n\n\n\n\n\n\n\n\n위의 실험 자료를 블럭과 처리 순으로 정렬해 보자.\n\ndf %&gt;% arrange( block, treat)\n\n   A B C D block treat   y\n1  0 0 0 0     1     0  45\n2  1 1 1 0     1   ABC  65\n3  1 1 0 1     1   ABD 104\n4  0 0 1 1     1    CD  75\n5  1 0 1 0     2    AC  60\n6  1 0 0 1     2    AD 100\n7  0 1 0 0     2     B  48\n8  0 1 1 1     2   BCD  70\n9  1 0 0 0     3     A  71\n10 1 0 1 1     3   ACD  86\n11 0 1 1 0     3    BC  80\n12 0 1 0 1     3    BD  45\n13 1 1 0 0     4    AB  65\n14 1 1 1 1     4  ABCD  96\n15 0 0 1 0     4     C  68\n16 0 0 0 1     4     D  43\n\n\n\n\n6.1.2 선형표현식\n이제 위에서 생성된 자료에서 상호작용효과 \\(ACD\\) 와 \\(BCD\\) 가 블록과 교락되어 있는지 선형표현식을 이용하여 확인해 보자.\n\\[\n\\begin{aligned}\nL_1 & = x_1 + x_3 + x_4 (\\text{mod}2) \\\\\nL_2 & = x_2 + x_3 + x_4 (\\text{mod}2)\n\\end{aligned}\n\\]\n예를 들어 블럭 1 (\\(L_1=0, L_2=0\\)) 에 베치된 처리에 대하여 선형식의 값을 구해보자.\n\n\n\n\n\n\n\n\n\n블럭\n처리\n\\(L_1 (ACD)\\)\n\\(L_2 (BCD)\\)\n\n\n\n\n1\n\\((0)\\)\n\\(\\texttt{MOD} (0+0+0, 2) = 0\\)\n\\(\\texttt{MOD} (0+0+0, 2) = 0\\)\n\n\n1\n\\(ABC\\)\n\\(\\texttt{MOD} (1+1+0, 2) = 0\\)\n\\(\\texttt{MOD} (1+1+0, 2) = 0\\)\n\n\n1\n\\(ABD\\)\n\\(\\texttt{MOD} (1+0+1, 2) = 0\\)\n\\(\\texttt{MOD} (1+0+1, 2) = 0\\)\n\n\n1\n\\(CD\\)\n\\(\\texttt{MOD} (0+1+1, 2) = 0\\)\n\\(\\texttt{MOD} (0+1+1, 2) = 0\\)\n\n\n\n예를 들어 블럭 2 (\\(L_1=0, L_2=1\\)) 에 베치된 처리에 대하여 선형식의 값을 구해보자.\n\n\n\n\n\n\n\n\n\n블럭\n처리\n\\(L_1 (ACD)\\)\n\\(L_2 (BCD)\\)\n\n\n\n\n2\n\\(AC\\)\n\\(\\texttt{MOD} (1+1+0, 2) = 0\\)\n\\(\\texttt{MOD} (0+1+0, 2) = 1\\)\n\n\n2\n\\(AD\\)\n\\(\\texttt{MOD} (1+0+1, 2) = 0\\)\n\\(\\texttt{MOD} (0+0+1, 2) = 1\\)\n\n\n2\n\\(B\\)\n\\(\\texttt{MOD} (0+0+0, 2) = 0\\)\n\\(\\texttt{MOD} (1+0+0, 2) = 1\\)\n\n\n2\n\\(BCD\\)\n\\(\\texttt{MOD} (0+1+1, 2) = 0\\)\n\\(\\texttt{MOD} (1+1+1, 2) = 1\\)\n\n\n\n이렇게 모든 처리에 대하여 구한 선형식의 값은 다음과 같이 함수 conf.design() 로 구할 수 있다. 아래 주어진 블럭배치의 결과는 자료 df 에서 처리들이 블럭에 배치된 것과 일치함을 확인할 수 있다.\n먼저 상호작용효과 \\(ACD\\) 와 \\(BCD\\) 가 블록과 교락되도록 정의할 수 있는 행렬을 만들어 보자. 아래 0 과 1 로 구성된 \\(4 \\times 2\\) 행렬을 보면, 먼저 4개의 인자를 나타내는 4개의 열로 구성되어 있으며 각 행은 블록과 교락된 상호작용효과에 해당되는 요인을 1로 표시한 것이다. 따라서 첫 행은 \\(ACD\\) 에 해당되는 요인들을 1로 표시하고 나머지 행은 \\(BCD\\) 에 해당되는 요인들을 1로 표시한 것이다.\n\n\n\nA\nB\nC\nD\n\n\n\n\n1\n0\n1\n1\n\n\n0\n1\n1\n1\n\n\n\n\nDef.contrast &lt;-   matrix(c(1,0,1,1, 0,1,1,1), 2,4, byrow=TRUE)\nDef.contrast\n\n     [,1] [,2] [,3] [,4]\n[1,]    1    0    1    1\n[2,]    0    1    1    1\n\n\n다음으로 위에서 정의한 행렬을 이용하여 상호작용효과 \\(ACD\\) 와 \\(BCD\\) 가 블록과 교락되도록 실험을 설계해 보자. 아래 함수 conf.design() 를 사용하는 경우 인자들의 역활은 다음과 같다.\n\nG : 상호작용효과를 정의하는 행렬\np : 실험의 수준\nblock.name : 블럭의 이름\ntreatment.names : 처리의 이름\n\n\ndf2 &lt;- conf.design(G=Def.contrast , p=2, block.name = \"블럭\", treatment.names=c(\"A\", \"B\", \"C\", \"D\"))\ndf2\n\n   블럭 A B C D\n1    00 0 0 0 0\n2    00 1 1 1 0\n3    00 1 1 0 1\n4    00 0 0 1 1\n5    01 0 1 0 0\n6    01 1 0 1 0\n7    01 1 0 0 1\n8    01 0 1 1 1\n9    10 1 0 0 0\n10   10 0 1 1 0\n11   10 0 1 0 1\n12   10 1 0 1 1\n13   11 1 1 0 0\n14   11 0 0 1 0\n15   11 0 0 0 1\n16   11 1 1 1 1\n\n\n아래 함수 conf.design() 의 결과 df2 는 앞에서 만든 실험자료 df 와 처리와 블럭의배정이 일치하는 것을 확인할 수 있다.\n\n\n6.1.3 결합요인\n상호작용효과 \\(ACD\\) 와 \\(BCD\\) 가 블록과 교락되어 있을 경우 발생하는 결합요인은 \\(AB\\) 이다. 따라서 상호작용효과 \\(AD\\) 도 블록 효과와 교락된다.\n\\[ ACD \\times BCD = ABC^2 D^2= AB \\]\n\n\n6.1.4 Yates 계산법\n이제 자료 df 에 함수 yates() 를 다음과 같이 적용하여 각 효과의 추정치(effect)를 게산해 보자. 참고로 attr(a, \"mean\") 는 Yates 추정치가 저장된 a 에서 반응값의 전체 평균 \\(\\bar y_{....}\\) 을 구하는 함수이다.\n\na &lt;- yates(df$y, c(\"A\", \"B\", \"C\", \"D\"))\na\n\n      A       B      AB       C      AC      BC     ABC       D      AD      BD \n 21.625   3.125   0.125   9.875 -18.125   2.375   1.875  14.625  16.625  -0.375 \n    ABD      CD     ACD     BCD    ABCD \n  4.125  -1.125  -1.625  -2.625   1.375 \nattr(,\"mean\")\n        \n70.0625 \n\nattr(a, \"mean\")\n\n        \n70.0625 \n\n\n이제 위의 결과를 이용하여 교과서 표 8.4 와 동일한 Yates 계산의 결과를 구해보자.\n\nyates_effect &lt;- data.frame(treat = names(a), effect= a)\nyates_effect\n\n     treat  effect\nA        A  21.625\nB        B   3.125\nAB      AB   0.125\nC        C   9.875\nAC      AC -18.125\nBC      BC   2.375\nABC    ABC   1.875\nD        D  14.625\nAD      AD  16.625\nBD      BD  -0.375\nABD    ABD   4.125\nCD      CD  -1.125\nACD    ACD  -1.625\nBCD    BCD  -2.625\nABCD  ABCD   1.375\n\ntotalmean &lt;-  data.frame(treat=\"(0)\", effect = attr(a, \"mean\"))\ntotalmean \n\n  treat  effect\n1   (0) 70.0625\n\nyates_effect &lt;- rbind(totalmean, yates_effect)\nyates_effect\n\n     treat   effect\n1      (0)  70.0625\nA        A  21.6250\nB        B   3.1250\nAB      AB   0.1250\nC        C   9.8750\nAC      AC -18.1250\nBC      BC   2.3750\nABC    ABC   1.8750\nD        D  14.6250\nAD      AD  16.6250\nBD      BD  -0.3750\nABD    ABD   4.1250\nCD      CD  -1.1250\nACD    ACD  -1.6250\nBCD    BCD  -2.6250\nABCD  ABCD   1.3750\n\n\n위에서 구한 데이터프레임의 effect 는 평균 효과를 의미한다. 예를 들어서 처리 \\(A\\) 에 대한 효과는 다음과 같이 구한다.\n\\[\n\\begin{aligned}\nA & = \\frac{1}{8} (a + ab + ac + abc + ad + abd + acd + abcd - (0) - b -c -bc -d - bd - cd -bcd) \\\\\n  & =\\frac{1}{8} (T_{1...} - T_{0...}) \\\\\n  & = \\bar {y}_{1...} - \\bar {y}_{0...} \\\\\n  & = 21.625\n\\end{aligned}  \n\\]\n따라서 제곱합을 구하는 방법은 처리합의 차를 제곱한 값 \\((T_{1...} - T_{0...})^2\\) 을 총 실험의 크기 \\(n=16\\) 으로 나눈다. 이는 평균처리 효과를 제곱한 값에 4를 곱해주는 양과 같다.\n\\[ SS_A =  \\frac{(T_{1...} - T_{0...})^2}{16} = 4 (\\bar {y}_{1...} - \\bar {y}_{0...})^2  \\]\n이제 위에서 구한 평균 처리 효과를 이용하여 제곱합을 구해보자. 주의할 점은 평균 처리 효과가 저장된 yates_effect 의 첫 행은 전체평균 \\(\\bar y_{....} = T_{....}/16\\) 이 저장되어 있기 때문에 4를 한번 더 곱해주어야 한다.\n\\[ CT = \\frac{T_{....}^2}{16} = 16 (\\bar y_{....})^2\\]\n\nyates_effect$SS &lt;- 4*yates_effect$effect^2\nyates_effect$SS[1] &lt;- yates_effect$SS[1] *4\nyates_effect\n\n     treat   effect         SS\n1      (0)  70.0625 78540.0625\nA        A  21.6250  1870.5625\nB        B   3.1250    39.0625\nAB      AB   0.1250     0.0625\nC        C   9.8750   390.0625\nAC      AC -18.1250  1314.0625\nBC      BC   2.3750    22.5625\nABC    ABC   1.8750    14.0625\nD        D  14.6250   855.5625\nAD      AD  16.6250  1105.5625\nBD      BD  -0.3750     0.5625\nABD    ABD   4.1250    68.0625\nCD      CD  -1.1250     5.0625\nACD    ACD  -1.6250    10.5625\nBCD    BCD  -2.6250    27.5625\nABCD  ABCD   1.3750     7.5625\n\n\n\n\n\n\n\n예제 8.2 Yates 계산\n\n\n\n\n\n\n6.1.5 블럭변동\n자료에서 블럭의 변동을 구하는 방법은 교과서 231 에 나온 것처럼 각 블럭에 대한 관측값의 합을 구해서 변동의 공식을 이용할 수 있다. 각 블럭 안의 관측값들 합을 \\(T_i\\)라고 하면\n\\[ SS_{block} = \\frac{1}{4} \\sum_{i=1}^4  T^2_i - CT \\quad \\text{where } CT=\\frac {T^2}{(4)(4)}  \\]\n\n\n\n\n\n예제 8.2 블럭 제곱합\n\n\n\n\n또한 다음과 같은 선형식을 R 록 적합식키고 분산분석을 이용하여 블럭의 변동(\\(SS_{block}\\))을 구할 수 있다. 아래 함수\nanova() 결과에 의하면 \\(SS_{block} = 38.19\\) 이다.\n\\[ y_{ij} = \\mu + \\text{(block)}_i + e_{ij} \\]\n\nres_block &lt;- lm(y~block, data=df)\nanova(res_block)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df Sum Sq Mean Sq F value Pr(&gt;F)\nblock      3   38.2   12.73  0.0268 0.9937\nResiduals 12 5692.8  474.40               \n\n\n블럭의 변동은 상호작용 효과 \\(ACD\\), \\(BCD\\), \\(AB\\) 에 대한 제곱합들의 합과 같다.\n\\[ SS_{block} = SS_{ACD} + SS_{BCD} + SS_{AB} = 10.5625 +  27.5625 +0.0625 = 38.19 \\]\n\nyates_effect %&gt;% filter(treat == \"ACD\" | treat == \"BCD\" | treat == \"AB\")\n\n    treat effect      SS\nAB     AB  0.125  0.0625\nACD   ACD -1.625 10.5625\nBCD   BCD -2.625 27.5625\n\n\n\n\n6.1.6 핵심요인의 선별\n핵심요인의 선별하기 위하여 먼저 각 처리의 제곱합을 순서대로 나열해 보자. 주요인 \\(A\\), \\(C\\), \\(D\\) 와 상호작용 효과 \\(AC\\) 와 \\(AD\\)의 제곱합이 다른 것보다 크게 나타나는 것을 볼 수 있다.\n\nyates_effect %&gt;%  arrange(desc(SS))\n\n     treat   effect         SS\n1      (0)  70.0625 78540.0625\nA        A  21.6250  1870.5625\nAC      AC -18.1250  1314.0625\nAD      AD  16.6250  1105.5625\nD        D  14.6250   855.5625\nC        C   9.8750   390.0625\nABD    ABD   4.1250    68.0625\nB        B   3.1250    39.0625\nBCD    BCD  -2.6250    27.5625\nBC      BC   2.3750    22.5625\nABC    ABC   1.8750    14.0625\nACD    ACD  -1.6250    10.5625\nABCD  ABCD   1.3750     7.5625\nCD      CD  -1.1250     5.0625\nBD      BD  -0.3750     0.5625\nAB      AB   0.1250     0.0625\n\n\n이제 모든 효과가 포함된 완전모형(full model)을 적합시키고 반정규확률 그림을 그려서 핵심효인을 다시 찾아보자. 제곱합을 비교할 때와 같이 주요인 \\(A\\), \\(C\\), \\(D\\) 와 상호작용 효과 \\(AC\\) 와 \\(AD\\)이 핵심 요인으로 보여진다.\n\nfullmodel &lt;- lm (y~ A*B*C*D, data=df) \nDanielPlot(fullmodel, half=TRUE)\n\n\n\n\n\n\n\n\n\n\n6.1.7 최종 모형\n위의 핵심요인의 선별 결과를 고려하여 주요인 \\(A\\), \\(B\\), \\(C\\), \\(D\\) 와 상호작용 효과 \\(AC\\) 와 \\(AD\\) 를 포함하는 축소된 모형을 최종모형으로 적합해 보자. 축소모형에는 당연히 블럭효과도 포함해야 한다. 또한 오차항에는 블럭과 교럭돤 상호작용 효과들과 축소모형에 포함된 효과들을 제외한 다른 효과들이 풀링된다.\n\\[ SS_E = SS_{B \\times C} + SS_{B \\times D} + SS_{C \\times D} + SS_{A \\times B \\times C} + SS_{A \\times B \\times D } + SS_{A \\times B \\times C \\times D}\\]\n\nfinalmodel &lt;- lm(y ~ block + A +B + C+ D + A:C + A:D, data=df)\nanova(finalmodel)\n\nAnalysis of Variance Table\n\nResponse: y\n          Df  Sum Sq Mean Sq F value    Pr(&gt;F)    \nblock      3   38.19   12.73  0.6479 0.6123498    \nA          1 1870.56 1870.56 95.2142  6.66e-05 ***\nB          1   39.06   39.06  1.9883 0.2081893    \nC          1  390.06  390.06 19.8547 0.0043020 ** \nD          1  855.56  855.56 43.5493 0.0005821 ***\nA:C        1 1314.06 1314.06 66.8876 0.0001800 ***\nA:D        1 1105.56 1105.56 56.2747 0.0002902 ***\nResiduals  6  117.88   19.65                      \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>2수준 요인배치법 - 교락법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevelscomf.html#상호작용-그림",
    "href": "qmd/twolevelscomf.html#상호작용-그림",
    "title": "6  2수준 요인배치법 - 교락법",
    "section": "6.2 상호작용 그림",
    "text": "6.2 상호작용 그림\n\nwith(df, interaction.plot(x.factor = A, trace.factor = C,  response = y))\n\n\n\n\n\n\n\n\n\nwith(df, interaction.plot(x.factor = A, trace.factor = D,  response = y))",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>2수준 요인배치법 - 교락법</span>"
    ]
  },
  {
    "objectID": "qmd/twolevelscomf.html#exerxise8",
    "href": "qmd/twolevelscomf.html#exerxise8",
    "title": "6  2수준 요인배치법 - 교락법",
    "section": "6.3 8장 연습문제",
    "text": "6.3 8장 연습문제\n다음은 8장의 연습문제를 풀 때 도음이 되는 R 프로그램이다.\n\n6.3.1 연습문제 1\n\nX1 &lt;- FrF2(nruns=16, nfactors=4, randomize = FALSE,  default.level=c(0,1))\nX1\n\n   A B C D\n1  0 0 0 0\n2  1 0 0 0\n3  0 1 0 0\n4  1 1 0 0\n5  0 0 1 0\n6  1 0 1 0\n7  0 1 1 0\n8  1 1 1 0\n9  0 0 0 1\n10 1 0 0 1\n11 0 1 0 1\n12 1 1 0 1\n13 0 0 1 1\n14 1 0 1 1\n15 0 1 1 1\n16 1 1 1 1\nclass=design, type= full factorial \n\nyates(rep(0,16))\n\n   A    B   AB    C   AC   BC  ABC    D   AD   BD  ABD   CD  ACD  BCD ABCD \n   0    0    0    0    0    0    0    0    0    0    0    0    0    0    0 \nattr(,\"mean\")\n  \n0 \n\nDef.contrast1 &lt;- c(1,1,1,1)\nconf.design(G=Def.contrast1 , p=2, block.name = \"블럭\", treatment.names=c(\"A\", \"B\", \"C\", \"D\"))\n\n   블럭 A B C D\n1     0 0 0 0 0\n2     0 1 1 0 0\n3     0 1 0 1 0\n4     0 0 1 1 0\n5     0 1 0 0 1\n6     0 0 1 0 1\n7     0 0 0 1 1\n8     0 1 1 1 1\n9     1 1 0 0 0\n10    1 0 1 0 0\n11    1 0 0 1 0\n12    1 1 1 1 0\n13    1 0 0 0 1\n14    1 1 1 0 1\n15    1 1 0 1 1\n16    1 0 1 1 1\n\n\n\n\n6.3.2 연습문제 4\n\nX2 &lt;- FrF2(nruns=8, nfactors=3, randomize = FALSE,  default.level=c(0,1))\nX2\n\n  A B C\n1 0 0 0\n2 1 0 0\n3 0 1 0\n4 1 1 0\n5 0 0 1\n6 1 0 1\n7 0 1 1\n8 1 1 1\nclass=design, type= full factorial \n\nyates(rep(0,8))\n\n  A   B  AB   C  AC  BC ABC \n  0   0   0   0   0   0   0 \nattr(,\"mean\")\n  \n0 \n\nDef.contrast2 &lt;- c(1,1,1)\nconf.design(G=Def.contrast2 , p=2, block.name = \"블럭\", treatment.names=c(\"A\", \"B\", \"C\"))\n\n  블럭 A B C\n1    0 0 0 0\n2    0 1 1 0\n3    0 1 0 1\n4    0 0 1 1\n5    1 1 0 0\n6    1 0 1 0\n7    1 0 0 1\n8    1 1 1 1\n\n\n\n\n6.3.3 연습문제 10\n\nX3 &lt;- FrF2(nruns=64, nfactors=6, randomize = FALSE,  default.level=c(0,1))\nX3\n\n   A B C D E F\n1  0 0 0 0 0 0\n2  1 0 0 0 0 0\n3  0 1 0 0 0 0\n4  1 1 0 0 0 0\n5  0 0 1 0 0 0\n6  1 0 1 0 0 0\n7  0 1 1 0 0 0\n8  1 1 1 0 0 0\n9  0 0 0 1 0 0\n10 1 0 0 1 0 0\n11 0 1 0 1 0 0\n12 1 1 0 1 0 0\n13 0 0 1 1 0 0\n14 1 0 1 1 0 0\n15 0 1 1 1 0 0\n16 1 1 1 1 0 0\n17 0 0 0 0 1 0\n18 1 0 0 0 1 0\n19 0 1 0 0 1 0\n20 1 1 0 0 1 0\n21 0 0 1 0 1 0\n22 1 0 1 0 1 0\n23 0 1 1 0 1 0\n24 1 1 1 0 1 0\n25 0 0 0 1 1 0\n26 1 0 0 1 1 0\n27 0 1 0 1 1 0\n28 1 1 0 1 1 0\n29 0 0 1 1 1 0\n30 1 0 1 1 1 0\n31 0 1 1 1 1 0\n32 1 1 1 1 1 0\n33 0 0 0 0 0 1\n34 1 0 0 0 0 1\n35 0 1 0 0 0 1\n36 1 1 0 0 0 1\n37 0 0 1 0 0 1\n38 1 0 1 0 0 1\n39 0 1 1 0 0 1\n40 1 1 1 0 0 1\n41 0 0 0 1 0 1\n42 1 0 0 1 0 1\n43 0 1 0 1 0 1\n44 1 1 0 1 0 1\n45 0 0 1 1 0 1\n46 1 0 1 1 0 1\n47 0 1 1 1 0 1\n48 1 1 1 1 0 1\n49 0 0 0 0 1 1\n50 1 0 0 0 1 1\n51 0 1 0 0 1 1\n52 1 1 0 0 1 1\n53 0 0 1 0 1 1\n54 1 0 1 0 1 1\n55 0 1 1 0 1 1\n56 1 1 1 0 1 1\n57 0 0 0 1 1 1\n58 1 0 0 1 1 1\n59 0 1 0 1 1 1\n60 1 1 0 1 1 1\n61 0 0 1 1 1 1\n62 1 0 1 1 1 1\n63 0 1 1 1 1 1\n64 1 1 1 1 1 1\nclass=design, type= full factorial \n\nyates(rep(0,64))\n\n     A      B     AB      C     AC     BC    ABC      D     AD     BD    ABD \n     0      0      0      0      0      0      0      0      0      0      0 \n    CD    ACD    BCD   ABCD      E     AE     BE    ABE     CE    ACE    BCE \n     0      0      0      0      0      0      0      0      0      0      0 \n  ABCE     DE    ADE    BDE   ABDE    CDE   ACDE   BCDE  ABCDE      F     AF \n     0      0      0      0      0      0      0      0      0      0      0 \n    BF    ABF     CF    ACF    BCF   ABCF     DF    ADF    BDF   ABDF    CDF \n     0      0      0      0      0      0      0      0      0      0      0 \n  ACDF   BCDF  ABCDF     EF    AEF    BEF   ABEF    CEF   ACEF   BCEF  ABCEF \n     0      0      0      0      0      0      0      0      0      0      0 \n   DEF   ADEF   BDEF  ABDEF   CDEF  ACDEF  BCDEF ABCDEF \n     0      0      0      0      0      0      0      0 \nattr(,\"mean\")\n  \n0 \n\nDef.contrast3 &lt;-   matrix(c(1,1,1,1,0,0, 1,1,0,0,1,1), 2,6, byrow=TRUE)\nconf.design(G=Def.contrast3 , p=2, block.name = \"블럭\", treatment.names=c(\"A\", \"B\", \"C\", \"D\", \"E\", \"F\"))\n\n   블럭 A B C D E F\n1    00 0 0 0 0 0 0\n2    00 1 1 0 0 0 0\n3    00 0 0 1 1 0 0\n4    00 1 1 1 1 0 0\n5    00 1 0 1 0 1 0\n6    00 0 1 1 0 1 0\n7    00 1 0 0 1 1 0\n8    00 0 1 0 1 1 0\n9    00 1 0 1 0 0 1\n10   00 0 1 1 0 0 1\n11   00 1 0 0 1 0 1\n12   00 0 1 0 1 0 1\n13   00 0 0 0 0 1 1\n14   00 1 1 0 0 1 1\n15   00 0 0 1 1 1 1\n16   00 1 1 1 1 1 1\n17   01 1 0 1 0 0 0\n18   01 0 1 1 0 0 0\n19   01 1 0 0 1 0 0\n20   01 0 1 0 1 0 0\n21   01 0 0 0 0 1 0\n22   01 1 1 0 0 1 0\n23   01 0 0 1 1 1 0\n24   01 1 1 1 1 1 0\n25   01 0 0 0 0 0 1\n26   01 1 1 0 0 0 1\n27   01 0 0 1 1 0 1\n28   01 1 1 1 1 0 1\n29   01 1 0 1 0 1 1\n30   01 0 1 1 0 1 1\n31   01 1 0 0 1 1 1\n32   01 0 1 0 1 1 1\n33   10 0 0 1 0 0 0\n34   10 1 1 1 0 0 0\n35   10 0 0 0 1 0 0\n36   10 1 1 0 1 0 0\n37   10 1 0 0 0 1 0\n38   10 0 1 0 0 1 0\n39   10 1 0 1 1 1 0\n40   10 0 1 1 1 1 0\n41   10 1 0 0 0 0 1\n42   10 0 1 0 0 0 1\n43   10 1 0 1 1 0 1\n44   10 0 1 1 1 0 1\n45   10 0 0 1 0 1 1\n46   10 1 1 1 0 1 1\n47   10 0 0 0 1 1 1\n48   10 1 1 0 1 1 1\n49   11 1 0 0 0 0 0\n50   11 0 1 0 0 0 0\n51   11 1 0 1 1 0 0\n52   11 0 1 1 1 0 0\n53   11 0 0 1 0 1 0\n54   11 1 1 1 0 1 0\n55   11 0 0 0 1 1 0\n56   11 1 1 0 1 1 0\n57   11 0 0 1 0 0 1\n58   11 1 1 1 0 0 1\n59   11 0 0 0 1 0 1\n60   11 1 1 0 1 0 1\n61   11 1 0 0 0 1 1\n62   11 0 1 0 0 1 1\n63   11 1 0 1 1 1 1\n64   11 0 1 1 1 1 1",
    "crumbs": [
      "<span class='chapter-number'>6</span>  <span class='chapter-title'>2수준 요인배치법 - 교락법</span>"
    ]
  },
  {
    "objectID": "qmd/response.html",
    "href": "qmd/response.html",
    "title": "7  반응표면 분석",
    "section": "",
    "text": "7.1 반응표면 분석 개요",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#sec-response-intro",
    "href": "qmd/response.html#sec-response-intro",
    "title": "7  반응표면 분석",
    "section": "",
    "text": "7.1.1 실험계획의 절차\n\n요인배치법의 실험 자료의 분석은 실험조건인 처리에서의 모평균 비교.\n분산분석을 통하여 유의한 요인효과들을 선별\n각 처리에서 예측치 구하기.\n실험에서 고려된 처리조건들 중에서 모평균의 값을 최적으로 하는 실험조건 찾기 및 재현성 검토\n\n\n\n7.1.2 반응표면분석의 목적\n반응표면분석(response surface method)에서는 관심영역에 속한 임의의 계량인자(quantatitative factor)들의 값에서 수율(반응변수)의 예측이 실험 목적이다.\n일단 반응표변분석에서는 두 개의 계량인자 \\(x_1\\), \\(x_2\\) 와 반응변수 \\(y\\) 의 모평균 \\(\\eta =E(y)\\)이 다음과 같은 함수관계를 가진다고 가정한다.\n\\[ \\eta = f(x_1, x_2) \\]\n위의 관계에서 함수 \\(f(x_1, x_2)\\)는 모르는 함수이다.\n반응표면분석의 목적은 반응변수의 모평균 \\(\\eta\\)의 최대값 \\(\\eta^*\\) 가 나타나는 계량인자의 수준 \\(x_1^*\\) 와 \\(x_2^*\\) 를 주어진 영역에서 찾는 것이다.\n\\[\\eta^* = \\max_{x_1, x_2} f(x_1, x_2) =f(x_1^*, x_2^*) \\]\n함수 \\(f(x_1, x_2)\\)는 복잡한 형태를 가질 수 있지만 반응표변분석에서는 최대값의 주위에서 함수 \\(f(x_1, x_2)\\)를 이차함수로 근사하여 최적점을 찾는다.\n\n\n\n\n\n이차함수 근사 (Montgomery 2017)\n\n\n\n\n\n\n7.1.3 반응표면분석의 절차\n\n반응값을 나타내는 변수를 반응변수로, 계량인자를 설명변수로 간주하여 실험 자료를 이용하여 회귀분석을 실시.\n\n관심영역의 최적조건 근처에서 곡선효과 존재\n곡선효과를 반영하는 가장 간결한 모형인 이차 다항모형 가정\n적절한 모형 찾기.\n\n예측치를 최적으로 하는 최적조건을 관심영역에서 찾고, 최적조건에서의 재현성 검토하기.\n반응표면분석의 절차는 다음과 같이 크게 3단계로 구성된다.\n\n2수준 일부실시법에 의해서 핵심인자들을 선별하기.\n선별된 핵심인자들에 대한 축차적인 실험 설계(중심점을 갖는 2수준 요인 배치법)와 분석에 의해서 최적조건 근처의 설명변수들의 영역 으로 이동하기. (최대경사법 적용)\n\n\n\\[ y = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\dots + \\beta_p x_p + e \\]\n\n최적조건 근처에서 2차 모형을 가정, ccd(중심합성설계)에 의한 실험설계 및 실험자료의 회귀분석을 통한 적절한 모형 찾기 및 최적조 건 찾기와 재현성 검토.\n\n\\[  y = \\beta_0 + \\sum_{i=1}^k \\beta_i x_i + \\sum_{i=1}^k \\beta_{ii} x^2_i + \\underset{i&lt;j}{\\sum \\sum} \\beta_{ij} x_i x_j + e \\]\n\n\n\n\n\n반응표면분석의 순차적인 특성 (Montgomery 2017)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#steepdescent",
    "href": "qmd/response.html#steepdescent",
    "title": "7  반응표면 분석",
    "section": "7.2 최대경사법",
    "text": "7.2 최대경사법\n\n7.2.1 개요\n\n초기 실험에서는 실험에서 고려하는 계량인자들의 관심 영역이 반응변수의 최적값을 가지는 영역에서 멀리 떨어져 있는 경우가 흔하다.\n따라서 초기 실험에서는 최적의 영역으로 이동하기 위한 계량인자들의 방향을 알아내는 것이 중요하다.\n간단한 초기 실험의 결과를 이용하여 계량인자들의 값을 최적점 근처로 순차적으로 이동시킬 수 있는 쉽고 경제적인 절차가 필요하다.\n주어진 선형모형에서 계량인자들의 값을 이동시킬 수 있는 간단한 방법들 중의 하나는 최대경사법(method of steepest ascent) 이다.\n\n\n\n7.2.2 9.2절 자료와 변환\n교과서 9.2 절에 나오는 실험 자료를 고려해 보자. 화학공장에서 공정의 수율(\\(y\\))을 최적화하는 공정조건을 찾는 실험자가 관심이 있는 시간(\\(x_1\\), time)의 범위는 30-40분 이고 온도(\\(x_2\\), temp)의 범위는 160-180도 라고 하자. 이제 주어진 시간과 온도에 따라서 실험을 7번 수행하였으며 결과 자료는 다음과 같다.\n\ntime &lt;- c(30,30,40,40,35,35,35)\ntemp &lt;- c(160, 180, 160, 180, 170, 170, 170)\ny &lt;- c(72.5, 74.2, 76.3, 77.0, 74.8, 75.6, 75.2)\ndf1 &lt;- data.frame(time=time, temp=temp, y=y)\ndf1 \n\n  time temp    y\n1   30  160 72.5\n2   30  180 74.2\n3   40  160 76.3\n4   40  180 77.0\n5   35  170 74.8\n6   35  170 75.6\n7   35  170 75.2\n\n\n반응표면분석에서는 고려하는 변량의 범위를 \\((-1,1)\\) 로 변환하는 작업을 먼저 수행한다. 위의 자료에서 시간과 온도의 범위를 \\((-1,1)\\)로 변환하기 위하여 다음과 같은 식을 적용한다.\n\\[ x_1 = \\frac{\\text{time} - 35}{5}, \\quad x_2 = \\frac{\\text{temp} - 170}{10} \\]\n위와 같은 변환은 패키지 rsm 에 있는 함수 coded.data를 사용해서 쉽게 수행할 수 있다.\n\ndf11 &lt;- coded.data(df1, x1 ~ (time - 35)/5, x2 ~ (temp - 170)/10)\nclass(df11)\n\n[1] \"coded.data\" \"data.frame\"\n\ndf11 \n\n  time temp    y\n1   30  160 72.5\n2   30  180 74.2\n3   40  160 76.3\n4   40  180 77.0\n5   35  170 74.8\n6   35  170 75.6\n7   35  170 75.2\n\nData are stored in coded form using these coding formulas ...\nx1 ~ (time - 35)/5\nx2 ~ (temp - 170)/10\n\n\n위에서 변환된 자료 df11 는 변환된 이름 x1 과 x2 로 자료가 저장되어 있지만 원래 변수의 이름 time 과 temp 도 특정한 함수에서 사용이 가능한다.\n9.2 장 자료에서 7번 실험을 수행하는 경우 고려한 실험점(experiment point)은 정사각형의 각 꼭지점에서 하나의 관측값을 얻고 중심점 \\((0,0)\\) 에서 3개의 실험값을 얻었다.\n\ndf11 %&gt;% ggplot(aes(time, temp)) + geom_point(colour = \"red\", size = 2)  + theme_bw()\ndf11 %&gt;% ggplot(aes(x1, x2)) + geom_point(colour = \"red\", size = 2)  + theme_bw()\n\n\n\n\n실험점의 배치\n\n\n\n\n\n\n\n실험점의 배치\n\n\n\n\n변환된 자료 x1 과 x2 의 값으로 부터 원래 자료의 값을 얻는 방법은 함수 code2val()을 사용한다. 예를 들어 x1 = 0.5 , x2 = 0.0 으로 코딩된 원래 자료 time 과 temp 의 값은 다음과 같이 얻을 수 있다.\n\ncode2val(data.frame(x1 = c(0.5), x2 = c(0.0)), codings(df11))\n\n  time temp\n1 37.5  170\n\n\n\n\n7.2.3 선형회귀식\n다음은 반응변수 \\(y\\) 를 에측하는 모형으로 두 개의 변량인자 \\(x_1\\)과 \\(x_2\\) 를 가지는 다음과 같은 일차선형 모형을 고려하자.\n\\[\ny = \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 +  e\n\\tag{7.1}\\]\n주어진 자료를 이용하여 위의 일차선형 모형의 회귀계수들을 추정하면 반응변수의 평균 \\(E(y|x)\\) 에 대한 다음과 같은 예측식을 얻을 수 있다.\n\\[\n\\widehat {E(y|x)} = \\hat y = \\hat \\beta_0 + \\hat \\beta_1 x_1 + \\hat \\beta_2 x_2\n\\tag{7.2}\\]\n변환된 \\(x_1\\) 과 \\(x_2\\) 가 저장된 데이터 프레임 df11 에 있는 자료를 이용하여 일차선형 모형을 적합한 결과는 다음과 같다.\n\nlmdf11 &lt;- lm(y ~ x1 + x2, data=df11)\nsummary(lmdf11)\n\n\nCall:\nlm.default(formula = y ~ x1 + x2, data = df11)\n\nResiduals:\n      1       2       3       4       5       6       7 \n-0.3357  0.1643  0.1643 -0.3357 -0.2857  0.5143  0.1143 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  75.0857     0.1510 497.201 9.82e-11 ***\nx1            1.6500     0.1998   8.259  0.00117 ** \nx2            0.6000     0.1998   3.003  0.03981 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.3996 on 4 degrees of freedom\nMultiple R-squared:  0.9508,    Adjusted R-squared:  0.9261 \nF-statistic: 38.62 on 2 and 4 DF,  p-value: 0.002425\n\n\n예측식 식 7.2 를 3차원 공간에 표시하면 다음과 같은 평면으로 나타나게 된다. 패키지 scatterplot3d 의 함수 scatterplot3d()를 이용하여 3차원 산포도와 추정된 선형식을 그릴 수 있다.\n\ns3d &lt;- scatterplot3d(as.data.frame(df11), type = \"h\", color = \"blue\", angle=55, pch = 16, xlab=\"x1\", ylab=\"x2\")\ns3d$plane3d(lmdf11)\n\n\n\n\n일차 선형식\n\n\n\n\n위에서 적합된 예측식 식 7.2 을 함수 contour.lm()을 이용하여 등고선 그림으로 나타내면 다음 그림과 같다.\n\ncontour.lm(lmdf11, x2~x1, labcex=1.4 )\npoints(c(-1,-1,1,1, 0), c(-1,1,-1,1,0), col=\"blue\", cex=1.3, pch=19)\n\n\n\n\n일차 선형식\n\n\n\n\n\n\n7.2.4 최대경사법\n이제 반응변수의 변화에 대한 선형 예측식이 식 7.2 로 주어진 경우 반응변수가 가장 크게 증가하는 방향을 2차원 공간 \\((x_1, x_2)\\)에서 찾아보자. 이렇게 공간에서 다변량 함수의 변화가 가장 크게 변하는 방향을 찾는 방법을 최대경사법(method of steepest ascent)이라고 부르며 이는 기울기 하강법(gradient descent method)의 반대 방법이다.\n이변량 함수 \\(f(x_1, x_2)\\) 에 대한 기울기 벡터(gradient) \\(\\nabla f\\)는 다음과 같이 각 축에 대한 부분 미분(partial derivative)로 이루어진 벡터이다.\n\\[\n\\nabla f  =  \\nabla f (x_1, x_2)  =\n\\begin{bmatrix}\n\\pardifftwo{f(x_1, x_2)}{x_1} \\\\\n\\pardifftwo{f(x_1, x_2)}{x_2}\n\\end{bmatrix}\n\\]\n기울기 벡터 \\(\\nabla f\\) 에 대한 기하학적 의미는 다음과 같은 그림으로 나타낼 수 있으며 \\(\\nabla f\\)는 주어진 점에서 함수 \\(f\\)가 가장 빨리 증가하는 방향을 의미한다. 따라서 기울기 벡터 \\(\\nabla f\\) 를 최대 경사(steepest ascent) 벡터라고 부른다.\n\n\n\n\n\n기울기 벡터의 기하학적 의미\n\n\n\n\n선형 예측식 식 7.2 이 주어진 경우 2차원 공간 \\((x_1, x_2)\\)에서 반응변수가 가장 크게 증가하는 방향, 즉 최대경사 방향 \\(\\nabla f\\) 은 다음과 같이 주어진다.\n\\[\n\\nabla f =\n\\begin{bmatrix}\n\\pardifftwo{f(x_1, x_2)}{x_1} \\\\\n\\pardifftwo{f(x_1, x_2)}{x_2} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\pardifftwo{(\\hat \\beta_0 + \\hat \\beta_1 x_1 + \\hat \\beta_2 x_2)}{x_1} \\\\\n\\pardifftwo{(\\hat \\beta_0 + \\hat \\beta_1 x_1 + \\hat \\beta_2 x_2)}{x_2}\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n\\hat \\beta_1  \\\\\n\\hat \\beta_2\n\\end{bmatrix}\n\\tag{7.3}\\]\n따라서 9.2절의 실험자료에 대하여 적합한 모형식을 이용하면 최대경사 벡터 \\(\\nabla f\\) 는 다음과 같이 주어진다.\n\\[\n\\nabla f =\n\\begin{bmatrix}\n1.65  \\\\\n0.6\n\\end{bmatrix}\n\\tag{7.4}\\]\n위의 최대경사 벡터 \\(\\nabla f\\)은 적합한 모형식에서 \\(x_1\\)과 \\(x_2\\) 가 1 단위 만큼 증가할 때 반응변수의 변화를 나타내는 회귀계수 \\(\\hat \\beta_1\\), \\(\\hat \\beta_2\\)의 방향을 의미한다.\n\ncoef(lmdf11)\n\n(Intercept)          x1          x2 \n   75.08571     1.65000     0.60000 \n\n\n식 식 7.4 에 나타난 최대경사 벡터 \\(\\nabla f\\)을 등고선 그림에 나타내면 다음과 같다. 아래의 등고선에서 최대경사 방향은 기울기가 \\(0.6/1.65=0.364\\) 를 가진 원점을 지나는 직선 방향이다.\n\ncontour.lm(lmdf11, x2~x1, xlabs=c( \"x1\", \"x2\"), bounds = list(x1 = c(-3, 3), x2 = c(-3, 3)))\npoints(c(-1,-1,1,1, 0), c(-1,1,-1,1,0), col=\"blue\", cex=1.3, pch=19)\nslope &lt;- as.numeric( coef(lmdf11)[\"x2\"] / coef(lmdf11)[\"x1\"])\nslope\n\n[1] 0.3636364\n\nlines(x=c(0,1), y=c(0,slope ), col=\"red\")\nabline(h=0, lty=2)\nabline(v=0, lty=2)\n\n\n\n\n일차 선형식(빨간선이 최대경사 방향)\n\n\n\n\n최대경사 벡터를 구하는 경우 벡터의 길이가 1 이 되도록 하는 경우도 있다. 이러한 경우의 최대경사 방향의 벡터는 다음과 같다.\n\\[\n\\begin{bmatrix}\n1.65 / \\sqrt{1.65^2 + 0.6^2}  \\\\\n0.60 / \\sqrt{1.65^2 + 0.6^2}  \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n0.9398 \\\\\n0.3417\n\\end{bmatrix}\n\\tag{7.5}\\]\n\nradi &lt;- sqrt(sum(c(coef(lmdf11)[\"x1\"], coef(lmdf11)[\"x2\"])^2))\nc(coef(lmdf11)[\"x1\"], coef(lmdf11)[\"x2\"])/radi\n\n       x1        x2 \n0.9397934 0.3417431 \n\n\n\n\n7.2.5 패키지 rsm\n위에서 언급한 분석을 포함한 다양한 반응표면 분석은 패키지 rsm 에 있는 여러 가지 함수를 이용하여 쉽게 수행할 수 있다.\n\n7.2.5.1 일차 선형식의 적합\n먼저 일차 선형식 식 7.1 을 적합하는 경우 함수 rsm() 을 다음과 같이 사용할 수 있다. 모형식에서 FO(x1, x2) 는 2개의 변수 x1 과 x2 로 구성된 일차선형식(FO; First Order function)를 사용하는 것을 의미한다.\n\nrsmdf1 &lt;- rsm(y ~ FO(x1, x2), data = df11)\nsummary(rsmdf1)\n\n\nCall:\nrsm(formula = y ~ FO(x1, x2), data = df11)\n\n            Estimate Std. Error  t value  Pr(&gt;|t|)    \n(Intercept) 75.08571    0.15102 497.2005 9.818e-11 ***\nx1           1.65000    0.19978   8.2592  0.001172 ** \nx2           0.60000    0.19978   3.0034  0.039810 *  \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nMultiple R-squared:  0.9508,    Adjusted R-squared:  0.9261 \nF-statistic: 38.62 on 2 and 4 DF,  p-value: 0.002425\n\nAnalysis of Variance Table\n\nResponse: y\n            Df  Sum Sq Mean Sq F value   Pr(&gt;F)\nFO(x1, x2)   2 12.3300  6.1650 38.6174 0.002425\nResiduals    4  0.6386  0.1596                 \nLack of fit  2  0.3186  0.1593  0.9955 0.501119\nPure error   2  0.3200  0.1600                 \n\nDirection of steepest ascent (at radius 1):\n       x1        x2 \n0.9397934 0.3417431 \n\nCorresponding increment in original units:\n    time     temp \n4.698967 3.417431 \n\n\n위의 함수 rsm()에서 얻은 결과는 선형모형을 적합하는 함수 lm() 의 결과에 추가적은 분석 결과가 포함된다. 추가 분석에 대한 설명은 다음과 같다.\n\nAnalysis of Variance Table 는 일반적인 분산분석표에 2차 반응표면 함수의 각 부분에 대한 유의성 F-검정이 주어진다. 반복이 있는 경우 적합성결여 검정(lack of fit test)이 주어지며 해당하는 p-값이 유의수준 \\(\\alpha\\) 보다 작으면 모형의 적합성에 문제가 있다는 의미이다. 위의 결과에서는 분산분석에서 Lack of fit 에 대한 p-값이 0.5011 이므로 선형모형의 적합성에는 큰 문제가 없다.\nDirection of steepest ascent (at radius 1) 부분에서는 길이가 1 인 최대경사 벡터 \\(\\nabla f\\)를 구해준다.\nCorresponding increment in original units 부분에서는 최대경사 벡터를 원래 변환되기 전의 자료의 단위로 구해준다.\n\n\n\n7.2.5.2 등고선 그림\n반응 표면의 등고선 그림은 함수 rsm() 의 적합 결과를 이용하여 contour() 함수를 사용하면 쉽게 그릴 수 있다.\n\ncontour(rsmdf1, ~ x1 + x2)\ncontour(rsmdf1, ~ x1 + x2, image = TRUE)\n\n\n\n\nrsm 결과를 이용한 등고선 그림\n\n\n\n\n\n\n\nrsm 결과를 이용한 등고선 그림\n\n\n\n\n\n\n7.2.5.3 최적 실험점 탐색\n이제 실험 원점 \\((0,0)\\) 에서 최대경사 벡터 \\(\\nabla f\\) 방향으로 여러 개의 실험점을 계산하려면 함수 steepest()를 사용한다. 아래의 함수에서 dist=seq(0,5, by=1) 는 최대경사 벡터 방향으로 길이가 1 만큼 증가하면서 길이가 5인 점까지 실험점을 구하라는 의미이다.\n\ndeltapoints &lt;- steepest(rsmdf1, dist=seq(0,5, by=1))\n\nPath of steepest ascent from ridge analysis:\n\ndeltapoints\n\n  dist    x1    x2 |   time   temp |   yhat\n1    0 0.000 0.000 | 35.000 170.00 | 75.086\n2    1 0.940 0.342 | 39.700 173.42 | 76.842\n3    2 1.880 0.683 | 44.400 176.83 | 78.598\n4    3 2.819 1.025 | 49.095 180.25 | 80.352\n5    4 3.759 1.367 | 53.795 183.67 | 82.108\n6    5 4.699 1.709 | 58.495 187.09 | 83.864\n\n\n위에서 구한 실험점들을 등고선 그림에 표시하면 다음과 같다.\n\ncontour(rsmdf1, ~ x1 + x2,  bounds = list(x1 = c(-3, 3), x2 = c(-3, 3)))\npoints(deltapoints$time, deltapoints$temp, cex=1.2, col=\"red\", pch=19)\n\n\n\n\n최대경사 벡터 방향의 실험점\n\n\n\n\n만약 아래 그림과 같이 최대경사 방향으로 4번의 실험을 수행하였다면 다음 실험의 중심점은 \\((50, 180.9)\\)를 선택한다. 왜냐하면 더 경사면으로 올라간 실험점 \\((55, 184.6)\\) 에서는 반응값이 감소하기 때문이다.\n\n\n\n\n\n최대경사법을 이용한 실험점 찾기\n\n\n\n\n\n\n\n7.2.6 변량이 3개 이상인 경우\n\nheli\n\n   block    A    R    W   L ave logSD\n1      1 11.8 2.26 1.00 1.5 367    72\n2      1 13.0 2.26 1.00 1.5 369    72\n3      1 11.8 2.78 1.00 1.5 374    74\n4      1 13.0 2.78 1.00 1.5 370    79\n5      1 11.8 2.26 1.50 1.5 372    72\n6      1 13.0 2.26 1.50 1.5 355    81\n7      1 11.8 2.78 1.50 1.5 397    72\n8      1 13.0 2.78 1.50 1.5 377    99\n9      1 11.8 2.26 1.00 2.5 350    90\n10     1 13.0 2.26 1.00 2.5 373    86\n11     1 11.8 2.78 1.00 2.5 358    92\n12     1 13.0 2.78 1.00 2.5 363   112\n13     1 11.8 2.26 1.50 2.5 344    76\n14     1 13.0 2.26 1.50 2.5 355    69\n15     1 11.8 2.78 1.50 2.5 370    91\n16     1 13.0 2.78 1.50 2.5 362    71\n17     1 12.4 2.52 1.25 2.0 377    51\n18     1 12.4 2.52 1.25 2.0 375    74\n19     2 11.2 2.52 1.25 2.0 361   111\n20     2 13.6 2.52 1.25 2.0 364    93\n21     2 12.4 2.00 1.25 2.0 355   100\n22     2 12.4 3.04 1.25 2.0 373    80\n23     2 12.4 2.52 0.75 2.0 361    71\n24     2 12.4 2.52 1.75 2.0 360    98\n25     2 12.4 2.52 1.25 1.0 380    69\n26     2 12.4 2.52 1.25 3.0 360    74\n27     2 12.4 2.52 1.25 2.0 370    86\n28     2 12.4 2.52 1.25 2.0 368    74\n29     2 12.4 2.52 1.25 2.0 369    89\n30     2 12.4 2.52 1.25 2.0 366    76\n\nData are stored in coded form using these coding formulas ...\nx1 ~ (A - 12.4)/0.6\nx2 ~ (R - 2.52)/0.26\nx3 ~ (W - 1.25)/0.25\nx4 ~ (L - 2)/0.5\n\n\n\nheli.rsm &lt;- rsm(ave ~  FO(x1, x2, x3, x4), data = heli)\nsummary(heli.rsm)\n\n\nCall:\nrsm(formula = ave ~ FO(x1, x2, x3, x4), data = heli)\n\n              Estimate Std. Error  t value  Pr(&gt;|t|)    \n(Intercept) 366.500000   1.437359 254.9816 &lt; 2.2e-16 ***\nx1           -0.083333   1.607016  -0.0519 0.9590556    \nx2            5.083333   1.607016   3.1632 0.0040659 ** \nx3            0.250000   1.607016   0.1556 0.8776230    \nx4           -6.083333   1.607016  -3.7855 0.0008577 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nMultiple R-squared:  0.4935,    Adjusted R-squared:  0.4125 \nF-statistic: 6.091 on 4 and 25 DF,  p-value: 0.001453\n\nAnalysis of Variance Table\n\nResponse: ave\n                   Df  Sum Sq Mean Sq F value   Pr(&gt;F)\nFO(x1, x2, x3, x4)  4 1510.00  377.50  6.0907 0.001453\nResiduals          25 1549.50   61.98                 \nLack of fit        20 1458.67   72.93  4.0147 0.064646\nPure error          5   90.83   18.17                 \n\nDirection of steepest ascent (at radius 1):\n         x1          x2          x3          x4 \n-0.01050596  0.64086379  0.03151789 -0.76693536 \n\nCorresponding increment in original units:\n           A            R            W            L \n-0.006303578  0.166624586  0.007879473 -0.383467680 \n\n\n\n par(mfrow = c(2, 3))\ncontour(heli.rsm, ~ x1 + x2 + x3 + x4)\n\n\n\n\n\n\n\n\n\nsteepest(heli.rsm)\n\nPath of steepest ascent from ridge analysis:\n\n\n   dist     x1    x2    x3     x4 |       A       R       W      L |    yhat\n1   0.0  0.000 0.000 0.000  0.000 | 12.4000 2.52000 1.25000 2.0000 | 366.500\n2   0.5 -0.005 0.320 0.016 -0.383 | 12.3970 2.60320 1.25400 1.8085 | 370.461\n3   1.0 -0.011 0.641 0.032 -0.767 | 12.3934 2.68666 1.25800 1.6165 | 374.433\n4   1.5 -0.016 0.961 0.047 -1.150 | 12.3904 2.76986 1.26175 1.4250 | 378.394\n5   2.0 -0.021 1.282 0.063 -1.534 | 12.3874 2.85332 1.26575 1.2330 | 382.366\n6   2.5 -0.026 1.602 0.079 -1.917 | 12.3844 2.93652 1.26975 1.0415 | 386.327\n7   3.0 -0.032 1.923 0.095 -2.301 | 12.3808 3.01998 1.27375 0.8495 | 390.299\n8   3.5 -0.037 2.243 0.110 -2.684 | 12.3778 3.10318 1.27750 0.6580 | 394.260\n9   4.0 -0.042 2.563 0.126 -3.068 | 12.3748 3.18638 1.28150 0.4660 | 398.227\n10  4.5 -0.047 2.884 0.142 -3.451 | 12.3718 3.26984 1.28550 0.2745 | 402.193\n11  5.0 -0.053 3.204 0.158 -3.835 | 12.3682 3.35304 1.28950 0.0825 | 406.160",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#secondorder",
    "href": "qmd/response.html#secondorder",
    "title": "7  반응표면 분석",
    "section": "7.3 2차 반응표면",
    "text": "7.3 2차 반응표면\n\n7.3.1 개요\n\n여러번의 간단한 실험을 순차적으로 수행하면서 1차모형과 최대경사법을 이용하여 최적점 근처로 실험점을 이동한다.\n최적조건 근처의 영역에서는 반응표면모형의 모형으로 곡선효과가 고려된 2차 다항 모형을 가정하고 최적점을 찾는다.\n\n\n\n7.3.2 2차 다항 모형\n이제 반응변수 \\(y\\)의 변화(반응표면; response surface)를 \\(k\\) 개의 독립변수 \\(x_1, x_2, \\cdots, x_k\\) 로 이루어진 2차 다항식(second polynomial function)으로 적합하는 2차 다항 모형을 고려하자.\n\\[\ny = \\beta_0 + \\sum_{i=1}^{k} \\beta_i x_i + \\sum_{i=1}^{k} \\beta_{ii} x^2_i + \\underset{i&lt;j}{\\sum \\sum} \\beta_{ij} x_i x_j +e\n\\tag{7.6}\\]\n\n\n\n\n\n\n노트\n\n\n\n반응표면분석에서 고려한 2차 다항 모형에서는 독립변수의 값들이 모두 \\([-1,1]\\) 사이에 있다고 가정하자.\n\n\n\n\n7.3.3 이차 반응표면의 모양\n예를 들어 독립변수가 두 개인 경우 다음과 같은 2차 다항 모형이 된다.\n\\[\ny = \\beta_0 + \\beta_1 x_1  + \\beta_2 x_2 + \\beta_{11} x_1^2 + \\beta_{22} x_2^2 + \\beta_{12} x_1 x_2 + e\n\\tag{7.7}\\]\n독립변수가 두 개인 경우 2차 다항 모형 식 7.7 은 다음 그림과 같이 다양한 반응 표면을 가질 수 있다.\n\n\n\n\n\n이차 반응표면의 모양- 표면그림과 등고선\n\n\n\n\n\n\n\n이차 반응표면의 모양- 표면그림과 등고선\n\n\n\n\n\n\n7.3.4 최적점과 정상점\n2차 다항모형 식 7.6 을 반응표면 분석에 사용하는 이유는 반응변수의 값이 최대가 되는 독립변수들의 값을 구하기 위함이다. 이렇게 반응변수의 값이 최대가 되는 독립변수들의 값을 최적점(optimum point) 라고 부른다.\n최적점을 찾는 방법은 2차 다항모형 식 7.6 을 각 독립변수로 미분한 식을 0으로 놓고 방정식을 푸는 것이다. 최적점을 찾는 방법을 좀 더 체계적으로 구성하기 위하여 2차 다항모형 식 7.6 을 벡터와 행렬로 나타내어 보자.\n먼저 자료를 이용하여 2차 다항모형 식 7.6 에 나타난 계수들을 추정한 후 반응변수의 예측식을 다음과 같이 나타낼 수 있다. 아래의 식에서 \\(b_0,b_{i}, b_{ii}, b_{ij}\\) 는 각각 회귀계수 \\(\\beta_0, \\beta_{i}, \\beta_{ii}, \\beta_{ij}\\) 의 추정값이라고 하자.\n\\[\n\\hat y = b_0 + \\sum_{i=1}^{k} b_i x_i + \\sum_{i=1}^{k} b_{ii} x^2_i + \\underset{i&lt;j}{\\sum \\sum} b_{ij} x_i x_j\n\\tag{7.8}\\]\n이제 추정식 식 7.8 를 다음과 같이 벡터와 행렬로 나타내자.\n\\[\n\\hat y = b_0 + {\\pmb  x}^t \\pmb  b + {\\pmb  x}^t \\pmb  B {\\pmb  x}\n\\tag{7.9}\\]\n여기서 \\(k \\times 1\\) 차원의 독립변수 벡터 \\(\\pmb  x\\), \\(k \\times 1\\) 차원의 1차 계수 벡터 \\(\\pmb  b\\), \\(k \\times K\\) 차원의 2차 계수 행렬 \\(\\pmb  B\\) 는 다음과 같이 주어진다. 여기서 2차 계수 행렬 \\(\\pmb  B\\) 는 대칭행렬이며 비대각 원소는 계수 \\(b_{ij}\\)의 반 값임을 유의하자.\n\\[\n\\pmb  x =\n\\begin{bmatrix}\nx_1 \\\\\nx_2 \\\\\n\\vdots \\\\\nx_k\n\\end{bmatrix}\n, \\quad\n\\pmb  b =\n\\begin{bmatrix}\nb_1 \\\\\nb_2 \\\\\n\\vdots \\\\\nb_k\n\\end{bmatrix}, \\quad\n\\pmb  B =\n\\begin{bmatrix}\nb_{11}   & \\frac{b_{12}}{2} & \\frac{b_{13}}{2}    & \\dots & \\frac{b_{1k}}{2} \\\\\n\\frac{b_{12}}{2} & b_{22}   & \\frac{b_{23}}{2}  & \\dots & \\frac{b_{2k}}{2}  \\\\\n\\frac{b_{13}}{2}  & \\frac{b_{23}}{2}    & b_{33} & \\dots & \\frac{b_{3k}}{2} \\\\\n\\vdots   & \\vdots   & \\vdots   & \\vdots & \\vdots \\\\\n\\frac{b_{1k}}{2}  & \\frac{b_{2k}}{2}    & \\frac{b_{3k}}{2}  & \\dots & b_{kk}\n\\end{bmatrix}\n\\tag{7.10}\\]\n이제 정삼점을 찿는 방법은 2차 다항 에측식 식 7.8 를 각 독립변수 \\(x_i\\) 로 미분한 식을 0으로 놓은 방정식을 풀면 된다.\n\\[\n\\pardifftwo{\\hat y}{x_i} =  b_i + 2 b_{ii} x_i + \\sum_{j \\ne i} b_{ij} x_j =0, \\quad i=1,2,\\cdots, k\n\\tag{7.11}\\]\n방정식 식 7.11 을 벡터식으로 표시하면 다음과 같은 벡터 방정식을 얻는다.\n\\[\n\\pardifftwo{\\hat y}{\\pmb  x} =  \\pmb  b + 2 {\\pmb  B} \\pmb  x = \\pmb  0\n\\tag{7.12}\\]\n벡터 방정식 식 7.12 을 만족하는 벡터 \\({\\pmb  x}^*\\) 를 정상점(stationary point) 라고 부르며 정상점 \\({\\pmb  x}^* = (x_1^*, x_2^*, \\cdots, x_k^*)^t\\) 는 다음과 같이 얻어진다.\n\\[\n{\\pmb  x}^* =  - \\frac{1}{2} {\\pmb  B}^{-1} \\pmb  b\n\\tag{7.13}\\]\n식 식 7.13 에 주어진 정상점 \\({\\pmb  x}^*\\) 은 행렬 \\(\\pmb  B\\) 의 성질에 따라서 반응값을 최대로 하는 최적점일 수도 있고 아닐 수도 있다. 다음 절에서는 정상점이 최적점일 조건을 살펴보기로 하자.\n\n\n7.3.5 2차 다항식의 표현\n앞 절에서 보았듯이 정상점 \\({\\pmb  x}^*\\) 은 추정된 2차 다항식에 대하여 미분방정식 식 7.13 을 만족하는 점이다.\n2차 다항식은 그림 @ref(fig:plot3) 처럼 다양한 모양을 가진다. 실험의 목적이 반응변수를 최대로 하는 최적점을 찾는 것이기 떄문에 2차 다항식의 모양이 산 모양이면 정상점이 최적점이 되지만 다른 형태이면 최적점이 아니다.\n정상점 \\({\\pmb  x}^*\\) 이 최적점이 될 조건은 행렬 \\(\\pmb  B\\)에 대한 정준분석(canonical analysis)를 통하여 파악할 수 있다. 정준분석은 행령의 고유값(eigen value)과 고유벡터(eigen vector) 를 통하여 이루어진다. 이 절에서는 정분분석을 하기 위하여 2차 다항식을 다루기 쉬운 형식으로 표현하고자 한다.\n식 식 7.13 의 정상점 \\({\\pmb  x}^*\\) 을 중심으로 하는 축 \\(\\pmb  z\\) 를 다음과 같이 고려하고\n\\[\n\\pmb  z = \\pmb  x - {\\pmb  x}^* \\quad \\text{ equivalently} \\quad  \\pmb  x =  {\\pmb  x}^* + \\pmb  z\n\\tag{7.14}\\]\n2차 다항식 식 7.9 를 다음과 같이 \\(\\pmb  z\\) 의 함수로 변환해 보자. 아래 식에서 정상점 \\({\\pmb  x}^* =  -{\\pmb  B}^{-1} \\pmb  b/2\\) 이다.\n\\[\n\\begin{aligned}\n\\hat y  & =   b_0 + {\\pmb  x}^t \\pmb  b + {\\pmb  x}^t \\pmb  B {\\pmb  x}  \\\\\n  & =  b_0  + {\\pmb  x}^t \\pmb  b +  ({\\pmb  x}^* + \\pmb  z )^t \\pmb  B ({\\pmb  x}^* + \\pmb  z ) \\\\\n  & =  b_0  + {\\pmb  x}^t \\pmb  b + 2 {\\pmb  x}^{*t}  \\pmb  B  \\pmb  z  + {\\pmb  x}^{*t}  \\pmb  B {\\pmb  x}^{*} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n   & =  b_0  + {\\pmb  x}^t \\pmb  b - {\\pmb  b}^t  {\\pmb  B}^{-1}  \\pmb  B  \\pmb  z  +\\frac{1}{4} {\\pmb  b}^t  {\\pmb  B}^{-1} \\pmb  B {\\pmb  B}^{-1} {\\pmb  b} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n   & = b_0  + {\\pmb  x}^t \\pmb  b  - {\\pmb  b}^t  \\pmb  z +\\frac{1}{4}  {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n   & = b_0  + ({\\pmb  x}^* + \\pmb  z)^t \\pmb  b  - {\\pmb  b}^t  \\pmb  z +\\frac{1}{4}  {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n   & = b_0 + ( {\\pmb  z}^t \\pmb  b - {\\pmb  b}^t  \\pmb  z) + {\\pmb  x}^{*t} \\pmb  b  +\\frac{1}{4}  {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n  & = b_0 + 0  + \\left [ - \\frac{1}{2}   {\\pmb  b}^t  {\\pmb  B}^{-1} \\right ] {\\pmb  b} +\\frac{1}{4}  {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} +  {\\pmb  z}^t \\pmb  B  {\\pmb  z} \\\\\n  & =  \\left [ b_0 - \\frac{1}{4} {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b}  \\right ] +  {\\pmb  z}^t \\pmb  B  {\\pmb  z}\n\\end{aligned}\n\\tag{7.15}\\]\n위의 식에서 \\(\\pmb  z= 0\\) 인 점은 원래의 측으로 보면 정상점 \\(\\pmb  x ={\\pmb  x}^*\\) 이다. 정상점에서의 반응변수의 예측값을 \\(\\hat y_s\\) 라고 하면\n\\[ \\hat y_s =   b_0 + {\\pmb  x}^{*t} \\pmb  b + {\\pmb  x}^{*t} \\pmb  B {\\pmb  x}^* =  b_0 - \\frac{1}{4} {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} \\]\n따라서 2차 다항식의 예측식 식 7.9 은 변수 \\(\\pmb  z = \\pmb  x - {\\pmb  x}^*\\) 으로 다음과 같이 나타낼 수 있다.\n\\[\n\\hat y = \\hat y_s +   {\\pmb  z}^t \\pmb  B  {\\pmb  z}\n\\tag{7.16}\\]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#canonocal",
    "href": "qmd/response.html#canonocal",
    "title": "7  반응표면 분석",
    "section": "7.4 2차모형의 정준분석",
    "text": "7.4 2차모형의 정준분석\n\n7.4.1 개요\n\n여러번의 간단한 실험을 순차적으로 수행하면서 1차모형과 최대경사법을 이용하여 최적점 근처로 실험점을 이동한다.\n최적조건 근처의 영역에서는 반응표면모형의 모형으로 곡선효과가 고려된 2차 다항 모형을 가정하고 최적점을 찾는다.\n2차 다항 모형은 계수의 추정치에 따라서 반응표면의 모양을 4가지 모양으로 크게 분류하할 수 있다.\n추정된 2차 모형이 어떤 모양에 해당하는지 판단할 수 있는 기법인 정준분석(canonocal analysis)을 적용한다.\n\n\n\n7.4.2 이차형식\n임의의 벡터 \\(\\pmb  x\\)에 대하여 차원이 \\(k \\times k\\) 인 대칭 행렬 \\(\\pmb  B\\) 이 주어진 경우 이차형식(quadratic form) \\(s(\\pmb  x, \\pmb  B)\\)는 다음과 같이 정의된다.\n\\[\ns(\\pmb  x, \\pmb  B) = {\\pmb  x}^t \\pmb  B \\pmb  x\n\\tag{7.17}\\]\n만약 행렬 \\(\\pmb  B\\)의 고유값이 다음과 같고\n\\[ \\lambda_1 ,\\lambda_2 , \\dots , \\lambda_k \\]\n이에 대응하는 고유벡터가 다음과 같다고 하자.\n\\[  \\pmb  q_1, \\pmb  q_2 , \\cdots , \\pmb  q_k \\]\n자세한 고유값과 고유젝터에 대한 이론은 부록을 참조하자.\n대칭 행렬 \\(\\pmb  B\\)의 고유값과 고유벡터를 이용하면 다음과 같은 스펙트럴 분해(spectral decomposition)가 가능하다 (부록 참조).\n\\[\n\\pmb  B = \\pmb  Q \\pmb  \\Lambda {\\pmb  Q}^t = \\lambda_1 \\pmb  q_1 \\pmb  q_1^t + \\lambda_2 \\pmb  q_2 \\pmb  q_2^t\n+ \\cdots + \\lambda_k \\pmb  q_k \\pmb  q_k^t\n\\tag{7.18}\\]\n이제 식 식 7.17 에서 정의된 이차형식은 스펙트럴 분해를 이용하여 다음과 같은 분해가 가능하다.\n\\[\n\\begin{aligned}\ns(\\pmb  x, \\pmb  B) & = {\\pmb  x}^t \\pmb  B \\pmb  x \\notag \\\\\n    & = {\\pmb  x}^t \\pmb  Q \\pmb  \\Lambda {\\pmb  Q}^t \\pmb  x \\notag \\\\\n    &= {\\pmb  x}^t  \\left [ \\lambda_1 \\pmb  q_1 \\pmb  q_1^t + \\lambda_2 \\pmb  q_2 \\pmb  q_2^t\n+ \\cdots + \\lambda_k \\pmb  q_k \\pmb  q_k^t \\right ] \\pmb  x \\notag \\\\\n& = \\sum_{i=1}^k \\lambda_i  ( {\\pmb  x}^t \\pmb  q_i)  (\\pmb  q_i^t \\pmb  x) \\notag  \\\\\n& = \\sum_{i=1}^k \\lambda_i w_i^2\n\\end{aligned}\n\\tag{7.19}\\]\n여기서\n\\[ w_i = {\\pmb  x}^t \\pmb  q_i = \\pmb  q_i^t \\pmb  x, \\quad i=1,2,\\dots, k \\]",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#차-다항식의-정준형식",
    "href": "qmd/response.html#차-다항식의-정준형식",
    "title": "7  반응표면 분석",
    "section": "7.5 2차 다항식의 정준형식",
    "text": "7.5 2차 다항식의 정준형식\n앞 절에서 논의한 것을 정리하면 2차 다항식의 예측식은 식 식 7.14 에서 정의된 변수 \\(\\pmb  z = \\pmb  x - {\\pmb  x}^*\\) 를 이용하여 식 식 7.16 과 같이 표현할 수 있으므로 다음과 같이 정준형식으로 나타낼 수 있다.\n\\[\n\\begin{aligned}\n\\hat y & = \\hat y_s +   {\\pmb  z}^t \\pmb  B  {\\pmb  z}  \\notag \\\\\n  & = \\hat y_s + \\lambda_1 w_1^2 + \\lambda_2 w_2^2 + \\cdots + \\lambda_k w_k^2\n\\end{aligned}\n\\tag{7.20}\\]\n여기서\n\\[w_i = {\\pmb  z}^t \\pmb  q_i = \\pmb  q_i^t \\pmb  z, \\quad i=1,2,\\dots, k \\]\n\\[ \\hat y_s =   b_0 - \\frac{1}{4} {\\pmb  b}^t {\\pmb  B}^{-1}{\\pmb  b} \\]\n위의 식 식 7.20 을 2차 다항식의 정준형식(canonical form) 이라고 부른다.\n이제 행렬 \\(\\pmb  B\\) 의 고유값을 이용한 정준분석을 이용하여 다음과 같이 정상점의 형태와 최적점의 유무를 알아낼 수 있다.\n\n정준분석을 이용한 최적점의 판단\n\n\n행렬 \\(\\pmb  B\\) 의 고유값\n정상점은\n\n\n\n\n모두 음수이면\n최대점(최적점)\n\n\n모두 양수 이면\n최저점\n\n\n양수와 음수가 섞여있으면\n안장점\n\n\n\n\n7.5.1 변환된 변수\n2차 다항식의 정준형식 식 7.20 에 나타난 변환된 변수 \\(w_i\\) 와 원래 사용된 변수 \\(x_i\\) 의 관계를 알아보자.\n변수 \\(z_i\\) 는 원래 변수 \\(x_i\\) 에서 정상점 \\(x_i^*\\) 를 빼서 만든 변수이다 식 7.14. 또한 \\(w_i = {\\pmb  q}_i^t \\pmb  z\\) 이므로 다음과 같은 변환식이 얻어진다.\n\\[\n\\pmb  w =\n\\begin{bmatrix}\nw_1 \\\\\nw_2 \\\\\n\\vdots \\\\\nw_k\n\\end{bmatrix}\n= \\pmb  Q^t \\pmb  z  = \\pmb  Q^t (\\pmb  x -\\pmb  x^*)\n\\tag{7.21}\\]\n여기서 행렬 \\(\\pmb  Q\\) 는 행렬 \\(\\pmb  B\\) 의 고유벡터들로 이루진다. 따라서 행렬 \\(\\pmb  Q\\) 는 직교행렬이다.\n\\[ \\pmb  Q = [ \\pmb  q_1~ \\pmb  q_2 ~ \\dots \\pmb  q_k], \\quad  \\pmb  Q^t \\pmb  Q = \\pmb  Q \\pmb  Q^t = \\pmb  I \\]\n따라서 식 식 7.21 에서 정의된 변환은 벡터 \\(\\pmb  z\\)를 행렬 \\(\\pmb  Q\\) 를 이용하여 회전하는 변환이다.\n\\[ \\pmb  w^t \\pmb  w = \\pmb  z^t  \\pmb  Q \\pmb  Q^t \\pmb  z =  \\pmb  z^t  \\pmb  z \\]\n\n\n\n\n\n\n\n\n\n\n\n7.5.2 예제: 2개의 독립 변수\n만약 독립변수가 2개 있는 2차 다항 모형에서는 행렬 \\(\\pmb  B\\)의 차원은 \\(2 \\times 2\\)이다. 따라서 행렬 \\(\\pmb  B\\)의 고유치는 \\(\\lambda_1\\) 과 \\(\\lambda_2\\) 라고 하자.\n이 경우는 2차 형식이 다음과 같이 분해될 수 있다.\n\\[ s(\\pmb  x, \\pmb  B) =  \\pmb  x^t \\pmb  B \\pmb  x = \\lambda_1 w_1^2 + \\lambda_2 w_2^2 \\]\n위의 2차 형식을 계산하는 함수를 R 로 만들어 보자.\n\nquad &lt;- function(w1, w2, l1, l2){\n  l1*w1^2 + l2*w2^2\n}\n\n\n\\(\\lambda_1 &lt; \\lambda_2 &lt;  0\\) 의 경우\n\n이차형식 \\(s(\\pmb  x, \\pmb  B)\\) 는 정상점이 최대 반응점이 되며 \\(w_2\\) 에 비하여 \\(w_1\\) 축으로 반응의 변화가 급하다.\n\\(\\lambda_1 =-4\\), \\(\\lambda_2 =-1\\) 인 경우 2차 형식의 형태는 다음과 같다.\n\n\n\nw1 &lt;- w2 &lt;- seq(-1, 1, length= 30)\ns &lt;- outer(w1, w2 ,quad, -4, -1)\npersp3D(w1, w2, s,\n      main=\"이차형식: l1 &lt; l2 &lt; 0\",\n      zlab = \"s\",\n      theta = 30, phi = 15)\n\n\n\n\n\n\n\n\n\n\\(\\lambda_1 &gt; \\lambda_2 &gt;  0\\) 의 경우\n\n이차형식 \\(s(\\pmb  x, \\pmb  B)\\) 는 정상점이 최소 반응점이 되며 \\(w_2\\) 에 비하여 \\(w_1\\) 축으로 반응의 변화가 급하다.\n\\(\\lambda_1 =2\\), \\(\\lambda_2 =1\\) 인 경우 2차 형식의 형태는 다음과 같다.\n\n\n\nw1 &lt;- w2 &lt;- seq(-1, 1, length= 30)\ns &lt;- outer(w1, w2 ,quad, 3, 1)\npersp3D(w1, w2, s,\n      main=\"이차형식: l1 &gt; l2 &gt;  0\",\n      zlab = \"s\",\n      theta = 40, phi = 20)\n\n\n\n\n\n\n\n\n\n\\(\\lambda_1 &gt;0\\), \\(\\lambda_2 &lt;0\\), \\(|\\lambda_1| &gt; |\\lambda_2\\) 의 경우\n\n이차형식 \\(s(\\pmb  x, \\pmb  B)\\) 는 정상점이 안장점(saddle point)이 되며 \\(w_2\\) 축으로는 반응값이 감소하게 되고 \\(w_1\\) 축으로는 반응값이 증가하게 된다. 또한 \\(w_2\\) 에 비하여 \\(w_1\\) 축으로 반응의 변화가 급하다.\n\\(\\lambda_1 = - 3\\), \\(\\lambda_2 =1\\) 인 경우 2차 형식의 형태는 다음과 같다.\n\n\n\nw1 &lt;- w2 &lt;- seq(-1, 1, length= 30)\ns &lt;- outer(w1, w2 ,quad, -3, 1)\npersp3D(w1, w2, s,\n      main=\"이차형식: l1 &gt;  0  &gt; l2\",\n      zlab = \"s\",\n      theta = 40, phi = 15)\n\n\n\n\n\n\n\n\n\n\\(\\lambda_i  \\approx 0\\) 인 경우\n\n반응표면 체계가 능선 체계(ridge system)이라고 한다. 능선 체계에서는 최적점이 무수히 많은 정상 능선 체계(stationary ridge system)와 능선이 한 방향ㅇ으로 계속 증가하는 형태(rising ridge system)으로 나뉜다. 올라가는 능선 체계에서는 현제의 실험 영역에서 최적점이 없기 때문에 실헌 영역을 변경하여 다시 실험을 진행해야 한다.\n\\(\\lambda_1 = 0\\), \\(\\lambda_2 =1\\) 인 경우 2차 형식의 형태는 다음과 같다.\n\n\n\nw1 &lt;- w2 &lt;- seq(-1, 1, length= 30)\ns &lt;- outer(w1, w2 ,quad, 0, 1)\npersp3D(w1, w2, s,\n      main=\"이차형식: l1 =  0 \",\n      zlab = \"s\",\n      theta = 40, phi = 15)",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#expriment",
    "href": "qmd/response.html#expriment",
    "title": "7  반응표면 분석",
    "section": "7.6 최적점 탐색을 위한 실험계획",
    "text": "7.6 최적점 탐색을 위한 실험계획\n\n7.6.1 개요\n\n최적조건 근처의 영역에서는 반응표면모형의 모형으로 곡선효과가 고려된 2차 다항 모형을 가정하고 최적점을 찾는다.\n최적 조건을 찾는 실험에서는 실험점을 효율적으로 배치해야 한다.\n2차다항식을 적합해야 하기 때문에 각 요인에 대하여 최소한 3개의 수준이 필요하다.\n\n\n\n7.6.2 중심합성설계\n반응표면 분석에서 고려하는 변량(독립변수)의 개수가 \\(k\\) 개 이면 한 요인에 대해서 최소한 3개의 수준이 필요하다. 3개의 수준이 필요한 이유는 2차 다항식을 고려해야 하기 때문이다.\n따라서 요인의 개수가 \\(k\\) 이면 실험점의 개수가 \\(3^k\\) 가 필요하며 실험점의 개수는 요인의 수에 따라서 기하급수적으로 늘어나게 된다. 예를 들어 \\(k=3\\) 인 경우에는 실험점이 \\(3^3=27\\) 개, 경우에는 실험점이 \\(3^4=81\\) 개로 늘어나는데 이는 현실적으로 감당하기 어려운 경우일 수 있다.\n따라서 반응표면 방법에서는 실험을 축차적으로(sequentially) 실행하면서 최적점 근처에서 더 많은 실험을 수행할 수 있는 효율적인 실험 계획을 고려해야 한다. 아래는 반응표면 실험의 축차적인 절차를 설명한다.\n\n1차 모형 적합을 위한 1단계 실험\n\n먼저 중심점(center points)에서 \\(n_0\\) 개의 실험을 수행하고 각 요인의 상자점들(factorial points)에서 \\(2^k\\) 실험을 실시한다.\n이러한 기초 실험은 최대경사법을 이용하는 중간 과정에서 언제나 수행해야 하는 실험이다.\n기초 실험은 1차 모형을 적합하기 위한 실험계획이다.\n기초 실험에서 실험 구간에 최적점이 포함되어 있다고 판단되면 2차 모형 적합을 위한 2단계실험을 실시한다.\n1단계 실험의 개수는 상자점 \\(2^k\\) 개 + 중심점 \\(n_0\\) 개\n\n2차 모형 적합을 위한 2단계 실험\n\n최적점이 가까워진 경우 2차 모형 적합을 위해서 1단계 실험의 실험점들에 추가적인 실험점을 더해서 2단계 실험을 진행한다.\n2차 모형을 적합하기 위한 실험으로 각 요인에 대하여 2개의 축점(axial points, star points)을 더 추가한다. 기초실험에서 수행한 실험점들과 합쳐서 각 요인마다 3개의 수준을 가지는 실험점을 만든다.\n2단계 실험에서 추가한 축점은 2차 모형의 효율적인 추정을 고려하여 선택한다.\n2단계 실험의 개수는 축점 \\(2k\\) 개\n\n\n반응표면방법에서 위와 같이 최적점 탐색을 하는 경우 사용되는 대표적인 실험설계는 중심합성설계(CCD: central composite design) 이다.\n\n\n\n\n\n구형 계획법을 이용한 중심합성설계\n\n\n\n\n중심합성설계에서 축차적으로 실험을 실시한 경우 \\(k\\)개의 요인을 고려하면 실험점들은 그 특성에 따라서 다음과 같은 나타난다.\n\n\n\n\n\n\n\n\n실험점\n목적\n개수\n\n\n\n\n상자점(factorial points)\n1차 모형 적합을 위한 2수준 배치법에서의 실험점\n\\(F=2^k\\)\n\n\n중심점(center points)\n관심 구간의 중심에 위치한 실험점\n\\(n_0\\)\n\n\n축점(axial points)\n2차 모형 적합을 위해 추가된 실험점\n\\(n_a=2k\\)\n\n\n\n\n\n7.6.3 회전가능 중심합성설계\n중심합성설계에서 2차 다항식을 추정하기 위한 2단계 실험에서 추가하는 축점(axial points)을 어떻게 선택하는 것이 좋을까?\n축점을 배치할 때 중요한 고려사항은 2차 다항식에서 얻은 추정치들의 분산이 각 실험접들에서 동일하게 나타나게 하는 것이다. 이러한 성질을 회전 가능성(Rotatibility) 라고 부른다. 이러한 회전 가능성이 만족하면 고려한 모든 실험점들에서 구한 예측값들의 정도(precision)가 같다는 의미이다.\n회전가능성이 중요한 이유는 반응표면분석이 반응의 최적점을 찾는 실험이고 최적점의 위치는 알 수 없으므로 모든 방향에 대한 예측값의 정도를 동일하게 설정하는 것이 합리적이기 때문이다.\n2차 다항식도 선형모형에 속하므로 다음과 같은 선형모형을 고려할 때\n\\[\\pmb  y = \\pmb  X \\pmb  \\beta + \\pmb  e\\]\n최소제곱법으로 얻은 회귀계수의 추정량을 \\(\\hat {\\pmb  \\beta}\\) 이라고 하자. 만약 관심이 있는 실험점 \\(\\pmb  x\\) 에서 반응값의 예측치는 \\(\\hat y = {\\pmb  x}^t  \\hat {\\pmb  \\beta}\\) 이다. 또한 예측치의 분산은 다음과 같이 주어진다.\n\\[Var (\\hat y) = Var (\\hat y|\\pmb  x) = \\sigma^2 {\\pmb  x}^t (\\pmb  X^t \\pmb  X)^{-1} {\\pmb  x}\\] “중심합성설계가 회전 가능하다”는 의미는 실험에서 사용한 모든 실험점들에서 반응변수 예측치의 분산이 동일하다는 것을 의미한다.\n\\[\nVar (\\hat y|\\pmb  x_i) =   Var (\\hat y|\\pmb  x_j)  \\quad \\text{ for all } i,j\n\\tag{7.22}\\]\n이렇게 실험에서 고려한 모든 실험점에서 예측치의 분산이 같은 실험계획을 ‘회전가능하다’(rotatable) 라고 말하며 일반적으로 균등 정밀 중심합성설계(uniform precision CCD)라고 부른다.\n중심합성설계가 회전가능하게 되는 조건은 무었일까? 일반적으로 2차 실험에서 추가되는 축점의 길이 \\(\\alpha\\)에 따라서 회전가능성이 결정된다. 상자점의 수가 \\(F\\)개 인 경우 회전 가능한 계획을 얻기 위해서는 축점의 길이를 \\(\\alpha= F^{1/4}\\) 로 설정하면 된다.\n다음은 요인의 개수 \\(k\\) 에 대한 균등 정밀 중심합성설계의 각 실험점의 개수와 축점의 길이 \\(\\alpha\\)를 나타낸 표이다.\n\n\n표 9.4. 균등 정밀 중심합성설계의 각 실험점의 개수와 축점의 거리\n\n\n\n\n\n\n\n\n\n\n\n\\(k\\)\n2\n3\n4\n5\n6\n7\n\n\n\n\n\\(F=2^k\\)\n4\n8\n16\n32\n64\n128\n\n\n\\(n_a=2k\\)\n4\n6\n8\n10\n12\n14\n\n\n\\(n_0\\)\n\\(n_0\\)\n\\(n_0\\)\n\\(n_0\\)\n\\(n_0\\)\n\\(n_0\\)\n\\(n_0\\)\n\n\n\\(\\alpha = F^{1/4}\\)\n1.414\n1.682\n2.000\n2.378\n2.828\n3.363\n\n\n\n교과서 표 9.5 에 오타가 있습니다. 위의 표가 수정된 실험점의 개수와 축점의 거리입니다.\n참고로 중심점 \\((0,0)\\) 에서의 실험의 수 \\(n_0\\) 는 일반적으로 3개에서 5개이다.\n\n\n\n\n\n\n노트\n\n\n\n구형 계획법\n반응표면분석에서 회전 가능한 계획법은 실험에서 고려한 모든 실험점들의 분산을 같게 하는 실험계획이다. 하지만 실제 현장에서는 분산이 모두 동일한 경우 보다는 모든 실험점이 원점에서 같은 거리에 있는 경우를 선호하는 경우도 있다.\n고려한 모든 실험점이 중심점으로부터 거리가 동일한 계획을 구형 계획법(spherical design)이라고 한다. 요인의 개수가 \\(k\\) 개인 경우, 구형 계획법에서 축점의 거리는 \\(\\alpha=\\sqrt{k}\\) 이다.\n\n\n\n\n7.6.4 Box-Benken 설계\nBox-Benken 설계는 2차 모형 적합을 위한 효율적인 3수준 실험설계로 3수준 요인배치법의 일부 실험조건에서만 실험을 실시하는 것이다.\n예를 들어 3개의 요인가 있다면 관심영역 상자점에서 2개의 요인를 먼저 선택하고 \\(2^2\\) 개의 \\((\\pm 1, \\pm1)\\) 수준에서 실험을 하고 나머지 인자는 수준의 중앙값인 0으로 고정한다.\n이렇게 고려하는 인자의 개수가 \\(k\\) 개인 경우, 2개의 인자를 선택하는 조합의 수는 \\(k(k-1)/2\\) 개이다. 또한 각 조합마다 4개의 실험점\\((\\pm 1, \\pm1)\\) 이 추가되므로 총 실험점의 개수는 다음과 같다.\n\\[ 4k(k-1)/2 + n_0 \\]\nBox-Benken 설계는 선택된 2개의 조합이 블럭으로 나타나는 블럭 일부실시법이다.\n\n\n\n\n\n요인의 개수가 3개 인 경우 Box-Benken 설계\n\n\n\n\n\n\n7.6.5 계획법에 따른 실험점의 개수\n요인의 개수가 \\(k\\) 개인 경우 각 실험계획법에 대한 실험점의 개수는 다음의 표에 있는 공식으로 계산할 수 있다. \\(n_c\\) 는 중심점 \\((0,0)\\) 에서 실험의 개수이다(앞 절에서는 중심점을 \\(n_0\\) 로 표시).\n\n\n\n\n\n\n\n\n\n요인의 수\nBox-Benken 설계\n중심합성설계(CCD)\n3수준 요인 배치법\n\n\n\n\nk\n\\(4k(k-1)/2 + n_c\\)\n\\(2^k+2k + n_c\\)\n\\(3^k\\)\n\n\n\n\n\n\n\n\n계획법에 따른 실험점의 개수 예제\n\n\n\n\n\n\n7.6.6 R 을 이용한 실험계획\n\n7.6.6.1 회전가능 중심합성설계\n요인의 개수가 \\(k=3\\) 이고 중심점에서 실험의 개수가 \\(n_0=2\\) 인 회전가능 중심합성설계의 실험점을 패키지 rsm 의 함수 ccd() 를 통하여 구해보자.\n함수 ccd()를 사용하는 경우 인자는 다음과 같다.\n\nbasis = 3 : 요인의 개수(\\(k\\))를 3개로 지정\nn0 = 2 : 중심점의 수 (\\(n_0\\)) 를 2개로 지정\nalpha = \"rotatable\" : 회전 가능한 계획의 축점을 지정\nrandomize = F : 실험의 순서를 임의화하지 않는다.\n\n함수 ccd()의 결과를 볼 때 주의할 점은 다음과 같다.\n\n실험점들은 2개의 블럭(Block)으로 나누어 표시된다.\n첫 번째 블럭(Block=1)은 1차 모형을 적합하기 위한 상자점과 중심점으로 구성된다.\n두 번째 블럭(Block=2)은 2차 모형을 적합하기 위한 축점과 중심점으로 구성된다.\n따라서 중심점의 총 개수는 지정한 개수 n0 = 2 의 2배가 된다.\n\n\ndesignR &lt;- ccd (basis = 3, n0 = 2, alpha = \"rotatable\", randomize = F)\ndesignR\n\n   run.order std.order  x1.as.is  x2.as.is  x3.as.is Block\n1          1         1 -1.000000 -1.000000 -1.000000     1\n2          2         2  1.000000 -1.000000 -1.000000     1\n3          3         3 -1.000000  1.000000 -1.000000     1\n4          4         4  1.000000  1.000000 -1.000000     1\n5          5         5 -1.000000 -1.000000  1.000000     1\n6          6         6  1.000000 -1.000000  1.000000     1\n7          7         7 -1.000000  1.000000  1.000000     1\n8          8         8  1.000000  1.000000  1.000000     1\n9          9         9  0.000000  0.000000  0.000000     1\n10        10        10  0.000000  0.000000  0.000000     1\n11         1         1 -1.681793  0.000000  0.000000     2\n12         2         2  1.681793  0.000000  0.000000     2\n13         3         3  0.000000 -1.681793  0.000000     2\n14         4         4  0.000000  1.681793  0.000000     2\n15         5         5  0.000000  0.000000 -1.681793     2\n16         6         6  0.000000  0.000000  1.681793     2\n17         7         7  0.000000  0.000000  0.000000     2\n18         8         8  0.000000  0.000000  0.000000     2\n\nData are stored in coded form using these coding formulas ...\nx1 ~ x1.as.is\nx2 ~ x2.as.is\nx3 ~ x3.as.is\n\n\n교과서 표 9.4에 나타난 실험계획에 대한 데이터프레임을 만드는 방법은 아래와 같다. 참고할 점은 중심점의 수를 6개로 지정하면(n0=6) 모두 12개의 중심점이 생성되므로 마지막 6개의 중심점은 자료에 포함시키지 않는다.\n\ndesign94 &lt;- ccd (basis = 3, n0 = 6, alpha = \"rotatable\", randomize = F)\ndesign94\n\n   run.order std.order  x1.as.is  x2.as.is  x3.as.is Block\n1          1         1 -1.000000 -1.000000 -1.000000     1\n2          2         2  1.000000 -1.000000 -1.000000     1\n3          3         3 -1.000000  1.000000 -1.000000     1\n4          4         4  1.000000  1.000000 -1.000000     1\n5          5         5 -1.000000 -1.000000  1.000000     1\n6          6         6  1.000000 -1.000000  1.000000     1\n7          7         7 -1.000000  1.000000  1.000000     1\n8          8         8  1.000000  1.000000  1.000000     1\n9          9         9  0.000000  0.000000  0.000000     1\n10        10        10  0.000000  0.000000  0.000000     1\n11        11        11  0.000000  0.000000  0.000000     1\n12        12        12  0.000000  0.000000  0.000000     1\n13        13        13  0.000000  0.000000  0.000000     1\n14        14        14  0.000000  0.000000  0.000000     1\n15         1         1 -1.681793  0.000000  0.000000     2\n16         2         2  1.681793  0.000000  0.000000     2\n17         3         3  0.000000 -1.681793  0.000000     2\n18         4         4  0.000000  1.681793  0.000000     2\n19         5         5  0.000000  0.000000 -1.681793     2\n20         6         6  0.000000  0.000000  1.681793     2\n21         7         7  0.000000  0.000000  0.000000     2\n22         8         8  0.000000  0.000000  0.000000     2\n23         9         9  0.000000  0.000000  0.000000     2\n24        10        10  0.000000  0.000000  0.000000     2\n25        11        11  0.000000  0.000000  0.000000     2\n26        12        12  0.000000  0.000000  0.000000     2\n\nData are stored in coded form using these coding formulas ...\nx1 ~ x1.as.is\nx2 ~ x2.as.is\nx3 ~ x3.as.is\n\ny&lt;-c(7.6,7.9,8.9,7.1,10.2,7.8,11.9,8.3,11.5,11.2,13.8,10.7,11,10.9,10.8,6,7.9,\n     7.3,5,9.8)\ndata94 &lt;- cbind(data.frame(design94)[1:20,3:5], y)\ndata94\n\n          x1        x2        x3    y\n1  -1.000000 -1.000000 -1.000000  7.6\n2   1.000000 -1.000000 -1.000000  7.9\n3  -1.000000  1.000000 -1.000000  8.9\n4   1.000000  1.000000 -1.000000  7.1\n5  -1.000000 -1.000000  1.000000 10.2\n6   1.000000 -1.000000  1.000000  7.8\n7  -1.000000  1.000000  1.000000 11.9\n8   1.000000  1.000000  1.000000  8.3\n9   0.000000  0.000000  0.000000 11.5\n10  0.000000  0.000000  0.000000 11.2\n11  0.000000  0.000000  0.000000 13.8\n12  0.000000  0.000000  0.000000 10.7\n13  0.000000  0.000000  0.000000 11.0\n14  0.000000  0.000000  0.000000 10.9\n15 -1.681793  0.000000  0.000000 10.8\n16  1.681793  0.000000  0.000000  6.0\n17  0.000000 -1.681793  0.000000  7.9\n18  0.000000  1.681793  0.000000  7.3\n19  0.000000  0.000000 -1.681793  5.0\n20  0.000000  0.000000  1.681793  9.8\n\n\n\n\n7.6.6.2 Box-Benken 설계\n요인의 개수가 \\(k=3\\) 이고 중심점에서 실험의 개수가 \\(n_0=2\\) 인 Box-Benken 설계의 실험점을 패키지 rsm 의 함수 bbd() 를 통하여 구해보자 (교과서 표 9.6).\n함수 bbd()를 사용하는 경우 인자는 다음과 같다.\n\nk = 3 : 요인의 개수(\\(k\\))를 3개로 지정\nn0 = 2 : 중심점의 수 (\\(n_0\\)) 를 2개로 지정\nrandomize = F : 실험의 순서를 임의화하지 않는다.\n\n\ndesignBB &lt;- bbd ( k= 3, n0 = 2,  randomize = F)\ndesignBB\n\n   run.order std.order x1.as.is x2.as.is x3.as.is\n1          1         1       -1       -1        0\n2          2         2        1       -1        0\n3          3         3       -1        1        0\n4          4         4        1        1        0\n5          5         5       -1        0       -1\n6          6         6        1        0       -1\n7          7         7       -1        0        1\n8          8         8        1        0        1\n9          9         9        0       -1       -1\n10        10        10        0        1       -1\n11        11        11        0       -1        1\n12        12        12        0        1        1\n13        13        13        0        0        0\n14        14        14        0        0        0\n\nData are stored in coded form using these coding formulas ...\nx1 ~ x1.as.is\nx2 ~ x2.as.is\nx3 ~ x3.as.is",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "qmd/response.html#example",
    "href": "qmd/response.html#example",
    "title": "7  반응표면 분석",
    "section": "7.7 이차반응표면분석 사례",
    "text": "7.7 이차반응표면분석 사례\n\n7.7.1 개요\n\n교과서 9.6 절의 반응표면분석 사례 예제\n교과서에서는 Design Expert 프로그램을 사용하였지만 본 강의노트에서는 R 의 rsm 패키지를 사용하여 사례 분석\n\n\n\n7.7.2 실험의 목적과 개요\n빵을 포장하는 비닐 봉지의 접착력 \\(y\\) 을 가장 크게 하는 마감 공정의 조건을 찾는 실험을 수행하려고 한다. 실험에서 고려하는 반응변수 \\(y\\) 는 접착력이고 설명변수는 3개를 고려하는데 변수의 정의, 고려하는 범위와 변환식는 다음과 같다.\n\n실험에서 고려하는 설명변수\n\n\n\n\n\n\n\n\n독립변수 이름\n설명(단위)\n관심 범위\n상자점 \\((-1,1)\\) 변환식\n\n\n\n\nT\n마감온도(섭씨 온도)\n(100, 140)\n\\(x_1 = (T-120)/20\\)\n\n\nC\n냉각온도(섭씨 온도)\n(5, 15)\n\\(x_2 = (C-10)/5\\)\n\n\nP\n폴리 에틸렌 첨가제의 양(%)\n(0.5, 1.7)\n\\(x_2 = (P-1.1)/(0.6)\\)\n\n\n\n반응표면분석은 다음과 같은 2차 모형을 고려하여 접착력을 최대로 하는 최적점을 찾으려고 한다.\n\\[\ny = \\beta_0 + \\sum_{i=1}^{3} \\beta_i x_i + \\sum_{i=1}^{3} \\beta_{ii} x^2_i +\n\\sum_{i=1}^{2} \\sum_{j=i+1}^3 \\beta_{ij} x_i x_j +e\n\\tag{7.23}\\]\n다음은 반응표면분석을 위한 패키지 rsm 에서 함수 rsm()을 이용하여 1차 또는 2차 다항모형을 적합하는 경우 사용되는 모형식의 종류와 설명이다.\n\n함수 rsm() 의 모형식\n\n\n\n\n\n\n\n\n모형식\n설명\n사용의 예\n식\n\n\n\n\nFO\nfirst-order, 1차 다항식\nFO(x1, x2, x3)\n\\(\\sum_{i=1}^{3} \\beta_i x_i\\)\n\n\nTWI\ntwo-way interaction, 두 변수의 상호작용\nTWI(x1,x2)\n\\(\\sum_{i=1}^{2} \\sum_{j=i+1}^3 \\beta_{ij} x_i x_j\\)\n\n\nPQ\npure quadratic , 제곱항\nPQ(x1)\n\\(\\sum_{i=1}^{3} \\beta_{ii} x^2_i\\)\n\n\nSO\nsecond-order, 2차 다항식\nSO(x1, x2, x3)\nall terms\n\n\n\n\n\n7.7.3 중심합성설계의 실험점 생성\n설명변수(요인)의 개수가 3개이며 회전가능한 중심합성설계를 사용한 실험점은 다음과 같이 ccd() 함수로 구할 수 있다.\n\nccd() 함수에서 독립 변수의 변환식을 지정할 수 있으며 실험점이 원래 변수(T, C, P)의 값으로 표시된다.\n중심점에서 6개의 실험을 하려고 한다. ccd() 함수는 지정된 n0 값보다 2배의 실험점을 생성하기 때문에 n0 = 6 를 사용하고 마지막 6개의 중심점을 제거하였다.\n\n\nmydesign0 &lt;- ccd(3, n0 = 6, alpha = \"rotatable\", randomize = F, coding =list(x1 ~ (T - 120)/20, x2 ~ (C - 10)/5, x3 ~ (P-1.1)/0.6))\nmydesign0\n\n   run.order std.order         T         C         P Block\n1          1         1 100.00000  5.000000 0.5000000     1\n2          2         2 140.00000  5.000000 0.5000000     1\n3          3         3 100.00000 15.000000 0.5000000     1\n4          4         4 140.00000 15.000000 0.5000000     1\n5          5         5 100.00000  5.000000 1.7000000     1\n6          6         6 140.00000  5.000000 1.7000000     1\n7          7         7 100.00000 15.000000 1.7000000     1\n8          8         8 140.00000 15.000000 1.7000000     1\n9          9         9 120.00000 10.000000 1.1000000     1\n10        10        10 120.00000 10.000000 1.1000000     1\n11        11        11 120.00000 10.000000 1.1000000     1\n12        12        12 120.00000 10.000000 1.1000000     1\n13        13        13 120.00000 10.000000 1.1000000     1\n14        14        14 120.00000 10.000000 1.1000000     1\n15         1         1  86.36414 10.000000 1.1000000     2\n16         2         2 153.63586 10.000000 1.1000000     2\n17         3         3 120.00000  1.591036 1.1000000     2\n18         4         4 120.00000 18.408964 1.1000000     2\n19         5         5 120.00000 10.000000 0.0909243     2\n20         6         6 120.00000 10.000000 2.1090757     2\n21         7         7 120.00000 10.000000 1.1000000     2\n22         8         8 120.00000 10.000000 1.1000000     2\n23         9         9 120.00000 10.000000 1.1000000     2\n24        10        10 120.00000 10.000000 1.1000000     2\n25        11        11 120.00000 10.000000 1.1000000     2\n26        12        12 120.00000 10.000000 1.1000000     2\n\nData are stored in coded form using these coding formulas ...\nx1 ~ (T - 120)/20\nx2 ~ (C - 10)/5\nx3 ~ (P - 1.1)/0.6\n\nmydesign &lt;- mydesign0[1:20,3:5]\nmydesign\n\n           T         C         P\n1  100.00000  5.000000 0.5000000\n2  140.00000  5.000000 0.5000000\n3  100.00000 15.000000 0.5000000\n4  140.00000 15.000000 0.5000000\n5  100.00000  5.000000 1.7000000\n6  140.00000  5.000000 1.7000000\n7  100.00000 15.000000 1.7000000\n8  140.00000 15.000000 1.7000000\n9  120.00000 10.000000 1.1000000\n10 120.00000 10.000000 1.1000000\n11 120.00000 10.000000 1.1000000\n12 120.00000 10.000000 1.1000000\n13 120.00000 10.000000 1.1000000\n14 120.00000 10.000000 1.1000000\n15  86.36414 10.000000 1.1000000\n16 153.63586 10.000000 1.1000000\n17 120.00000  1.591036 1.1000000\n18 120.00000 18.408964 1.1000000\n19 120.00000 10.000000 0.0909243\n20 120.00000 10.000000 2.1090757\n\nData are stored in coded form using these coding formulas ...\nx1 ~ (T - 120)/20\nx2 ~ (C - 10)/5\nx3 ~ (P - 1.1)/0.6\n\n\n\n\n7.7.4 실험자료 읽어오기\n이제 실제 실험을 수행하고 반응값인 접착력을 측정한 자료를 읽어보자. 측정한 자료는 화일 chap9_rsm.csv 에 저장되어 있으며 다음과 같이 자료를 읽어서 데이터프레임rsm_data 를 생성할 수 있다.\n주의할 점은 화일 chap9_rsm.csv 이 현재 작업 경로(working directory)에 있다고 가정한다. 현재 작업 경로에 화일이 없으면 화일의 전체 경로를 지정해주어야 한다.\n\nrsm_data0 &lt;- read.csv(here::here(\"data\",\"chap9_rsm.csv\"), header = T)\nrsm_data0\n\n           T         C         P    y\n1  100.00000  5.000000 0.5000000  7.6\n2  140.00000  5.000000 0.5000000  7.9\n3  100.00000 15.000000 0.5000000  8.9\n4  140.00000 15.000000 0.5000000  7.1\n5  100.00000  5.000000 1.7000000 10.2\n6  140.00000  5.000000 1.7000000  7.8\n7  100.00000 15.000000 1.7000000 11.9\n8  140.00000 15.000000 1.7000000  8.3\n9   86.36414 10.000000 1.1000000 10.8\n10 153.63586 10.000000 1.1000000  6.0\n11 120.00000  1.591036 1.1000000  7.9\n12 120.00000 18.408964 1.1000000  7.3\n13 120.00000 10.000000 0.0909243  5.0\n14 120.00000 10.000000 2.1090757  9.8\n15 120.00000 10.000000 1.1000000 11.5\n16 120.00000 10.000000 1.1000000 11.2\n17 120.00000 10.000000 1.1000000 13.8\n18 120.00000 10.000000 1.1000000 10.7\n19 120.00000 10.000000 1.1000000 11.0\n20 120.00000 10.000000 1.1000000 10.9\n\n\n이제 위의 표에서 제시된 변환식이 적용된 실험자료의 데이터프레임을 만들자.\n\nrsm_data &lt;- coded.data(rsm_data0, x1 ~ (T - 120)/20, x2 ~ (C - 10)/5, x3 ~ (P-1.1)/0.6)\nrsm_data\n\n           T         C         P    y\n1  100.00000  5.000000 0.5000000  7.6\n2  140.00000  5.000000 0.5000000  7.9\n3  100.00000 15.000000 0.5000000  8.9\n4  140.00000 15.000000 0.5000000  7.1\n5  100.00000  5.000000 1.7000000 10.2\n6  140.00000  5.000000 1.7000000  7.8\n7  100.00000 15.000000 1.7000000 11.9\n8  140.00000 15.000000 1.7000000  8.3\n9   86.36414 10.000000 1.1000000 10.8\n10 153.63586 10.000000 1.1000000  6.0\n11 120.00000  1.591036 1.1000000  7.9\n12 120.00000 18.408964 1.1000000  7.3\n13 120.00000 10.000000 0.0909243  5.0\n14 120.00000 10.000000 2.1090757  9.8\n15 120.00000 10.000000 1.1000000 11.5\n16 120.00000 10.000000 1.1000000 11.2\n17 120.00000 10.000000 1.1000000 13.8\n18 120.00000 10.000000 1.1000000 10.7\n19 120.00000 10.000000 1.1000000 11.0\n20 120.00000 10.000000 1.1000000 10.9\n\nData are stored in coded form using these coding formulas ...\nx1 ~ (T - 120)/20\nx2 ~ (C - 10)/5\nx3 ~ (P - 1.1)/0.6\n\n\n\n\n\n7.7.5 2차 다항식 모형의 적합\n\n7.7.5.1 모형의 적합\n이제 자료 rsm_data 에 대하여 식 식 7.23 으로 표현된 2차 선형모형을 적합해보자. 2차 다항식의 적합은 함수 rsm() 에서 SO(x1+x2+x3)를 사용한다.\n아래의 적합한 결과를 요약하면 다음과 같다.\n\n1차항(FO)은 x1 과 x2 가 유의하다.\n상호작용(TWI)은 모두 유의하지 않다.\n2차항(PQ)은 모두 유의하다.\n2차 다항식의 정준분석으로 3개의 고유값이 모두 음수이다 \\((-0.6064, -1.2442, -1.3711)\\)\n따라서 최적점은 반응변수가 최대가 되는 실험점이다.\n최적점은 원자료의 단위로 \\(T=100.86\\), \\(C=11.45\\), \\(P=1.52\\)이다.\n\n\nres2 &lt;- rsm(y ~ SO(x1, x2, x3), data = rsm_data)\nsummary(res2)\n\n\nCall:\nrsm(formula = y ~ SO(x1, x2, x3), data = rsm_data)\n\n            Estimate Std. Error t value  Pr(&gt;|t|)    \n(Intercept) 11.47992    0.47725 24.0542 3.508e-10 ***\nx1          -1.14028    0.31665 -3.6011  0.004839 ** \nx2           0.12382    0.31665  0.3910  0.703984    \nx3           1.08170    0.31665  3.4161  0.006590 ** \nx1:x2       -0.41250    0.41372 -0.9971  0.342252    \nx1:x3       -0.56250    0.41372 -1.3596  0.203816    \nx2:x3        0.21250    0.41372  0.5136  0.618665    \nx1^2        -0.86177    0.30825 -2.7957  0.018933 *  \nx2^2        -1.14462    0.30825 -3.7133  0.004019 ** \nx3^2        -1.21533    0.30825 -3.9427  0.002763 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nMultiple R-squared:  0.8553,    Adjusted R-squared:  0.725 \nF-statistic: 6.566 on 9 and 10 DF,  p-value: 0.003469\n\nAnalysis of Variance Table\n\nResponse: y\n                Df Sum Sq Mean Sq F value   Pr(&gt;F)\nFO(x1, x2, x3)   3 33.946 11.3153  8.2636 0.004630\nTWI(x1, x2, x3)  3  4.254  1.4179  1.0355 0.418243\nPQ(x1, x2, x3)   3 42.719 14.2397 10.3992 0.002037\nResiduals       10 13.693  1.3693                 \nLack of fit      5  7.065  1.4129  1.0658 0.472962\nPure error       5  6.628  1.3257                 \n\nStationary point of response surface:\n        x1         x2         x3 \n-0.9569885  0.2907543  0.6919092 \n\nStationary point in original units:\n         T          C          P \n100.860230  11.453771   1.515146 \n\nEigenanalysis:\neigen() decomposition\n$values\n[1] -0.6064157 -1.2442428 -1.3710551\n\n$vectors\n         [,1]       [,2]        [,3]\nx1  0.8054829 -0.3224169 -0.49723696\nx2 -0.3957602 -0.9171818 -0.04638263\nx3 -0.4411022  0.2341470 -0.86637408\n\n\n\n\n7.7.5.2 등고선과 3차원 그림\n이제 각 두 개의 요인에 대하여 적합된 2차 다항식 반응표면의 예측값을 등고선 그림과 3차원 그림으로 나타내어 보자.\n이 실험에서는 3개의 독립변수를 사용하였기 때문에 등고선 그림을 그리는 경우 2개의 변수를 사용해서 그려야 한다. 이 경우 나머지 독립변수의 값은 주어진 값으로 고정시켜야 한다. 함수 contour() 에서 at=summary(res2)$canonical$xs 는 두 독립변수를 축으로 그림을 그릴때 나머지 독립변수의 값을 최적점으로 지정해주는 옵션이다.\n\nsummary(res2)$canonical$xs # 최적실험점\n\n        x1         x2         x3 \n-0.9569885  0.2907543  0.6919092 \n\npar(mar = c(4, 4, .1, .1))\ncontour (res2, ~ x1+x2+x3, image = TRUE, at=summary(res2)$canonical$xs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npar(mar = c(4, 4, .1, .1))\npersp(res2, x2~x1, col = rainbow(50))\npersp(res2, x3~x1, col = rainbow(50))\npersp(res2, x3~x2, col = rainbow(50))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n7.7.6 변수 선택\n앞에서 2차 다항식의 모형을 적합한 경우 상호작용 효과가 유의하지 않았다. 이제 2차 다항식 모형을 lm() 함수를 이용하여 적합한 후에 함수 step()을 이용하여 후방제거법(backward elimination)으로 변수 선택을 실행해 보자. step() 에서는 별도로 지정하지 않으면 AIC(Akaike Information Criteria)에 의한 최적 모형을 선택해 준다.\n2차 다항식 모형을 lm() 함수로 적합하는 경우는 상호작용과 2차식을 모두 모형식에 아래와 같이 포함시켜주어야 한다.\n후방제거법(backward elimination)을 실행한 결과 다음과 같은 모형이 최종적으로 선택되었다.\n\\[ y= \\beta_0 + \\beta_1 x_1 + \\beta_3 x_3 + \\beta_{13} x_1 x_3 + \\beta_{11} x_1^2 + \\beta_{22} x_2^2 + \\beta_{33} x_3^2 + e \\]\n\nres21 &lt;- lm(y~x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + I(x1^2) + I(x2^2) + I(x3^2), data=rsm_data)\nsummary(res21)\n\n\nCall:\nlm.default(formula = y ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + \n    I(x1^2) + I(x2^2) + I(x3^2), data = rsm_data)\n\nResiduals:\n     Min       1Q   Median       3Q      Max \n-1.22327 -0.50492 -0.07776  0.31191  2.32008 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  11.4799     0.4773  24.054 3.51e-10 ***\nx1           -1.1403     0.3166  -3.601  0.00484 ** \nx2            0.1238     0.3166   0.391  0.70398    \nx3            1.0817     0.3166   3.416  0.00659 ** \nI(x1^2)      -0.8618     0.3082  -2.796  0.01893 *  \nI(x2^2)      -1.1446     0.3082  -3.713  0.00402 ** \nI(x3^2)      -1.2153     0.3082  -3.943  0.00276 ** \nx1:x2        -0.4125     0.4137  -0.997  0.34225    \nx1:x3        -0.5625     0.4137  -1.360  0.20382    \nx2:x3         0.2125     0.4137   0.514  0.61866    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 1.17 on 10 degrees of freedom\nMultiple R-squared:  0.8553,    Adjusted R-squared:  0.725 \nF-statistic: 6.566 on 9 and 10 DF,  p-value: 0.003469\n\nstep(res21 , direction = \"backward\")\n\nStart:  AIC=12.42\ny ~ x1 + x2 + x3 + x1:x2 + x1:x3 + x2:x3 + I(x1^2) + I(x2^2) + \n    I(x3^2)\n\n          Df Sum of Sq    RSS    AIC\n- x2:x3    1    0.3613 14.054 10.944\n- x1:x2    1    1.3613 15.054 12.319\n&lt;none&gt;                 13.693 12.423\n- x1:x3    1    2.5313 16.224 13.816\n- I(x1^2)  1   10.7026 24.396 21.973\n- I(x2^2)  1   18.8809 32.574 27.756\n- I(x3^2)  1   21.2857 34.979 29.180\n\nStep:  AIC=10.94\ny ~ x1 + x2 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + x1:x2 + x1:x3\n\n          Df Sum of Sq    RSS    AIC\n- x1:x2    1    1.3613 15.416 10.793\n&lt;none&gt;                 14.054 10.944\n- x1:x3    1    2.5313 16.586 12.256\n- I(x1^2)  1   10.7026 24.757 20.267\n- I(x2^2)  1   18.8809 32.935 25.976\n- I(x3^2)  1   21.2857 35.340 27.386\n\nStep:  AIC=10.79\ny ~ x1 + x2 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + x1:x3\n\n          Df Sum of Sq    RSS     AIC\n- x2       1    0.2094 15.625  9.0627\n&lt;none&gt;                 15.416 10.7929\n- x1:x3    1    2.5312 17.947 11.8336\n- I(x1^2)  1   10.7026 26.118 19.3379\n- I(x2^2)  1   18.8809 34.296 24.7862\n- I(x3^2)  1   21.2857 36.701 26.1416\n\nStep:  AIC=9.06\ny ~ x1 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + x1:x3\n\n          Df Sum of Sq    RSS     AIC\n&lt;none&gt;                 15.625  9.0627\n- x1:x3    1    2.5312 18.156 10.0656\n- I(x1^2)  1   10.7026 26.327 17.4976\n- I(x2^2)  1   18.8809 34.506 22.9079\n- I(x3^2)  1   21.2857 36.911 24.2553\n\n\n\nCall:\nlm.default(formula = y ~ x1 + x3 + I(x1^2) + I(x2^2) + I(x3^2) + \n    x1:x3, data = rsm_data)\n\nCoefficients:\n(Intercept)           x1           x3      I(x1^2)      I(x2^2)      I(x3^2)  \n    11.4799      -1.1403       1.0817      -0.8618      -1.1446      -1.2153  \n      x1:x3  \n    -0.5625  \n\n\n\n\n7.7.7 최종모형 선택\n\n7.7.7.1 최종모형의 선택과 적합\n앞에서 후방제거법(backward elimination)을 실행한 결과에서 주 효과 \\(x_2\\) 가 제외되었지만 2차항 \\(x_2^2\\) 이 선택되었으므로 주 효과 \\(x_2\\) 도 최종 모형에 포함시킨다.\n\\[\ny= \\beta_0 + \\beta_1 x_1 + \\beta_2 x_2 + \\beta_3 x_3 + \\beta_{13} x_1 x_3 + \\beta_{11} x_1^2 + \\beta_{22} x_2^2 + \\beta_{33} x_3^2 + e\n\\tag{7.24}\\]\n따라서 위에서 고려한 최종모형 식 7.24 을 선택하여 반응표면 분석을 다시 실행해 보자.\n\n최종모형의 정준분석으로 3개의 고유값이 모두 음수이다 \\((-0.7064, -1.1446, -1.3707)\\)\n따라서 최적점은 반응변수가 최대가 되는 실험점이다.\n최종모형에서 최적점은 원자료의 단위로 \\(T=102.55\\), \\(C=10.27\\), \\(P=1.49\\)이다.\n\n\nfinalres &lt;- rsm(y ~ FO(x1, x2, x3) + TWI(x1, x3) + PQ(x1,x2,x3), data = rsm_data)\nsummary(finalres)\n\n\nCall:\nrsm(formula = y ~ FO(x1, x2, x3) + TWI(x1, x3) + PQ(x1, x2, x3), \n    data = rsm_data)\n\n            Estimate Std. Error t value  Pr(&gt;|t|)    \n(Intercept) 11.47992    0.46226 24.8343 1.099e-11 ***\nx1          -1.14028    0.30670 -3.7179  0.002938 ** \nx2           0.12382    0.30670  0.4037  0.693534    \nx3           1.08170    0.30670  3.5269  0.004170 ** \nx1:x3       -0.56250    0.40072 -1.4037  0.185750    \nx1^2        -0.86177    0.29856 -2.8864  0.013667 *  \nx2^2        -1.14462    0.29856 -3.8337  0.002379 ** \nx3^2        -1.21533    0.29856 -4.0706  0.001552 ** \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nMultiple R-squared:  0.8371,    Adjusted R-squared:  0.742 \nF-statistic: 8.807 on 7 and 12 DF,  p-value: 0.0006411\n\nAnalysis of Variance Table\n\nResponse: y\n               Df Sum Sq Mean Sq F value   Pr(&gt;F)\nFO(x1, x2, x3)  3 33.946 11.3153  8.8082 0.002327\nTWI(x1, x3)     1  2.531  2.5313  1.9704 0.185750\nPQ(x1, x2, x3)  3 42.719 14.2397 11.0847 0.000896\nResiduals      12 15.416  1.2846                 \nLack of fit     7  8.787  1.2553  0.9469 0.543851\nPure error      5  6.628  1.3257                 \n\nStationary point of response surface:\n         x1          x2          x3 \n-0.87274297  0.05408589  0.64699393 \n\nStationary point in original units:\n         T          C          P \n102.545141  10.270429   1.488196 \n\nEigenanalysis:\neigen() decomposition\n$values\n[1] -0.7063571 -1.1446152 -1.3707412\n\n$vectors\n         [,1] [,2]      [,3]\nx1  0.8752577    0 0.4836569\nx2  0.0000000    1 0.0000000\nx3 -0.4836569    0 0.8752577\n\n\n\n\n7.7.7.2 등고선과 3차원 그림\n이제 적합된 최종모형에서 각 두 개의 요인에 대하여 반응표면의 예측값을 등고선 그림과 3차원 그림으로 나타내어 보자.\n\npar(mar = c(4, 4, .1, .1))\ncontour (finalres, ~ x1+x2+x3, image = TRUE, at=summary(finalres)$canonical$xs)\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\npar(mar = c(4, 4, .1, .1))\npersp(finalres, x2~x1, col = rainbow(50))\npersp(finalres, x3~x1, col = rainbow(50))\npersp(finalres, x3~x2, col = rainbow(50))\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMontgomery, Douglas C. 2017. Design and analysis of experiments. John wiley & sons.",
    "crumbs": [
      "<span class='chapter-number'>7</span>  <span class='chapter-title'>반응표면 분석</span>"
    ]
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Montgomery, Douglas C. 2017. Design and Analysis of\nExperiments. John wiley & sons.\n\n\nSchabenberger, Oliver, and Francis J Pierce. 2001. Contemporary\nStatistical Models for the Plant and Soil Sciences. CRC press.\n\n\n임용빈. 2020. Design Expert, Minitab 과 R을 활용한 실험계획법.\n자유아카데미.",
    "crumbs": [
      "References"
    ]
  },
  {
    "objectID": "qmd/visual.html",
    "href": "qmd/visual.html",
    "title": "부록 A — R을 이용한 자료의 시각화 비교",
    "section": "",
    "text": "A.1 두 개 모집단의 비교",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R`을 이용한 자료의 시각화 비교</span>"
    ]
  },
  {
    "objectID": "qmd/visual.html#두-개-모집단의-비교",
    "href": "qmd/visual.html#두-개-모집단의-비교",
    "title": "부록 A — R을 이용한 자료의 시각화 비교",
    "section": "",
    "text": "A.1.1 예제 2.2 자료\n교재 2장의 예제 2.2 에서 소개된 인장 강도의 자료는 시멘트 공장의 2개의 생산라인에서 생산된 시멘트의 인장 강도를 측정한 것이다. 분석의 목적은 2개의 생산라인의 분포가 동일한지를 비교하는 것이다.\n먼저 R로 데이터프레임(data.frame)으로 만들어 보자. 예제 자료를 line1 과 line2 의 벡터 형식으로 만들고 data.frame의 형식인 df0에 저장하려면 다음과 같은 명령어를 사용하면 된다.\n\nline1 &lt;- c(16.9, 16.4, 17.2, 16.4, 16.5, 17.0, 17.0, 17.2, 16.6, 16.6)\nline2 &lt;- c(16.6, 16.8, 17.4, 17.1, 17.0, 16.9, 17.3, 17.0, 17.1, 17.3)\ndf220 &lt;- data.frame(line1, line2)\ndf220\n\n   line1 line2\n1   16.9  16.6\n2   16.4  16.8\n3   17.2  17.4\n4   16.4  17.1\n5   16.5  17.0\n6   17.0  16.9\n7   17.0  17.3\n8   17.2  17.0\n9   16.6  17.1\n10  16.6  17.3\n\n\ndata.frame 인 df0에는 각 그룹(line1과 line2)에 대한 10개의 자료가 2개의 열(column)에 각각 저장되어 있다. 이러한 자료의 형태를 넓은 형태의 자료(wide-format data)라고 부른다.\n위에서 만든 데이터프레임 df0 를 변형하여 반응값들을 하나의 변수(strength)로 합치고, 집단을 나타내는 변수 line를 생성하여 다른 형태의 데이터프레임 df를 다음과 같이 만들어 보자. 아래와 같은 형태의 자료를 좁은 형태의 자료(narrow-format data)라고 부른다. 넓은 형태보다 좁은 형태의 자료가 통계적 분석을 적용하기 편하다.\n\n# convert wide format to long format\ndf22&lt;- df220 %&gt;% pivot_longer(cols = everything(), names_to = \"line\", values_to = \"strength\") %&gt;% dplyr::arrange(line)\n\ndf22\n\n# A tibble: 20 × 2\n   line  strength\n   &lt;chr&gt;    &lt;dbl&gt;\n 1 line1     16.9\n 2 line1     16.4\n 3 line1     17.2\n 4 line1     16.4\n 5 line1     16.5\n 6 line1     17  \n 7 line1     17  \n 8 line1     17.2\n 9 line1     16.6\n10 line1     16.6\n11 line2     16.6\n12 line2     16.8\n13 line2     17.4\n14 line2     17.1\n15 line2     17  \n16 line2     16.9\n17 line2     17.3\n18 line2     17  \n19 line2     17.1\n20 line2     17.3\n\n\n\n\nA.1.2 기술 통계량에 의한 요약 - 넓은 형태의 자료\n넓은 형태의 자료 df0에 대한 요약통계(평균, 중앙값, 사분위수, 최소, 최대 등)를 다음과 같이 summary 함수를 이용하여 구하고 집단간의 차이를 비교할 수 있다.\n\nsummary(df220)\n\n     line1           line2      \n Min.   :16.40   Min.   :16.60  \n 1st Qu.:16.52   1st Qu.:16.93  \n Median :16.75   Median :17.05  \n Mean   :16.78   Mean   :17.05  \n 3rd Qu.:17.00   3rd Qu.:17.25  \n Max.   :17.20   Max.   :17.40  \n\n\n\n\nA.1.3 기술 통계량에 의한 요약 - 좁은 형태의 자료\n좁은 형태의 자료 df에 대해서는 다음과 같이 먼저 group_by함수로 집단을 구별하는 변수를 지정한다. 그 다음으로 summarise함수를 이용하여 여러 가지 통계량를 집단별로 계산할 수 있다.\n\ndf22 %&gt;% group_by(line)  %&gt;%  summarise(mean=mean(strength), median= median(strength), sd=sd(strength), min=min(strength), max=max(strength))\n\n# A tibble: 2 × 6\n  line   mean median    sd   min   max\n  &lt;chr&gt; &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 line1  16.8   16.8 0.316  16.4  17.2\n2 line2  17.0   17.0 0.246  16.6  17.4\n\n\n\n\nA.1.4 집단 자료에 대한 시각화\n다음으로 각 집단별로 상자그림(boxplot)을 그려서 자료의 중심과 퍼진 정도를 그림으로 비교해 보자. 위에서 좁은 형태로 구성된 자료에 대하여 다음과 같은 명령어로 상자그림을 집단별로 그릴 수 있다.\n\nwith(df22, boxplot(strength~line))\n\n\n\n\n\n\n\n\n패키지 ggplot2를 사용하면 좀 더 멋진 상자그림으로 시각화를 할 수 있다.\n\nggplot(df22, aes(line, strength)) +  geom_boxplot()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R`을 이용한 자료의 시각화 비교</span>"
    ]
  },
  {
    "objectID": "qmd/visual.html#세-개-이상의-모집단의-비교",
    "href": "qmd/visual.html#세-개-이상의-모집단의-비교",
    "title": "부록 A — R을 이용한 자료의 시각화 비교",
    "section": "A.2 세 개 이상의 모집단의 비교",
    "text": "A.2 세 개 이상의 모집단의 비교\n\nA.2.1 예제 3.1 자료\n4개의 서로 다른 원단업체에서 직물을 공급받고 있다. 공급한 직물의 긁힘에 대한 저항력을 알아보기 위하여 각 업체마다 4개의 제품을 랜덤하게 선택하여 일원배치법에 의하여 마모도 검사을 실시하였다. 자료는 다음과 같다.\n\ncompany&lt;- as.factor(rep(c(1:4), each=4))\nresponse&lt;- c(1.93, 2.38, 2.20, 2.25,\n             2.55, 2.72, 2.75, 2.70,\n             2.40, 2.68, 2.32, 2.28,\n             2.33, 2.38, 2.28, 2.25)\ndf31&lt;- data.frame(company=company, response= response)\ndf31\n\n   company response\n1        1     1.93\n2        1     2.38\n3        1     2.20\n4        1     2.25\n5        2     2.55\n6        2     2.72\n7        2     2.75\n8        2     2.70\n9        3     2.40\n10       3     2.68\n11       3     2.32\n12       3     2.28\n13       4     2.33\n14       4     2.38\n15       4     2.28\n16       4     2.25\n\n\n\n\nA.2.2 기술 통계량에 의한 요약\n\ndf31s &lt;- df31 %&gt;% group_by(company)  %&gt;%  summarise(mean=mean(response), median= median(response), sd=sd(response), min=min(response), max=max(response))\ndf31s\n\n# A tibble: 4 × 6\n  company  mean median     sd   min   max\n  &lt;fct&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1        2.19   2.22 0.189   1.93  2.38\n2 2        2.68   2.71 0.0891  2.55  2.75\n3 3        2.42   2.36 0.180   2.28  2.68\n4 4        2.31   2.30 0.0572  2.25  2.38\n\n\n\n\nA.2.3 집단 자료에 대한 시각화\n\nggplot(df31, aes(company, response)) +  geom_boxplot()\n\n\n\n\n\n\n\n\n\nggplot(df31, aes(company, response)) +\n  geom_boxplot() + \n  geom_line(data=df31s, aes(x=company, y=mean, group=1), size=1.5, col=\"#9ACBF9\") +\n  geom_point(data=df31s, aes(x=company, y=mean), col=\"darkblue\", size=3) +\n  theme_bw()",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>A</span>  <span class='chapter-title'>`R`을 이용한 자료의 시각화 비교</span>"
    ]
  },
  {
    "objectID": "qmd/linear.html",
    "href": "qmd/linear.html",
    "title": "부록 B — 일원배치 모형과 최소제곱법",
    "section": "",
    "text": "B.1 최소제곱법과 제약조건\n이제 일원배치법에 대한 통계적 모형에서 모수에 대한 추정을 생각해 보자.\n\\[\ny_{ij} = \\mu + \\alpha_i + e_{ij}\n\\tag{B.1}\\]\n추정해야할 모수는 전체 평균 \\(\\mu\\)와 각 그룹의 처리 효과 \\(\\alpha_i\\) 그리고 분산 \\(\\sigma_E^2\\)이다. 전체 평균과 그룹의 효과는 오차제곱합(Sum of Square Error; SSE)을 최소로 하는 모수를 추정하는 최소제곱법(Least Square method; LS)으로 구할 수 있다.\n\\[\n\\min_{\\mu, \\alpha_1, \\dots \\alpha_a} \\sum_{i=1}^a \\sum_{j=1}^r\n(y_{ij} - \\mu -\\alpha_i)^2 = \\min_{\\mu, \\alpha_1, \\dots \\alpha_a} SSE\n\\tag{B.2}\\]\n위의 오차제곱합이 모든 모수에 대하여 미분가능한 이차식으므로 최소제곱 추정량은 제곱합을 모수에 대하여 미분하고 0 으로 놓아 방정식을 풀어서 얻을 수 있다.\n오차제곱합을 모수 \\(\\mu\\)와 \\(\\alpha_1,\\alpha_2,\\dots,\\alpha_a\\) 로 미분하여 0 으로 놓은 방정식은 다음과 같다.\n\\[\n\\begin{aligned}\n& \\pardifftwo{}{\\mu} SSE = -2 \\sum_{i=1}^a \\sum_{j=1}^r (y_{ij} - \\mu -\\alpha_i) = 0 \\\\\n& \\pardifftwo{}{\\alpha_i} SSE = -2 \\sum_{j=1}^r (y_{ij} - \\mu -\\alpha_i) = 0 , \\quad i=1,2,\\dots, a\n\\end{aligned}\n\\]\n위의 방정식을 정리하면 다음과 같은 \\(a+1\\)개의 방정식을 얻는다.\n\\[\n\\begin{aligned}\n   \\mu +\\frac{ \\sum_{i=1}^a \\alpha_i}{a} & = \\bar {\\bar y}\\\\\n   \\mu + \\alpha_1  & =  \\bar {y}_{1.} \\\\\n   \\mu + \\alpha_2  & =  \\bar {y}_{2.} \\\\\n         \\cdots & \\cdots \\\\\n   \\mu + \\alpha_a  & =  \\bar {y}_{a.} \\\\\n\\end{aligned}\n\\tag{B.3}\\]\n위의 방정식에서 첫 번째 방정식은 다른 \\(a\\)개의 방정식을 모두 합한 방정식과 같다. 따라서 모수는 \\(a+1\\)개이지만 실제 방정식의 개수는 \\(a\\)개이므로 유일한 해가 얻어지지 않는다. 따라서 유일한 해를 구하려면 하나의 제약조건이 필요하며 일반적으로 다음과 같은 두 개의 조건 중 하나를 사용한다.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>일원배치 모형과 최소제곱법</span>"
    ]
  },
  {
    "objectID": "qmd/linear.html#최소제곱법과-제약조건",
    "href": "qmd/linear.html#최소제곱법과-제약조건",
    "title": "부록 B — 일원배치 모형과 최소제곱법",
    "section": "",
    "text": "B.1.1 set-to-zero condition\n첫 번째 효과 \\(\\alpha_1\\)를 0으로 놓는 조건을 주는 것이다 (\\(\\alpha_1=0\\)). set-to-zero 조건 하에서는 다음과 같은 추정량이 얻어진다.\n\\[\n\\hat \\mu = \\bar {y}_{1.}, \\quad \\hat \\alpha_1=0, ~~  \\hat \\alpha_i = \\bar {y}_{i.} -\\bar {y}_{1.},~~i=2,\\dots,a\n\\tag{B.4}\\]\n\n\nB.1.2 sum-to-zero condition\n처리들의 효과의 합은 0이라는 조건을 주는 것이다 ( \\(\\sum_{i=1}^a  \\alpha_i=0\\)). sum-to-zero 조건에서는 계수의 추정치가 다음과 같이 주어진다.\n\\[\n\\hat \\mu = \\bar {\\bar {y}}, \\quad \\hat \\alpha_i = \\bar {y}_{i.} -\\bar {\\bar {y}},~~i=1,2,\\dots,a\n\\tag{B.5}\\]\n여기서 유의할 점은 개별 모수들의 추정량은 조건에 따라서 달라지지만 집단의 평균을 나타내는 모수 \\(\\mu+ \\alpha_i\\) 에 대한 추정량은 언제나 같다.\n\\[ \\widehat{\\mu+ \\alpha_i} = \\hat \\mu + \\hat {\\alpha}_i =  \\bar {y}_{i.} \\]\n만약에 자료를 아래와 같은 평균 모형으로 나타낼 경우에는 각 평균 \\(\\mu_i\\) 는 각 그룹의 표본 평균으로 추정된다.\n\\[ y_{ij} = \\mu_i + e_{ij} \\]\n평균 모형에서 각 그룹의 모평균에 대한 최소제곱 추정량은 \\(\\hat \\mu_i = \\bar {y}_{i.}\\) 이며 이는 주효과 모형에서의 추정량과 동일하다.\n또한 모형에 관계없이 오차항의 분산 \\(\\sigma_E^2\\) 에 대한 추정량은 다음과 같이 주어진다.\n\\[\\begin{equation*}\n\\hat \\sigma_E^2 = \\frac{ \\sum_i \\sum_j (y_{ij} - \\hat \\mu -\\hat \\alpha_i )^2}{a(r-1)}\n\\end{equation*}\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>일원배치 모형과 최소제곱법</span>"
    ]
  },
  {
    "objectID": "qmd/linear.html#선형모형과-제약-조건",
    "href": "qmd/linear.html#선형모형과-제약-조건",
    "title": "부록 B — 일원배치 모형과 최소제곱법",
    "section": "B.2 선형모형과 제약 조건",
    "text": "B.2 선형모형과 제약 조건\n일원배치 모형 식 B.1 를 다음과 같은 벡터를 이용한 선형모형(linear regression model) 형태로 나타내고자 한다.\n\\[\n\\pmb y = \\pmb X \\pmb \\beta +\\pmb e\n\\tag{B.6}\\]\n위의 선형모형식의 요소 \\(\\pmb y\\), \\(\\pmb X\\), \\(\\pmb \\beta\\), \\(\\pmb e\\)는 다음과 같은 벡터와 행렬로 표현된다.\n\\[\n\\begin{bmatrix}\ny_{11} \\\\\ny_{12} \\\\\n\\vdots \\\\\ny_{1r} \\\\\ny_{21} \\\\\ny_{22} \\\\\n\\vdots \\\\\ny_{2r} \\\\\n\\vdots \\\\\ny_{a1} \\\\\ny_{a2} \\\\\n\\vdots \\\\\ny_{ar} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 1 & 0 & . & . & 0 \\\\\n1 & 1 & 0 & . & . & 0 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 1 & 0 & . & . & 0 \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{1} \\\\\n\\alpha_{2} \\\\\n\\vdots \\\\\n\\alpha_{a} \\\\\n\\end{bmatrix} +\n\\begin{bmatrix}\ne_{11} \\\\\ne_{12} \\\\\n\\vdots \\\\\ne_{1r} \\\\\ne_{21} \\\\\ne_{22} \\\\\n\\vdots \\\\\ne_{2r} \\\\\n\\vdots \\\\\ne_{a1} \\\\\ne_{a2} \\\\\n\\vdots \\\\\ne_{ar} \\\\\n\\end{bmatrix}\n\\tag{B.7}\\]\n이제 위에서 논의한 최소제곱법을 선형 모형 식 B.6 에 적용하면 다음과 같이 표현할 수 있다.\n\\[\n\\min_{\\mu, \\alpha_1, \\dots \\alpha_a} \\sum_{i=1}^a \\sum_{j=1}^r\n(y_{ij} - \\mu -\\alpha_i)^2 = \\min_{\\pmb \\beta } ( \\pmb y -  \\pmb X \\pmb \\beta )^t( \\pmb y -  \\pmb X \\pmb \\beta )\n\\tag{B.8}\\]\n최소제곱법의 기준을 만족하는 계수 \\(\\pmb \\beta\\)는 다음과 같은 정규방정식(normal equation)의 해(solution)이다.\n\\[\n\\pmb X^t \\pmb X \\pmb \\beta = \\pmb X^t \\pmb y\n\\tag{B.9}\\]\n정규방정식 식 B.9 을 일워배치의 선형모형식 식 B.7 에 나타난 \\(\\pmb y\\), \\(\\pmb X\\)로 이용하여 나타내면 다음과 같다.\n\\[\n\\begin{bmatrix}\nar   & r & r & \\cdot & \\cdot & r \\\\\nr & r &  0  & \\cdot & \\cdot & 0 \\\\\nr & 0   & r  & \\cdot & \\cdot & 0 \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\nr & 0   &  0   & \\cdot & \\cdot & r \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{1} \\\\\n\\alpha_{2} \\\\\n\\cdot \\\\\n\\cdot \\\\\n\\alpha_{a} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nar \\bar {\\bar y} \\\\\nr {\\bar y}_{1.}\\\\\nr \\bar y_{2.}\\\\\n\\cdot \\\\\n\\cdot \\\\\nr \\bar y_{a.}\n\\end{bmatrix}\n\\tag{B.10}\\]\n정규방정식 식 B.10 는 위에서 구한 최소제곱법에서 유도된 방정식 식 B.3 과 같다.\n여기서 유의할 점은 선형모형식 식 B.7 의 계획행렬 \\(\\pmb X\\) 가 완전 계수(full rank) 행렬이 아니다. 계획행렬 \\(\\pmb X\\)의 첫 번째 열은 다른 열을 합한 것과 같다. 또한 정규 방정식 식 B.10 에서 \\(\\pmb X^t \\pmb X\\) 행렬도 완전계수 행렬이 아니다. 따라서 \\(\\pmb X^t \\pmb X\\) 행렬의 역행렬은 존재하지 않는다.\n이러한 이유로 모수에 대한 유일한 추정량이 존재하지 않기 때문에 앞에서 언급한 제약 조건을 고려해야 정규방정식을 풀 수 있다.\n\nB.2.1 Set-to-zero 조건에서의 모형과 최소제곱 추정량\n만약 Set-to-zero 조건을 가정한다면 모수에서 \\(\\alpha_1\\)을 제외하고 선형모형식 식 B.7 를 다음과 같이 다시 표현할 수 있다.\n효과 \\(\\alpha_1\\)을 0 으로 놓는다는 것은 \\(\\alpha_1\\)을 추정할 필요가 없으므로 모수벡터 \\(\\pmb \\beta\\) 에서 \\(\\alpha_1\\)를 빼고 게획행렬에서도 대응하는 열을 제거하는 것이다.\n\\[\n\\begin{bmatrix}\ny_{11} \\\\\ny_{12} \\\\\n\\vdots \\\\\ny_{1r} \\\\\ny_{21} \\\\\ny_{22} \\\\\n\\vdots \\\\\ny_{2r} \\\\\n\\vdots \\\\\ny_{a1} \\\\\ny_{a2} \\\\\n\\vdots \\\\\ny_{ar} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 &  0 & . & . & 0 \\\\\n1 &  0 & . & . & 0 \\\\\n1 &  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 &  0 & . & . & 0 \\\\\n1 &  1 & . & . & 0 \\\\\n1 &  1 & . & . & 0 \\\\\n1 &  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 &  1 & . & . & 0 \\\\\n\\vdots &  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 &  0 & . & . & 1 \\\\\n1 &  0 & . & . & 1 \\\\\n1 &  \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 &  0 & . & . & 1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{2} \\\\\n\\alpha_{3} \\\\\n\\vdots \\\\\n\\alpha_{a} \\\\\n\\end{bmatrix} +\n\\begin{bmatrix}\ne_{11} \\\\\ne_{12} \\\\\n\\vdots \\\\\ne_{1r} \\\\\ne_{21} \\\\\ne_{22} \\\\\n\\vdots \\\\\ne_{2r} \\\\\n\\vdots \\\\\ne_{a1} \\\\\ne_{a2} \\\\\n\\vdots \\\\\ne_{ar} \\\\\n\\end{bmatrix}\n\\tag{B.11}\\]\n이제 수정된 모형식 식 B.11 에 최소제곱법을 적용하여 정규방정식을 구하면 다음과 같은 방정식을 얻는다.\n\\[\n\\begin{bmatrix}\nar   & r & r & \\cdot & \\cdot & r \\\\\nr & r &  0  & \\cdot & \\cdot & 0 \\\\\nr & 0   & r  & \\cdot & \\cdot & 0 \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\nr & 0   &  0   & \\cdot & \\cdot & r \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{2} \\\\\n\\alpha_{3} \\\\\n\\cdot \\\\\n\\cdot \\\\\n\\alpha_{a} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nar \\bar {\\bar y} \\\\\nr {\\bar y}_{2.}\\\\\nr \\bar y_{3.}\\\\\n\\cdot \\\\\n\\cdot \\\\\nr \\bar y_{a.}\n\\end{bmatrix}\n\\tag{B.12}\\]\n위의 정규방정 식 B.12 를 풀면 위에서 언급한 sum-to-zero 조건에서 구해지는 모수의 추정량 식 B.4 를 얻을 수 있다.\n\n\nB.2.2 Sum-to-zero 조건에서의 모형과 최소제곱 추정량\n이제 Sum-to-zero 조건에서 모수의 추정에 대해 알아보자. 조건 \\(\\sum_{i=1}^a \\alpha_i =0\\) 조건을 마지막 모수 \\(\\alpha_a\\)에 대하여 표현하면 다음과 같다.\n\\[ \\alpha_a = -\\alpha_1 - \\alpha_2 - \\dots - \\alpha_{a-1} \\]\n따라서 마지막 처리 \\(\\alpha_a\\) 에 대한 관측값에 대한 모형은 다음과 같아 쓸 수 있다.\n\\[ y_{aj} = \\mu + \\alpha_a + e_{aj} = \\mu +( -\\alpha_1 - \\alpha_2 - \\dots - \\alpha_{a-1}) + e_{ij} \\]\n이러한 결과를 모형방정식에 반영한다. 즉, 모수벡터 \\(\\pmb \\beta\\) 에서 \\(\\alpha_a\\)를 제거하고 게획행렬에 위의 마지막 처리에 대한 효과식을 반영하면 다음과 같은 선형모형식을 얻는다.\n\\[\n\\begin{bmatrix}\ny_{11} \\\\\ny_{12} \\\\\n\\vdots \\\\\ny_{1r} \\\\\ny_{21} \\\\\ny_{22} \\\\\n\\vdots \\\\\ny_{2r} \\\\\n\\vdots \\\\\ny_{a1} \\\\\ny_{a2} \\\\\n\\vdots \\\\\ny_{ar} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\n1 & 1 & 0 & . & . & 0 \\\\\n1 & 1 & 0 & . & . & 0 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 1 & 0 & . & . & 0 \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 1 & . & . & 0 \\\\\n\\vdots & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & 0 & 0 & . & . & 1 \\\\\n1 & -1 & -1 & . & . & -1 \\\\\n1 & -1 & -1 & . & . & -1 \\\\\n1 & \\vdots & \\vdots & \\vdots & \\vdots & \\vdots \\\\\n1 & -1 & -1 & . & . & -1 \\\\\n1 & -1 & -1 & . & . & -1 \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{1} \\\\\n\\alpha_{2} \\\\\n\\vdots \\\\\n\\alpha_{a-1} \\\\\n\\end{bmatrix} +\n\\begin{bmatrix}\ne_{11} \\\\\ne_{12} \\\\\n\\vdots \\\\\ne_{1r} \\\\\ne_{21} \\\\\ne_{22} \\\\\n\\vdots \\\\\ne_{2r} \\\\\n\\vdots \\\\\ne_{a1} \\\\\ne_{a2} \\\\\n\\vdots \\\\\ne_{ar} \\\\\n\\end{bmatrix}\n\\tag{B.13}\\]\n이제 수정된 모형식 식 B.13 에 최소제곱법을 적용하여 정규방정식을 구하면 다음과 같은 방정식을 얻는다.\n\\[\n\\begin{bmatrix}\nar   & 0 & 0 & \\cdot & \\cdot & 0 \\\\\n0 & 2r &  r  & \\cdot & \\cdot & r \\\\\n0 & r   & 2r  & \\cdot & \\cdot & r \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\n\\cdot & \\cdot   & \\cdot  & \\cdot & \\cdot & \\cdot \\\\\n0 & r   &  r   & \\cdot & \\cdot & 2r \\\\\n\\end{bmatrix}\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_{1} \\\\\n\\alpha_{2} \\\\\n\\cdot \\\\\n\\cdot \\\\\n\\alpha_{a-1} \\\\\n\\end{bmatrix}\n=\n\\begin{bmatrix}\nar \\bar {\\bar y} \\\\\nr {\\bar y}_{1.}-r {\\bar y}_{a.} \\\\\nr \\bar y_{2.}-r {\\bar y}_{a.}\\\\\n\\cdot \\\\\n\\cdot \\\\\nr \\bar y_{a-1,.} -r {\\bar y}_{a.}\n\\end{bmatrix}\n\\tag{B.14}\\]\n위의 정규방정 식 B.14 를 풀면 위에서 언급한 sum-to-zero 조건에서 구해지는 모수의 추정량 식 B.5 를 얻을 수 있다.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>일원배치 모형과 최소제곱법</span>"
    ]
  },
  {
    "objectID": "qmd/linear.html#추정-가능한-함수",
    "href": "qmd/linear.html#추정-가능한-함수",
    "title": "부록 B — 일원배치 모형과 최소제곱법",
    "section": "B.3 추정 가능한 함수",
    "text": "B.3 추정 가능한 함수\n\nB.3.1 일원배치법에 추정가능한 모수\n앞 절에서 보았듯이 일원배치법을 선형 모형식으로 표현하는 경우 평균에 대한 모수는 모두 \\(a+1\\) 개가 있다.\n\\[ \\mu, \\alpha_1, \\alpha_2, \\cdots, \\alpha_a \\]\n하지만 모형식에서 계획행렬 \\(\\pmb X\\)가 완전 계수 행렬이 아니기 때문에 1개의 제약 조건을 가정하고 모수를 추정하였다. 하지만 제약 조건이 달라지면 각 모수의 추정량이 달라지기 때문에 각 모수는 유일한 값으로 추정이 불가능하다.\n이렇게 각 모수들은 제약 조건에 따라서 유일하게 추정이 불가능하지만 앞 절에서 보았듯이 \\(\\mu + \\alpha_i\\) 에 대한 추정량은 제약조건에 관계없이 표본 평균 \\(\\bar y_{i.}\\)으로 동일하게 추정되어 진다.\n그러면 어떤 모수들은 유일하게 추정이 불가능하고 어떤 모수들이 유일하게 추정이 가능할까?\n이제 제약조건이 달라도 유일하게 추정이 가능한 모수들의 형태를 살펴보자.\n\n\nB.3.2 추정가능한 모수의 함수\n선형모형 \\(\\pmb y =\\pmb X \\pmb \\beta + \\pmb e\\) 에서 계획행렬 \\(\\pmb X\\)의 계수가 완전하지 않으면 모수 벡터 \\(\\pmb \\beta\\)는 유일한 값으로 추정할 수 없다.\n이제 임의의 벡터 \\(\\pmb c\\)가 있을 때 모수들의 선형결합 \\(\\psi = \\pmb c^t \\pmb \\beta\\)를 고려하자.\n예를 들어 일원배치 모형에서는 다음과 같은 모수들의 선형결합을 고려하는 것이다.\n\\[ \\psi = \\pmb c^t \\pmb \\beta =\n[ c_0~ c_1~ c_2~ \\cdots~~c_a]\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_1 \\\\\n\\alpha_2 \\\\\n\\vdots \\\\\n\\alpha_a\n\\end{bmatrix}\n=c_0 \\mu + c_1 \\alpha_1 + c_2 \\alpha_2 + \\cdots + c_a \\alpha_a \\]\n위에서 본 것처럼 하나의 모수 \\(\\alpha_1\\)에 대한 유일한 추정은 불가능하다.\n\\[  \\alpha_1 = (0) \\mu + (1) \\alpha_1 + (0) \\alpha_2 + \\cdots + (0) \\alpha_a \\]\n하지만 모수의 조합 \\(\\mu+ \\alpha_2\\) 은 유일한 추정이 가능하다.\n\\[  \\mu + \\alpha_1 = (1) \\mu + (1) \\alpha_1 + (0) \\alpha_2 + \\cdots + (0) \\alpha_a \\]\n이제 문제는 선형조합 \\(\\psi= \\pmb c^t \\pmb \\beta\\) 에서 계수들 \\(c_0, c_1, \\dots, c_a\\)가 어떤 값을 가지는 경우 유일한 추정이 가능한 지 알아내는 것이다.\n이제 \\(\\psi = \\pmb c^t \\pmb \\beta\\) 에 대한 유일한 추정량 \\(\\hat \\psi\\) 이 있다고 가정하자. 선형 모형에서 추정량 \\(\\hat \\psi\\)의 형태는 관측값에 대한 선형함수가 되어야 한다. 따라서 추정량을 \\(\\hat \\psi = \\pmb a^t \\pmb y\\) 로 나타낼 수 있다. 이제 추정량 \\(\\hat \\psi\\)의 기대값은 \\(\\psi=\\pmb c^t \\pmb \\beta\\)이어야 하므로 다음이 성립해야 한다.\n\\[ E(\\hat \\psi| \\pmb X) = E(\\pmb a^t \\pmb y| \\pmb X) = \\pmb a^t E(\\pmb y| \\pmb X) = \\pmb a^t \\pmb X \\pmb \\beta = \\pmb c^t \\pmb \\beta \\]\n위의 식에서 가장 마지막 두 항의 관계를 보면 다음이 성립해야 한다.\n\\[\n\\pmb a^t \\pmb X = \\pmb c^t  \\quad \\text{ equivalently }\\quad \\pmb c = \\pmb X^t \\pmb a\n\\tag{B.15}\\]\n즉 추정가능한 모수의 조합 \\(\\psi = \\pmb c^t \\pmb \\beta\\)에서 계수 벡터 \\(\\pmb c\\) 는 계획행렬에 있는 행들의 선형 조합으로 표시되어야 한다는 것이다. 이렇게 유일하게 추정이 가능한 모수의 조합을 추정가능한 함수(estimable function)이라고 한다.\n\n\nB.3.3 예제\n2개의 수준이 있고 반복이 2번 있는 일원배치 \\((a=2,r=2)\\) 에 대한 선형모형 ?eq-lm2을 생각해보자. 이 경우 계획행렬 \\(\\pmb X\\) 과 모수벡터 \\(\\pmb \\beta\\) 는 다음과 같다.\n\\[\n\\pmb X =\n\\begin{bmatrix}\n1 & 1 & 0  \\\\\n1 & 1 & 0  \\\\\n1 & 0 & 1  \\\\\n1 & 0 & 1  \n\\end{bmatrix}\n\\quad\n\\pmb \\beta =\n\\begin{bmatrix}\n\\mu \\\\\n\\alpha_1 \\\\\n\\alpha_2\n\\end{bmatrix}\n\\]\n이제 유일하게 추정 가능한 모수 조합 \\(\\psi\\) 은 어떤 형태일까?\n\\[ \\psi = \\pmb c^t \\pmb \\beta = c_0 \\mu + c_1 \\alpha_1 + c_2 \\alpha_2 \\]\n위의 식 식 B.15 에서 추정가능한 모수의 조합에 대한 계수 벡터 \\(\\pmb c\\) 는 다음과 같은 조건을 만족해야 한다.\n\\[ \\pmb c = {\\pmb X}^t \\pmb a \\]\n이제 임의의 벡터 \\(\\pmb a\\) 에 대하여 \\(\\pmb c= \\pmb X^t \\pmb a\\)의 형태를 보자.\n\\[\n\\begin{aligned}\n\\pmb c &=\n\\pmb X^t \\pmb a \\\\ & =\n\\begin{bmatrix}\n1 & 1 & 1 & 1  \\\\\n1 & 1 & 0 & 0  \\\\\n0 & 0 & 1 & 1  \n\\end{bmatrix}\n\\begin{bmatrix}\na_1 \\\\\na_2 \\\\\na_3 \\\\\na_4\n\\end{bmatrix} \\\\\n& =\na_1\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\na_2\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\na_3\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n+\na_4\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix} \\\\\n& =\n(a_1 + a_2)\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\n(a_3 + a_4)\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix} \\\\\n&=\nb_1\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\nb_2\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n\\end{aligned}\n\\tag{B.16}\\]\n이제 \\(\\pmb X^t \\pmb a\\) 는 계획행렬 \\(\\pmb X\\)에 있는 유일한 행들의 선형조합임을 알 수 있다.\n\n위의 식 식 B.16 에서 유의할 점은 벡터 \\(\\pmb a=[a_1 ~a_2~a_3~a_4]^t\\)는 임의로 주어진 벡터이다.\n식 식 B.16 에서 \\(a_1=1\\), \\(a_2=1\\) 인 경우는 \\(a_1=2\\), \\(a_2=0\\) 인 경우와 동일하다.\n\n따라서 유일하게 추정 가능한 모수의 선형조합 \\(\\psi = \\pmb c^t \\pmb \\beta\\) 에 대한 계수 벡터 \\(\\pmb c =[ c_0 ~ c_1 ~ c_2]^t\\) 는 계획행렬 \\(\\pmb X\\)의 유일한 행들의 선형 조합으로 구성되어야 한다.\n\\[\n\\pmb c =\n\\begin{bmatrix}\nc_0 \\\\\nc_1 \\\\\nc_2\n\\end{bmatrix}\n=\nb_1\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\nb_2\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n\\tag{B.17}\\]\n\n처리의 효과를 나타내는 모수 \\(\\alpha_i\\)는 추정이 불가능하다.\n\n첫 번째 처리에 대한 효과 모수 \\(\\alpha_1\\) 를 선형조합으로 나타내면\n\\[ \\alpha_1 = c_0 \\mu + c_1 \\alpha_1 + c_2 \\alpha_2 = (0) \\mu + (1) \\alpha_1 + (0) \\alpha_2 \\]\n따라서 조건 식 B.17 에서 \\(\\pmb c^t = [0~1~0]\\)을 만들수 있는 계수 \\(b_1\\)과 \\(b_2\\)를 찾아야 하는데 이는 불가능하다. 따라서 모수 \\(\\alpha_1\\) 은 추정 불가능하다.\n\\[\n\\pmb c =\n\\begin{bmatrix}\n0 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n=\nb_1\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\nb_2\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n\\]\n\n처리의 평균을 나타내는 모수의 조합 \\(\\mu + \\alpha_i\\)는 추정이 가능하다.\n\n모수 조합 \\(\\mu + \\alpha_1\\) 를 선형조합으로 나타내면\n\\[ \\mu + \\alpha_1 = c_0 \\mu + c_1 \\alpha_1 + c_2 \\alpha_2 = (1) \\mu + (1) \\alpha_1 + (0) \\alpha_2 \\]\n따라서 조건 식 B.17 에서 \\(\\pmb c^t = [1~1~0]\\)을 만들수 있는 계수는 \\(b_1=1\\)과 \\(b_2=0\\) 이므로 추정이 가능하다.\n\\[\n\\pmb c =\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n=\n(1)\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\n(0)\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n\\]\n\n처리 효과의 차이를 나타내는 모수의 조합 \\(\\alpha_1-\\alpha_2\\)는 추정이 가능하다.\n\n\\[ \\alpha_1 -\\alpha_2= c_0 \\alpha_0 + c_1 \\alpha_1 + c_2 \\alpha_2 = (0) \\pmb u + (1) \\alpha_1 + (-1) \\alpha_2 \\]\n따라서 조건 식 B.17 에서 \\(\\pmb c^t = [0~1~-1]\\)을 만들수 있는 계수는 \\(b_1=1\\)과 \\(b_2=-1\\) 이므로 추정이 가능하다.\n\\[\n\\pmb c =\n\\begin{bmatrix}\n0 \\\\\n1 \\\\\n-1\n\\end{bmatrix}\n=\n(1)\n\\begin{bmatrix}\n1 \\\\\n1 \\\\\n0\n\\end{bmatrix}\n+\n(-1)\n\\begin{bmatrix}\n1 \\\\\n0 \\\\\n1\n\\end{bmatrix}\n\\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>일원배치 모형과 최소제곱법</span>"
    ]
  },
  {
    "objectID": "qmd/linear.html#r-실습",
    "href": "qmd/linear.html#r-실습",
    "title": "부록 B — 일원배치 모형과 최소제곱법",
    "section": "B.4 R 실습",
    "text": "B.4 R 실습\n\nB.4.1 예제 3.1\n4개의 서로 다른 원단업체에서 직물을 공급받고 있다. 공급한 직물의 긁힘에 대한 저항력을 알아보기 위하여 각 업체마다 4개의 제품을 랜덤하게 선택하여 (\\(a=4\\), \\(r=4\\)) 일원배치법에 의하여 마모도 검사을 실시하였다.\n\n\nB.4.2 자료의 생성\n\ncompany&lt;- as.factor(rep(c(1:4), each=4))\nresponse&lt;- c(1.93, 2.38, 2.20, 2.25,\n             2.55, 2.72, 2.75, 2.70,\n             2.40, 2.68, 2.32, 2.28,\n             2.33, 2.38, 2.28, 2.25)\ndf31&lt;- data.frame(company=company, response= response)\ndf31\n\n   company response\n1        1     1.93\n2        1     2.38\n3        1     2.20\n4        1     2.25\n5        2     2.55\n6        2     2.72\n7        2     2.75\n8        2     2.70\n9        3     2.40\n10       3     2.68\n11       3     2.32\n12       3     2.28\n13       4     2.33\n14       4     2.38\n15       4     2.28\n16       4     2.25\n\n\n각 수준에 대한 표보 평균을 구해보자.\n\ndf31s &lt;- df31 %&gt;% group_by(company)  %&gt;%  summarise(mean=mean(response), median= median(response), sd=sd(response), min=min(response), max=max(response))\ndf31s\n\n# A tibble: 4 × 6\n  company  mean median     sd   min   max\n  &lt;fct&gt;   &lt;dbl&gt;  &lt;dbl&gt;  &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;\n1 1        2.19   2.22 0.189   1.93  2.38\n2 2        2.68   2.71 0.0891  2.55  2.75\n3 3        2.42   2.36 0.180   2.28  2.68\n4 4        2.31   2.30 0.0572  2.25  2.38\n\n\n\n\nB.4.3 선형모형의 적합(set-to-zero)\n이제 자료를 다음과 같은 선형 모형으로 적합해 보자. 선형 모형의 적합은 lm() 함수를 사용한다.\n\\[ y_{ij} = \\mu + \\alpha_i + e_{ij}  \\]\n여기서 선형식의 모수와 R의 변수는 다음과 같은 관계를 가진다,\n\n\n\n선형식의 모수\nR의 변수\n\n\n\n\n\\(\\mu\\)\n(Intercept)\n\n\n\\(\\alpha_1\\)\ncompany1\n\n\n\\(\\alpha_2\\)\ncompany2\n\n\n\\(\\alpha_3\\)\ncompany3\n\n\n\\(\\alpha_4\\)\ncompany4\n\n\n\n\nfit1 &lt;- lm(response~company,data=df31)\nsummary(fit1)\n\n\nCall:\nlm.default(formula = response ~ company, data = df31)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.2600 -0.0700  0.0150  0.0625  0.2600 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  2.19000    0.07050  31.062 7.79e-13 ***\ncompany2     0.49000    0.09971   4.914 0.000357 ***\ncompany3     0.23000    0.09971   2.307 0.039710 *  \ncompany4     0.12000    0.09971   1.204 0.251982    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.141 on 12 degrees of freedom\nMultiple R-squared:  0.6871,    Adjusted R-squared:  0.6089 \nF-statistic: 8.785 on 3 and 12 DF,  p-value: 0.002353\n\n\n위에서 적합한 결과를 보면 평균 \\(\\mu\\)와 4개의 처리 \\(\\alpha_1\\), \\(\\alpha_2\\), \\(\\alpha_3\\), \\(\\alpha_4\\) 가 모형에 있지만 모수의 추정량은 평균(intercept)과 3개의 모수(company2, company3, company4)만 추정량이 주어진다.\nR 에서 옵션을 지정하지 않고 함수 lm()으로 선형모형을 적합하는 경우 set-to-zero 조건을 적용하며 자료에 나타난 처리의 수준들 중 순위가 가장 낮은 수준의 효과를 0으로 지정한다 (company1=0 ). set-to-zero 조건을 강제로 지정하려면 다음과 같은 명령문을 먼저 실행한다.\noptions(contrasts=c(\"contr.treatment\", \"contr.poly\"))\n위의 결과를 보면 (Intercept)에 대한 추정량이 첫 번째 처리 company1의 평균과 같은 것을 알 수 있다.\nset-to-zero 조건에서의 계획행렬은 다음과 같이 볼 수 있다.\n\nmodel.matrix(fit1)\n\n   (Intercept) company2 company3 company4\n1            1        0        0        0\n2            1        0        0        0\n3            1        0        0        0\n4            1        0        0        0\n5            1        1        0        0\n6            1        1        0        0\n7            1        1        0        0\n8            1        1        0        0\n9            1        0        1        0\n10           1        0        1        0\n11           1        0        1        0\n12           1        0        1        0\n13           1        0        0        1\n14           1        0        0        1\n15           1        0        0        1\n16           1        0        0        1\nattr(,\"assign\")\n[1] 0 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$company\n[1] \"contr.treatment\"\n\n\n이제 각 처리 평균에 대한 추정값 \\(\\widehat{\\mu+ \\alpha_i}\\)을 구해보자.\n\nemmeans(fit1, \"company\")\n\n company emmean     SE df lower.CL upper.CL\n 1         2.19 0.0705 12     2.04     2.34\n 2         2.68 0.0705 12     2.53     2.83\n 3         2.42 0.0705 12     2.27     2.57\n 4         2.31 0.0705 12     2.16     2.46\n\nConfidence level used: 0.95 \n\n\n이 경우 처리 평균에 대한 추정값은 산술 평균과 동일하게 나온다.\n\n\nB.4.4 선형모형의 적합 (sum-to-zero)\n이제 일원배치 모형에서 sum-to-zero 조건을 적용하여 모수를 추정해 보자. sum-to-zero 조건을 적용하려면 다음과 같은 명령어를 실행해야 한다.\n\noptions(contrasts=c(\"contr.sum\", \"contr.poly\"))\n\n이제 다시 선형모형을 적합하고 추정결과를 보자.\n\nfit2 &lt;- lm(response~company,data=df31)\nsummary(fit2)\n\n\nCall:\nlm.default(formula = response ~ company, data = df31)\n\nResiduals:\n    Min      1Q  Median      3Q     Max \n-0.2600 -0.0700  0.0150  0.0625  0.2600 \n\nCoefficients:\n            Estimate Std. Error t value Pr(&gt;|t|)    \n(Intercept)  2.40000    0.03525  68.081  &lt; 2e-16 ***\ncompany1    -0.21000    0.06106  -3.439 0.004901 ** \ncompany2     0.28000    0.06106   4.586 0.000626 ***\ncompany3     0.02000    0.06106   0.328 0.748892    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\nResidual standard error: 0.141 on 12 degrees of freedom\nMultiple R-squared:  0.6871,    Adjusted R-squared:  0.6089 \nF-statistic: 8.785 on 3 and 12 DF,  p-value: 0.002353\n\n\n이제 sum-to-zero 조건에 따라서 위의 set-to-zero 결과와 모수의 추정값이 다르게 나타나는 것을 알 수 있다. 마지막 모수 company4(\\(\\alpha_4\\))는 sum-to-zero 조건을 이용하여 다음과 같은 관계를 이용하여 구할 수 있다.\n\\[  \\alpha_4 = -(\\alpha_1 + \\alpha_2 + \\alpha_3) \\]\nsum-to-zero 조건에서의 계획행렬은 다음과 같이 볼 수 있다.\n\nmodel.matrix(fit2)\n\n   (Intercept) company1 company2 company3\n1            1        1        0        0\n2            1        1        0        0\n3            1        1        0        0\n4            1        1        0        0\n5            1        0        1        0\n6            1        0        1        0\n7            1        0        1        0\n8            1        0        1        0\n9            1        0        0        1\n10           1        0        0        1\n11           1        0        0        1\n12           1        0        0        1\n13           1       -1       -1       -1\n14           1       -1       -1       -1\n15           1       -1       -1       -1\n16           1       -1       -1       -1\nattr(,\"assign\")\n[1] 0 1 1 1\nattr(,\"contrasts\")\nattr(,\"contrasts\")$company\n[1] \"contr.sum\"\n\n\n이제 각 처리 평균에 대한 추정값 \\(\\widehat{\\mu+ \\alpha_i}\\)을 구해보면 set-to-zero 조건에서의 추정값과 동일함을 알 수 있다.\n\nemmeans(fit2, \"company\")\n\n company emmean     SE df lower.CL upper.CL\n 1         2.19 0.0705 12     2.04     2.34\n 2         2.68 0.0705 12     2.53     2.83\n 3         2.42 0.0705 12     2.27     2.57\n 4         2.31 0.0705 12     2.16     2.46\n\nConfidence level used: 0.95 \n\n\n\n\nB.4.5 분산분석\n분산분석의 결과는 어떠한 제약 조건에서도 동일하다.\n\nres1 &lt;- anova(fit1)\nres1\n\nAnalysis of Variance Table\n\nResponse: response\n          Df Sum Sq  Mean Sq F value   Pr(&gt;F)   \ncompany    3 0.5240 0.174667  8.7846 0.002353 **\nResiduals 12 0.2386 0.019883                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n\nres2&lt;- anova(fit2)\nres2\n\nAnalysis of Variance Table\n\nResponse: response\n          Df Sum Sq  Mean Sq F value   Pr(&gt;F)   \ncompany    3 0.5240 0.174667  8.7846 0.002353 **\nResiduals 12 0.2386 0.019883                    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>B</span>  <span class='chapter-title'>일원배치 모형과 최소제곱법</span>"
    ]
  },
  {
    "objectID": "qmd/raneff.html",
    "href": "qmd/raneff.html",
    "title": "부록 C — 혼합 모형",
    "section": "",
    "text": "C.1 고정효과\n앞 장에서 하나의 요인있는 일원배치 모형에 대한 추론에 대하여 알아보있다.\n\\[\nx_{ij} = \\mu + \\alpha_i + e_{ij}\n\\tag{C.1}\\]\n여기서 오차항 \\(e_{ij}\\)는 모두 독립이며 \\(N(0,\\sigma_E^2)\\)를 따른다.\n일원배치 모형 식 C.1 에서 전체 평균 \\(\\mu\\) 와 처리수준의 효과를 나타내는 \\(\\alpha_1, \\alpha_2, \\dots, \\alpha_a\\)는 모두 고정된 값을 가지는 모수(parameter)이다. 식 C.1 의 오른쪽 항들 중에서 확률변수는 오차항 \\(e_{ij}\\)이 유일하다.\n처리수준의 효과 \\(\\alpha_i\\)들이 모수이라는 것은 의미는 만약 새로운 실험에서 실험단위(experiment unit)에 동일한 처리를 적용하면 평균 처리 효과는 \\(\\alpha_i\\)로 일정하다는 의미이다.\n예를 들어 예제 3.1에서 수행한 실험을 다른 회사에서 동일한 납품업체의 원단(동일한 실험 단위와 처리)을 가지고 새로운 실험을 하면 평균적인 효과는 예제 3.1과 동일하다는 가정을 할 수 있다. 물론 횩과는 동일하지만 설명할 수 없는오차떄문에 관측값은 다를 수 있다.\n또한 예제 4.1 에 대한 실험에서도 만약 동일한 돼지 품종과 사료를 사용하여 새로운 실험을 수행할 때 처리 효과는 원래 실험과 같다고 가정할 수 있다. 즉, 처리라는 것이 기술적인 의미를 지니고 있어 반복하여 재현할 수 있는 효과이다. 이러한 고정된 모수로서의 효과를 고정 효과(fixed effect)라고 부른다.\n더 나아가 고정효과를 가지는 모형에서는 고정효과를 추정하고 처리 수준간의 차이가 있는지 추론하는 것이 실험의 주요 목적이다.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>혼합 모형</span>"
    ]
  },
  {
    "objectID": "qmd/raneff.html#임의효과",
    "href": "qmd/raneff.html#임의효과",
    "title": "부록 C — 혼합 모형",
    "section": "C.2 임의효과",
    "text": "C.2 임의효과\n이제 고정효과와는 다른 의미를 가지는 몇 가지 실험들을 생각해 보자.\n\n\n보기 C.1 (화학약품 회사:교과서예제 3.3) 화학약품 회사에서는 매년 원자재의 수백 개의 배치(batch)를 정제하여 순도가 높은 화학약품을 만든다. 품질 관리를 위하여 수백 개의 배치들 중에서 5개를 랜덤하게 선택하고 배치당 3개의 시료를 채취한 후에 순도를 측정하였다.\n배치마다 순도가 크게 다르면 품질을 일정하게 유지할 수 없눈 문제가 생긴다. 따라서 실험의 목적은 품질 관리이며 배치 간의 변동과 배치 내의 변동을 알아보는 것이다.\n\n\n\n보기 C.2 (학교간의 성적 비교) 학교 간에 성적의 차이를 알아보기 위하여 서울에 있는 603개의 학교에서 20개의 학교를을 임의로 추출하고 추출된 학교에 속한 6학년 학생들 10명을 임의로 추출하여 과학시험을 보게 하여 점수를 얻었다.\n이러한 자료에서 학생들의 성적은 가장 점수가 낮은 학생부터 매우 우수한 성적을 낸 학생까지 점수의 변동(variation)이 존재한다. 변동의 요인은 무었일까? 학생의 개인의 차이(예:학생의 지능, 노력 정도, 학습 환경)도 변동의 요인이지만 또한 학교의 차이(예: 교사, 거주 환경)도 변동의 요인이 될 수 있다.\n\n\n\n보기 C.3 (Test-ReTest) 새로 개발된 CT 로 만든 영상에 근거하여 의사들이 암의 단계를 점수로 파악하는 방법이 제안되었다. 제안된 방법의 유료성과 안정성을 알아보기 위하여 실험을 진행하였다. 일단 5명의 암환자들에서 CT 영상을 쵤영하였다. 다음으로 15명의 의사를 임의로 추출하고 5명의 CT 영상을 본 후 암의 진행 단계를 판단할 수 있는 점수를 매기도록 하였다.\n실험의 목적은 CT 영상에 근거한 진단이 의사들간에 잘 일치하는지를 알아보는 실험이다. 이 실험에서는 의사와 환자라는 두 가지 요인이 존재한다.\n\n\n위의 예제에서 배치, 의사, 학교는 고정 효과를 가정한 실험에서 고려하는 요인과는 성격이 틀리다. 5개의 배치들은 수백 개의 배치들에서 임의로 추출 되었으며 5명의 의사들은 다수의 의사들 중 임의로 추출되었다. 603개 초등 학교의 모집단에서 20개의 학교가 임의로 추출되었다.\n배치, 의사 또는 학교 간의 차이는 잘 설계된 실험의 처리에 대한 고정 효과와는 다르다. 동일한 배치, 학교 또는 의사으로 부터 나온 관측값들은 동일한 처릴 받은 값들이라기 보다는 동일한 집단(group, cluster)에서 나온 관측값으로 볼 수 있다. 위의 예제들에서는 식 C.2 에서 효과 \\(\\alpha_i\\) 의 변동은 모집단을 구성하는 집단들의 변동이라고 할 수 있다.\n위에서 언급한 3개 예제는 실험의 목적이 선택된 수준들의 효과의 기술적인 비교가 아니라 모집단이 가지고 있는 여러 가지 변동(variance)에 대하여 추론하는 것이다.\n\n\n\n\n\n\n노트\n\n\n\n같은 학교에 다니는 학생들은 주거 환경, 교사 등 공통적인 요인에 의하여 영향을 받는다고 가정할 수 있다. 따라서 같은 학교에 다는 학생들의 성적이 독립이 아닐 수도 있다.\n깉은 의사가 5명의 환자에 대한 평가하여 진단을 한 경우 5개의 진단결과는 다른 환자에 대항 결과임에도 불구하고 서로 독립이라고 가정하지 않을 수 있다. 의사의 역량, 경험, 성향에 따라서 환자에 대한 진단에 공통적인 영향을 미칠 수 있기 때문이다.\n\n\n고정효과처럼 기술적인 처리효과가 아니라 모집단의 구성 단위들의 변동을 기술하는 효과를 임의효과(random effect, 변량) 라고 한다. 임의효과를 가진 일원배치 모형을 변량모형(random models) 또는 임의효과 모형(random effect models)이라고 부르며 다음과 같이 나타낼 수 있다.\n\\[\nx_{ij} = \\mu + \\alpha_i + e_{ij} \\quad \\text{ where } \\alpha_i \\sim N(0,\\sigma_A^2),~~ e_{ij} \\sim N(0,\\sigma_E^2)\n\\tag{C.2}\\]\n위의 식에서 \\(\\alpha_1, \\alpha_2, \\dots, \\alpha_a\\)를 임의 효과라고 부르며 서로 독립인 확률 변수로서 분포는 \\(N(0,\\sigma_A^2)\\)을 따른다. 또한 임의 효과 \\(\\alpha_i\\)와 오차항 \\(e_{ij}\\)은 서로 독립이다.\n임의효과가 가지는 분산을 \\(\\sigma_A^2\\)을 분산성분(variance component)라고 하며 집단 간의 변동을 의미한다. \\(\\sigma_A^2\\)이 크면 모집단을 구성하고 있는 단위들의 변동이 크다고 할 수 있다. 반면 \\(\\sigma_A^2\\)이 작으면 단위들간의 변동이 작아진다.\n그럼 효과를 어느 경우에 고정효과로 가정하는지? 또 임의효과로 가정하는 경우는 언제인지? 이러한 질문에 대하여 간단하고 명료한 대답은 없다. 많은 학자들이 이 문제에 대하여 다양한 설명을 내놓았는데 정답은 없다.\n심지어 다음과 같이 말한 학자도 있어요\n\n\n\n\n\n\n노트\n\n\n\nBefore proceeding further with random field linear models, we need to remind the reader of the adage that one modeler’s random effect is another modeler’s fixed effect.\nSchabenberger 와/과 Pierce (2001) (627 page)\n\n\n모형은 실제 현상이 어떻게 작동되는지 인간이 가진 제한적인 지식으로 간단한 수식과 분포 가정을 사용하여 기술하는 것이기 때문에 가정한 모형이 옳다 그르다를 판별하기 어렵다. G.P. Box 가 말했듯이 모형을 평가하는 가장 중요한 요소는 모형의 유용성일 것이다. 즉, 유용하지 않는 모형은 사람들이 금방 외면해 버릴 것이고 유용한 모형은 실제 자료를 예측하는데 도음을 주니 많은 사람들이 이용할 것이다.\n아직도 같은 자료에 대하여 고정효과와 임의효과 모형이 동시에 사용되고 있으니 두 모형 모두 유용하다고 할 수 있다. 하지만 두 효과에 대한 어느 정도 차이점은 알아야 한다. 지금까지 경험으로 고정효과와 임의효과의 대략적 의미와 차이점은 다음과 같습니다.\n\n고정효과\n\n기술적인 효과(technical effect)\n실험자가 기술적으로 반복하여 적용할 수 있는 효과\n평균 효과의 비교가 주 목적인 경우\n예를 들어 온도, 사료, 비료, 촉매 등등\n\n임의효과\n\n효과가 있는 것 같은데 기술적으로 명확한 설명이 어려운 효과 (Unobservable heterogeneity)\n숨겨진 변수 (latent variable )\n모집단에서 추출된 집단(group, cluster, repeated menasure)에 속하여 나타나는 효과 - 급내상관계수\n효과들의 변동에 관심있는 경우\n예를 들어 학교, 병원, 재배단위(plot) 등등",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>혼합 모형</span>"
    ]
  },
  {
    "objectID": "qmd/raneff.html#변량모형의-성질",
    "href": "qmd/raneff.html#변량모형의-성질",
    "title": "부록 C — 혼합 모형",
    "section": "C.3 변량모형의 성질",
    "text": "C.3 변량모형의 성질\n\nC.3.1 총변동의 분해\n일원배치 변량 모형 식 C.2 을 따르는는 반응변수 \\(x_{ij}\\)의 평균과 분산은 다음과 같다.\n\\[\n\\begin{aligned}\nE(x_{ij}) & = E(\\mu + \\alpha_i + e_{ij}) \\\\\n  & =E(\\mu) + E(\\alpha_i) + E(e_{ij})  \\\\\n  &= \\mu + 0 + 0 \\\\\n  & = \\mu\n\\end{aligned}\n\\] \\[\n\\begin{aligned}\nV(x_{ij}) & =Var(\\mu + \\alpha_i + e_{ij}) \\\\\n  & = V(\\alpha_i) + V(e_{ij}) \\\\\n  & = \\sigma^2_A + \\sigma^2_E\n\\end{aligned}\n\\tag{C.3}\\]\n식 C.3 에서 나타난 분해는 다음과 같이 의미로 표현할 수 있다.\n\\[\n\\underbrace{V(x_{ij})}_{\\text{total variation}} =  \\underbrace{\\sigma^2_A}_{\\text{variation between groups}} + \\underbrace{\\sigma^2_E}_{\\text{variation within group}}  \n\\]\n\n\nC.3.2 관측값의 종속성\n식 C.2 로 표현된 변량모형의 가장 큰 특징 중에 하나는 같은 집단에 속하는 관측치들은 서로 독립이 아니며 양의 상관관계가 있는 것이다. 예를 들어 위의 학교간의 성적 비교 예제에서 두 학생 \\(x_{ij}\\)와 \\(x_{ik}\\)이 같은 학교 \\(i\\)에 속한다면\n\\[\n\\begin{aligned}\nCov(x_{ij},x_{ik}) &  = Cov(  \\mu + \\alpha_i + e_{ij}, \\mu + \\alpha_i + e_{ik})  \\\\\n  & =Cov (\\alpha_i, \\alpha_i) + Cov( \\alpha_i, e_{ik}) + Cov( e_{ij}, \\alpha_i ) + Cov( e_{ij}, e_{ik}) \\\\\n  & = Cov (\\alpha_i, \\alpha_i) + 0 + 0 + 0 \\\\\n  & = V (\\alpha_i, \\alpha_i) \\\\\n  & = \\sigma^2_A\n\\end{aligned}\n\\]\n따라서 \\[\n\\begin{aligned}\ncorr(x_{ij},x_{ik}) & = \\frac{ Cov(x_{ij},x_{ik})}{\\sqrt{V(x_{ij}) ~V(x_{ik})} } \\\\\n& = \\frac{\\sigma^2_A }{\\sigma^2_A + \\sigma^2_E } \\\\\n& =\\rho\n\\end{aligned}\n\\]\n위의 상관계수(교과서애서 기여율)는 보통 급내 상관계수(Intra Class Correlation, ICC)라고 부른다. 그룹 변동의 크기를 나타내는 분산성분 \\(\\sigma^2_A\\)가 그룹 내 변동을 나타내는 오차항의 분산 \\(\\sigma^2_E\\)보다 상대적으로 클수록 급내 상관계수가 1에 가까와진다.\n보통 \\(\\sigma^2_A\\)을 집단간 변동(between-group variance)라 하고 \\(\\sigma^2_E\\)를 집단내 변동(within-group variance)라고 한다. 따라서 \\(\\sigma^2_A\\)와 \\(\\sigma^2_E\\)의 상대적인 크기의 차이에 따라 그룹내 관측값의 상관관계가 달라진다.\n\n\nC.3.3 제곱합의 기대값\n일원배치 변량 모형 식 C.2 은 고정효과 모형 식 C.1 과 동일한 분산분석(ANOVA) 표를 사용한다. 분산분석 표의 제곱합을 이용하여 \\(\\sigma^2_A\\)와 \\(\\sigma^2_E\\)에 대한 추정량을 얻을 수 있다.\n첫 째로 분산분석 표에서 \\(SS_E\\)의 기대값을 구해보자.\n먼저 다음과 같은 분해를 고려하자.\n\\[\n\\begin{aligned}\nx_{ij}-\\bar x_{i.} &= (\\mu + \\alpha_i + e_{ij}) -\\frac{ \\sum_{j=1}^r (\\mu + \\alpha_i + e_{ij})}{r} \\\\\n& = (\\mu + \\alpha_i + e_{ij})  - \\left (\\mu + \\alpha_i + \\frac{ \\sum_{j=1}^r e_{ij}}{r} \\right ) \\\\\n& = (\\mu + \\alpha_i + e_{ij}) -(\\mu + \\alpha_i + \\bar e_{i.}) \\\\\n&= e_{ij}-\\bar e_{i}\n\\end{aligned}\n\\]\n이므로 오차제곱합 \\(SS_E\\)의 기대값은 다음과 같이 구해진다.\n\\[\n\\begin{aligned}\nE \\left [ \\sum_{i=1}^a \\sum_{j=1}^r (x_{ij}-\\bar x_{i.})^2 \\right ]\n&= E \\left [ \\sum_{i=1}^a \\sum_{j=1}^r (e_{ij}-\\bar e_{i.}))^2 \\right ] \\\\\n&= (r-1) \\sum_{i=1}^a E \\left [ \\frac{   \\sum_{j=1}^r  (e_{ij}-\\bar e_{i.}))^2 }{r-1} \\right ] \\\\\n&= (r-1) \\sum_{i=1}^a \\sigma^2_E \\\\\n&= a(r-1) \\sigma^2_E\n\\end{aligned}\n\\]\n또한 \\(SS_A\\)의 기대값을 구하기 위하여\n\\[\n\\begin{aligned}\n\\bar x_{i.} -\\bar {\\bar x}  &= (\\mu + \\alpha_i + \\bar e_{i.}) -(\\mu + \\bar \\alpha + \\bar {\\bar e}) \\\\\n  & = (\\alpha_i -\\bar \\alpha) + (\\bar e_{i.}- \\bar {\\bar e})\n\\end{aligned}\n\\]\n이므로 \\(SS_A\\)의 기대값은 다음과 같이 구해진다.\n\\[\n\\begin{aligned}\nE \\left [ \\sum_{i=1}^a \\sum_{j=1}^r (\\bar x_{i.} -\\bar {\\bar x} )^2 \\right ]\n&= E \\left [ \\sum_{i=1}^a \\sum_{j=1}^r \\{(\\alpha_i -\\bar \\alpha) + (\\bar e_{i.}-\\bar {\\bar e})\\}^2 \\right ] \\\\\n&= \\sum_{i=1}^a \\sum_{j=1}^r E  [(\\alpha_i -\\bar \\alpha)^2 ] + \\sum_{i=1}^a \\sum_{j=1}^r E  [(\\bar e_{i.}- \\bar{\\bar e})^2 ]  \\\\\n&= r(a-1)E \\left  [    \\frac{\\sum_{i=1}^a(\\alpha_i -\\bar \\alpha)^2}{a-1} \\right ]\n+ r(a-1)   E \\left [ \\frac{\\sum_{i=1}^a(\\bar e_{i.}-\\bar{\\bar e})^2}{a-1} \\right ]  \\\\\n&= r(a-1) \\sigma^2_A + r(a-1)\\frac{\\sigma^2_E}{r} \\\\\n&= (a-1)(r\\sigma^2_A+ \\sigma^2_E) \\\\\n\\end{aligned}\n\\]\n위의 계산에서 이용한 사실은 \\(\\alpha_i\\)는 서로 독립으로 \\(N(0,\\sigma^2_A)\\)를 따르고 \\(\\bar e_{i.}\\)는 서로 독립으로 \\(N(0,\\sigma^2_E/r)\\)를 따른다는 것이다.\n위의 제곱합의 기대값을 정리해보면 다음과 같은 두 방정식을 얻는다.\n\\[\nE(SS_A) = (a-1)(r\\sigma^2_A+ \\sigma^2_E), \\quad E(SS_E) =  a(r-1) \\sigma^2_E\n\\]\n위의 모수 방정식에 적률추정법(methods of moment)을 적용하면 다음과 같은 방정식을 얻고\n\\[\nSS_A = (a-1)(r \\hat{\\sigma}^2_A+ \\hat{\\sigma}^2_E), \\quad SS_E =  a(r-1) \\hat{\\sigma}^2_E\n\\]\n위의 방정식을 풀면 \\(\\sigma^2_A\\)와 \\(\\sigma^2_E\\)의 불편 추정량을 구할 수 있다. 여기서 유의할 사항은 \\(\\sigma^2_A\\)에 대한 추정량은 0보다 작은 값이 나올 수 있으므로 이럴 경우 0으로 지정한다.\n\\[\n\\begin{aligned}\ns^2_E & = \\hat \\sigma^2_E = \\frac{SS_E}{a(r-1)} =MS_E\\\\\ns^2_A & = \\hat \\sigma^2_A = \\max \\left [ 0, \\frac{SS_A/(a-1) -\\hat \\sigma^2_E}{r} \\right ]\n=\\max \\left [ 0, \\frac{MS_A -MS_E}{r} \\right ]\n\\end{aligned}\n\\]\n\n\nC.3.4 가설 검정\n고정효과 모형에서 요인 \\(A\\)의 수준간에 차이가 있는 지를 검정하는 경우 귀무가설은 \\(H_0: \\alpha_1=\\dots=\\alpha_a=0\\) 이었다. 이제 변량 모형에서는 집단 간의 변동이 없는지 검정하는 것이므로 다음과 같은 가설을 고려한다.\n\\[\nH_0 : \\sigma_A^2 = 0 \\quad \\text{vs. } \\quad H_1: \\sigma^2_A &gt;0\n\\tag{C.4}\\]\n분산성분 \\(\\sigma_A^2\\)가 0 이라는 의미는 모든 \\(\\alpha_i\\) 가 0이고 이는 집단 간의 차이가 없는 상황을 의미한다. 위의 가설을 검정하는 방법은 고정효과 모형과 동일하다. 즉 다음과 같은 조건이 만족되면 귀무가설을 기각한다.\n\\[ \\text{reject } H_0 \\text{ if } F_0 = \\frac{MS_A}{MS_E} &gt; F[1-\\alpha, a-1,a(r-1)] \\]",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>혼합 모형</span>"
    ]
  },
  {
    "objectID": "qmd/raneff.html#예제-3.3",
    "href": "qmd/raneff.html#예제-3.3",
    "title": "부록 C — 혼합 모형",
    "section": "C.4 예제 3.3",
    "text": "C.4 예제 3.3\n교과서 59 페이지에 있는 예제를 R 프호그램을 사용하여 풀어보자.\n화학약품 회사에서는 매년 원자재의 수백 개의 배치(batch)를 정제하여 순도가 높은 화학약품을 만든다. 품질 관리를 위하여 수백 개의 배치들 중에서 5개를 랜덤하게 선택하고 배치당 3개의 시료를 채취한 후에 순도를 측정하였다.\n배치마다 순도가 크게 다르면 품질을 일정하게 유지할 수 없눈 문제가 생긴다. 따라서 실험의 목적은 품질 관리이며 배치 간의 변동과 배치 내의 변동을 알아보는 것이다.\n\nC.4.1 자료\n다음과 같이 자료를 만들자\n\nresponse &lt;- c( 74, 76, 75,\n               68, 71, 72,\n               75, 77, 77,\n               72, 74, 73,\n               79, 81, 79)\nbatch &lt;- factor(rep(1:5, each=3))\ndf &lt;- data.frame(batch, response)\ndf\n\n   batch response\n1      1       74\n2      1       76\n3      1       75\n4      2       68\n5      2       71\n6      2       72\n7      3       75\n8      3       77\n9      3       77\n10     4       72\n11     4       74\n12     4       73\n13     5       79\n14     5       81\n15     5       79\n\n\n\n\nC.4.2 추정과 가설검정\n변량모형을 적합시키기 위해서는 lme4 패키지 가 필요하다. 일워배치 변량모형을 적합시키는 함수는 lmer이며 다음과 같이 사용한다. 아래 모형식에서 1은 평균 \\(\\mu\\)를 나타내고 (1|batch)는 배치에 대한 임의 효과 \\(\\alpha_i\\)를 나타낸다.\n\nres &lt;- lmer(response ~ 1 + (1|batch), data=df ) \nsummary(res)\n\nLinear mixed model fit by REML. t-tests use Satterthwaite's method [\nlmerModLmerTest]\nFormula: response ~ 1 + (1 | batch)\n   Data: df\n\nREML criterion at convergence: 62.8\n\nScaled residuals: \n     Min       1Q   Median       3Q      Max \n-1.90384 -0.53153  0.00484  0.61386  1.16817 \n\nRandom effects:\n Groups   Name        Variance Std.Dev.\n batch    (Intercept) 11.71    3.422   \n Residual              1.80    1.342   \nNumber of obs: 15, groups:  batch, 5\n\nFixed effects:\n            Estimate Std. Error     df t value Pr(&gt;|t|)    \n(Intercept)   74.867      1.569  4.000   47.71 1.15e-06 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\n위의 결과에서 다음과 같은 추정값을 얻는다.\n\n\\(\\hat \\mu = 74.867\\)\n\\(\\hat \\sigma^2_A = 11.71\\)\n\\(\\hat \\sigma_E^2 = 1.80\\)\n\n따라서 급내 상관계수(기여율)의 추정값은 다음과 같다.\n\\[ \\hat \\rho = \\frac{\\hat \\sigma^2_A }{\\hat \\sigma^2_A + \\hat \\sigma^2_E }\n= \\frac{11.7}{11.7 + 1.8} = 0.867 \\]\n위의 \\(\\hat \\rho=0.867\\)을 기여율로 해석하면 총변동 중에서 배치 간의 변동이 차지하는 비율이 86.7% 이라는 것이다.\n또한 \\(H_0: \\sigma_A^2=0\\) 에 대한 검정은 다음과 같이 aov함수를 사용하여 수행할 수 있다.\n\nsummary(aov(response ~ batch, data=df ))\n\n            Df Sum Sq Mean Sq F value   Pr(&gt;F)    \nbatch        4  147.7   36.93   20.52 8.25e-05 ***\nResiduals   10   18.0    1.80                     \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n\np-값이 유의수준 5% 보다 매우 작으므로 \\(H_0\\)를 기각한다. 배치 간 변동이 유의하다고 할 수 있다. 따라서 품질이 배치 간에 따라서 크게 다르다.\n\n\n\n\nSchabenberger, Oliver, 와/과 Francis J Pierce. 2001. Contemporary statistical models for the plant and soil sciences. CRC press.",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>C</span>  <span class='chapter-title'>혼합 모형</span>"
    ]
  },
  {
    "objectID": "qmd/comfound.html",
    "href": "qmd/comfound.html",
    "title": "부록 D — 교락",
    "section": "",
    "text": "교락(confounding)은 실험 또는 표본 추출의 방법에서 서로 다른 두 효과가 섞여서 자료를 통하여 구별할 수 없는 경우를 말한다. 실험계획에서 교락은 대부분 처리 효과와 오차/임의효과를 구별할 수 없는 경우에 발생한다.\n여러분이 반복이 없는 이원배치법에서는 상호작용과 오차가 교락되어 상호작용에 대한 추론을 할 수 없다고 배웠다.\n\nD.0.1 일원배치\n이러한 교락의 개념을 이해하기 위하여 가장 간단한 실험 계획인 일원배치를 생각하고 반복이 있는 경우와 없는 경우를 생각해 보자.\n\n\n\n일원배치: 반복이 없는 경우와 있는 경우\n\n\n\n반복이 없는 일원배치\n\n위의 그림에서 반복이 없는 일원배치에서는 처리효과와 실험단위(오차항)가 교락되어 구별할 수 없다.\n예를 들어 철수에게는 A 약을 처방하고 영이에게는 B 약을 처방한 경우, 만약 철수의 치료 효과가 영이보다 좋으면 A 약의 효과가 더 좋다고 말할 수 있는가? 이런 경우 약의 효과인지 실험 대상인 개인의 특성인지 알 수 없다.\n반복이 없는 일원배치에서는 효과의 차이를 알 수 있는 통계량이 두 관측값의 차이 \\(x_1 - x_2\\) 밖에 없으며 이를 모형식으로 보면 다음과 같다.\n\\[ x_1 - x_2 = \\alpha_1 - \\alpha_2 + e_1 - e_2 \\]\n즉 처리 효과 \\(\\alpha_i\\)와 오차 \\(e_i\\)의 효과를 분리해야 하는데 사용할 수 있는 통계량이 하나 밖에 없어서 처리효과에 대한 추론이 불가능하다.\n여기서 유의할 점은 두 관측값의 차이 \\(x_1 - x_2\\) 와 평균으로부터 편차 \\(x_1 -\\bar x\\)는 기본적으로 같은 정보를 가진 통계량이다.\n\\[\nx_1 -\\bar x = \\frac{x_2 - x_1}{2}\n\\]\n\n반복이 있는 일원배치\n\n반복이 있는 일원배치의 경우 우리는 2개의 편차를 만들 수 있으며 두 편차가 가지고 정보에서 처리 효과에 대한 정보를 분리해 낼수 있다.\n\\[\n\\begin{aligned}\nx_{11} - \\bar { \\bar x }  & = ( x_{11} - \\bar x_{1.}) +  (  {\\bar x}_{1.} - \\bar { \\bar x }) \\\\\n  & = \\frac{1}{2} \\left [ (-1)x_{12} +(1) x_{11} + (0)x_{21} + (0) x_{22} \\right ] \\\\\n   &~ + \\frac{1}{4}  \\left [ (1)x_{12} +(1) x_{11} + (-1)x_{21} + (-1) x_{22} \\right ]  \\\\\n  & =  ( e_{11} -  {\\bar e}_{1.} ) +  ( [\\alpha_1 - \\bar \\alpha] - [ {\\bar e}_{1.} - \\bar {\\bar e} ])\n\\end{aligned}\n\\]\n반복이 있는 일원배치에서 잔차제곱합 \\(MS_E\\)는 \\(x_{ij} - \\bar x_{i.}\\)가 지닌 정보, 즉 오차항의 분산에 대한 정보를 가지고 있다. 또한 \\(MS_A\\)는 \\(\\bar x_{i.}- \\bar { \\bar x }\\) 가 지닌 정보, 즉 오차항의 분산과 처리 효과의 정보 모두 가지고 있다. 이러한 사실은 각 평균제곱합의 기대값을 보면 알 수 있다.\n제곱합의 기대값을 구하는 방법은 섹션 C.3.3 을 참조하자.\n\\[\nE (MS_E) = \\sigma_E^2,  \\quad E(MS_A) = \\sigma^2_E + r \\frac {\\sum_i^a (\\alpha_i - \\bar \\alpha)^2}{a-1}  \n\\]\n따라서 처리효과가 있는지에 대한 검정은 \\(MS_E\\)와 \\(MS_E\\)의 비(ratio)를 이용하여 검정한다(F-검정).\n\n\nD.0.2 완전 랜덤화 이원배치\n이제 이원배치에서 반복이 없는 경우와 있는 경우를 살펴보자.\n\nD.0.2.1 반복이 없는 이원배치\n\n\n\n이원배치: 반복이 없는 경우\n\n\n반복이 없는 이원배치는 관측자료의 편차를 각 효과에 대한 편차들로 다음과 같이 분해할 수 있다.\n\\[\n\\underbrace{ ( {x}_{ij} - \\bar{\\bar {x}} )}_{\\text{total deviation}}= \\underbrace{( {\\bar x}_{i.} - \\bar{\\bar {x}} ) }_{\\text{A effect}} + \\underbrace{( {\\bar x}_{.j} - \\bar{\\bar {x}} ) }_{\\text{B effect}} + \\underbrace{ ( x_{ij} -{\\bar x}_{i.} - {\\bar x}_{.j} + \\bar{\\bar {x}}  )}_{\\text{(A x B) + residual}}\n\\] 위의 분해에서 이원배치 모형식을 이용하여 마지막 항 \\(x_{ij} -{\\bar x}_{i.} - {\\bar x}_{.j} + \\bar{\\bar {x}}\\) 을 모수와 오차로 표현해보면 다음과 같다.\n\\[\nx_{ij} -{\\bar x}_{i.} - {\\bar x}_{.j} + \\bar{\\bar {x}}  =\n[ (\\alpha \\beta)_{ij} - \\bar {(\\alpha \\beta)}_{i. } -\\bar {(\\alpha \\beta)}_{.j} + \\bar {\\bar {(\\alpha \\beta)}} ]  +\n[ e_{ij} - \\bar {e}_{i. } -\\bar {e}_{.j} + \\bar {\\bar {e}}]\n\\tag{D.1}\\]\n위의 식을 보면 편차 \\(x_{ij} -{\\bar x}_{i.} - {\\bar x}_{.j} + \\bar{\\bar {x}}\\) 는 상호작용에 대한 정보와 오차항의 정보가 섞여 있고 더 이상 분리할 수 없음을 알 수 있다. 따라서 상호작용과 오차항은 교락되어 있다.\n\n\nD.0.2.2 반복이 있는 이원배치\n\n\n\n이원배치: 반복이 있는 경우\n\n\n반복이 있는 이원배치는 관측자료의 편차를 각 효과에 대한 편차들로 다음과 같이 분해할 수 있다. 주목할 점은 반복이 있기 떄문에 반복이 없는 경우보다 하나의 항 \\(x_{ijk} - {\\bar x}_{ij.}\\) 이 추가된다.\n\\[\n\\underbrace{ (x_{ijk} - \\bar{\\bar {x}}) }_{\\text{total deviation}} =\n\\underbrace{( {\\bar x}_{i..} - \\bar{\\bar {x}} ) }_{\\text{A effect}} + \\underbrace{( {\\bar x}_{.j.} - \\bar{\\bar {x}} ) }_{\\text{B effect}} + \\underbrace{ ( {\\bar x}_{ij.} -{\\bar x}_{i..} - {\\bar x}_{.j.} + \\bar{\\bar {x}}  )}_{\\text{A x B}}\n+ \\underbrace{ ( x_{ijk} - {\\bar x}_{ij.} )}_{\\text{residual}}\n\\]\n반복이 있는 이원배치 모형에서 상호작용에 대한 편차는 반복이 없는 경우의 식 @ref(eq:inter)과 유사하게 다음과 같이 표시할 수 있다.\n\\[\nx_{ij.} -{\\bar x}_{i..} - {\\bar x}_{..j} + \\bar{\\bar {x}}  =\n[ (\\alpha \\beta)_{ij.} - \\bar {(\\alpha \\beta)}_{i. } -\\bar {(\\alpha \\beta)}_{.j} + \\bar {\\bar {(\\alpha \\beta)}} ] +\n[ e_{ij.} - \\bar {e}_{i.. } -\\bar {e}_{.j.} + \\bar {\\bar {e}}]\n\\]\n또한 잔차에 대한 편차는 다음과 같이 표시된다.\n\\[\nx_{ijk} - {\\bar x}_{ij.} = e_{ijk} - \\bar {e}_{ij. }\n\\] 이제 잔차에 대한 편차는 순수허게 오차항만의 정보를 가지고 있고 상호작용에 대한 편차는 상호작용과 오차에 대한 정보를 가지고 있다. 따라서 두 편차로 만든 두 개의 제곱합을 이용하면 상호작용에 대한 효과를 분리해낼 수 있다.\n따라서 상호작용 효과가 있는지에 대한 검정은 \\(x_{ij.} -{\\bar x}_{i..} - {\\bar x}_{..j} + \\bar{\\bar {x}}\\) 로 계산된 \\(MS_{(A \\times B)}\\)와 \\(x_{ijk} - {\\bar x}_{ij.}\\) 로 만들어진 \\(MS_E\\)의 비(ratio)를 이용하여 검정한다(F-검정).",
    "crumbs": [
      "Appendices",
      "<span class='chapter-number'>D</span>  <span class='chapter-title'>교락</span>"
    ]
  }
]